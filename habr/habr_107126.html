<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Objective-C с нуля / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.0f7bdd8f.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.670ab961.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.01bb2993.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.76acc47b.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-f458c7c4.e48e8f79.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-f458c7c4.6e221df6.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.0f7bdd8f.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.01bb2993.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-f458c7c4.e48e8f79.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.4f7c12b4e1b1b4c0e44ef6f9f33b1f9f.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/107126\/"},"headline":"Objective-C с нуля","datePublished":"2010-10-29T17:40:01+04:00","dateModified":"2011-03-23T12:48:28+03:00","author":{"@type":"Person","name":"Anthony Shoumikhin"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"У любого желающего писать программы для продукции фирмы Apple в жизни наступает такой момент, когда ему приходиться изучить новый язык программирования &mdash; Objecti...","url":"https:\/\/habr.com\/ru\/post\/107126\/#post-content-body","about":["h_ios_dev","f_develop"],"image":["https:\/\/habrastorage.org\/storage\/f1073050\/7aff6749\/77739192\/fd020592.png","https:\/\/habrastorage.org\/storage\/29b3f167\/006356ff\/88414a4a\/cb4d17e5.png","https:\/\/habrastorage.org\/storage\/53e1c6cb\/4d30e3d1\/ecfababe\/9dcb8d2a.png","https:\/\/habrastorage.org\/storage\/d18a0af3\/844fdcce\/1285d539\/5e2f0c3b.png","https:\/\/habrastorage.org\/storage\/194952d8\/4bbdb524\/3a81ab57\/01842029.png","https:\/\/habrastorage.org\/storage\/8d94a5cd\/18d3a791\/33c7f9ac\/a1811278.png"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.47.1">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Objective-C с нуля" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Objective-C с нуля" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Objective-C с нуля" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="У любого желающего писать программы для продукции фирмы Apple в жизни наступает такой момент, когда ему приходиться изучить новый язык программирования — Objective-C. Когда-то этот счастливый момент..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="У любого желающего писать программы для продукции фирмы Apple в жизни наступает такой момент, когда ему приходиться изучить новый язык программирования — Objective-C. Когда-то этот счастливый момент..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="У любого желающего писать программы для продукции фирмы Apple в жизни наступает такой момент, когда ему приходиться изучить новый язык программирования — Objective-C. Когда-то этот счастливый момент..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="У любого желающего писать программы для продукции фирмы Apple в жизни наступает такой момент, когда ему приходиться изучить новый язык программирования — Objective-C. Когда-то этот счастливый момент..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="У любого желающего писать программы для продукции фирмы Apple в жизни наступает такой момент, когда ему приходиться изучить новый язык программирования — Objective-C. Когда-то этот счастливый момент..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/107126/68a66d15c08113e69ea1745d4b3941ff/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/107126/68a66d15c08113e69ea1745d4b3941ff/" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/107126/68a66d15c08113e69ea1745d4b3941ff/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/107126/68a66d15c08113e69ea1745d4b3941ff/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/107126/68a66d15c08113e69ea1745d4b3941ff/" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="107126" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2010-10-29T13:40:01.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/107126/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/107126/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/107126/68a66d15c08113e69ea1745d4b3941ff/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.cee85629.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
              Как стать автором
            </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.cee85629.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.cee85629.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.cee85629.svg#pull-arrow"></use></svg></div></div> <!----> <div class="tm-page-article__body"><article class="tm-page-article__content tm-page-article__content_inner"><div class="tm-page-article__head-wrapper"><!----> <div class="tm-article-snippet tm-page-article__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/shoumikhin/" title="shoumikhin" class="tm-user-info__userpic"><div class="tm-entity-image"><svg height="24" width="24" class="tm-svg-img tm-image-placeholder tm-image-placeholder_green"><!----> <use xlink:href="/img/megazord-v24.cee85629.svg#placeholder-user"></use></svg></div></a> <span class="tm-user-info__user"><a href="/ru/users/shoumikhin/" class="tm-user-info__username">
      shoumikhin
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2010-10-29T13:40:01.000Z" title="2010-10-29, 17:40">29  октября  2010 в 17:40</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Objective-C с нуля</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/ios_dev/" class="tm-article-snippet__hubs-item-link"><span>Разработка под iOS</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <!----> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><img align="left" src="/img/image-loader.svg" data-src="https://habrastorage.org/storage/f1073050/7aff6749/77739192/fd020592.png"/>У любого желающего писать программы для продукции фирмы Apple в жизни наступает такой момент, когда ему приходиться изучить новый язык программирования — Objective-C. Когда-то этот счастливый момент постиг и меня. А чтобы лучше запомнить основные особенности этого языка, решил законспектировать свои мысли во время осмысления его документации, которыми и делюсь с вами. <br/>
<a name="habracut"></a><br/>
<h3>Банальная теория возникновения ООП</h3><br/>
Проблема повторного использования написанного кода и его переносимость постоянно заставляет программистов искать все новые пути его упорядочивания, структуризации и абстрагирования. Для решения этих проблем создаются новые парадигмы программирования, шаблоны проектирования, новые языки, компиляторы и стандартные библиотеки к ним, программные платформы и фреймворки. Так образовались парадигма подпрограмм (процедур), реализуемая при помощи процессорных команд CALL\RET и стека (по сути, перенос потока выполнения по адресу произвольной, а не следующей за текущей команды, с последующим возвратом). Затем, парадигма модулей (каждый файл – отдельная единица трансляции), породившая двухэтапную трансляцию: компиляция модулей, а затем их компоновка (статическая или динамическая) в исполняемый модуль.<br/>
<br/>
В следствии увеличения объема кода в проектах и сложностей его поддержки, с 1960х начинает образовываться новая, объектно-ориентированная парадигма программирования, разбившая программы на еще более мелкие составляющие – типы данных. Ее суть заключается во взаимодействии сущностей (объектов) посредством посылки друг другу сообщений. Каждый объект является переменной определенного программистом типа данных (так называемого класса). Определение такого специального пользовательского типа данных (класса) заключается в двух вещах: определении набора данных (инвариантов, членов) и набора подпрограмм (методов), которые будут их обслуживать.<br/>
<br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" data-src="https://habrastorage.org/storage/29b3f167/006356ff/88414a4a/cb4d17e5.png"/></div><br/>
Класс обычно оформляется как определенный программистом тип, основанный на встроенных (языковых) типах данных и\или других классах. Для языка С, не поддерживающего объектно-ориентированную парадигму, это может быть структура (struct). А набор подпрограмм реализуется как обычные функции, обязательно принимающие как минимум один параметр — указатель на набор данных, подлежащих обработке.<br/>
<br/>
Основным преимуществом объектно-ориентированного подхода стала возможность создавать новые классы на основе уже написанных (добавлять инварианты и методы, переопределять методы, использовать определенные в базовом классе методы как свои), названное наследованием.<br/>
<br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" data-src="https://habrastorage.org/storage/53e1c6cb/4d30e3d1/ecfababe/9dcb8d2a.png"/></div><br/>
Набор методов представляет собой интерфейс для взаимодействия с инвариантами. Невозможность непосредственной модификации данных класса (без задействования его интерфейса) отражает принцип инкапсуляции. На рисунке показан класс и его объекты. Имеется инвариант x типа float и к нему интерфейс (метод) doubleX, возвращающий значение инварианта.<br/>
<br/>
Бывает, что необходимо послать сообщение объекту, который на него определенно отвечает (т.е. вызвать для объекта класса такой метод, который он реализовал), но, по ситуации, конкретный класс этого объекта неизвестен. Например, каждому элементу списка указателей на объекты класса Auto нужно послать сообщение Move, а известно что в списке находятся указатели на объекты не только класса Auto, но также и указатели на производные (наследованные) классы Ford и Subaru. Это возможно сделать только благодаря принципу полиморфизма, заключающегося в том, что при посылке определенного сообщения объекту из некой иерархии классов, в которой все объекты способны принять такое сообщение, этот объект реагирует на него соответственно своему, а не базовому для данной иерархии классу.<br/>
<br/>
Первым языком с поддержкой объектно-ориентированного подхода стал Simula67. Затем появился Smalltalk. А в 80х начал оформляться С++ — основной язык современного системного программирования. Его расширение и усовершенствование в 90х породило ряд парадигм и шаблонов проектирования, и оказало необратимое влияние на современное видение объектно-ориентированного подхода, в том числе, и на язык Objective-C.<br/>
<br/>
<h3>Чуть-чуть истории</h3><br/>
Objective-C возник в 80-x как модификация С в сторону Smalltalk. Причем модификация эта состояла в добавлении новых синтаксических конструкций и специальном препроцессоре для них (который, проходя по коду преобразовывал их в обычные вызовы функций С), а также библиотеке времени выполнения (эти вызовы обрабатывающей). Таким образом, изначально Objective-C воспринимался как надстройка над C. В каком-то смысле это так и до сих пор: можно написать программу на чистом С, а после добавить к ней немного конструкций из Objective-C (при необходимости), или же наоборот, свободно пользоваться С в программах на Objective-C. Кроме того, все это касается и программ на С++. В 1988 NeXT (а в последствии Apple) лицензировала Objective-C и написала для него компилятор и стандартную библиотеку (по сути SDK). В 1992 к усовершенствованию языка и компилятора подключились разработчики проекта GNU в рамках проекта OpenStep. С тех пор GCC поддерживает Objective-C. После покупки NeXT, Apple взяля их SDK (компилятор, библиотеки, IDE) за основу для своих дальнейших разработок. IDE для кода назвали Xcode, а для GUI – Interface Builder. Фреймворк Cocoa для GUI разработок (и не только) на сегодня является наиболее значимой средой разработки программ на Objective-C.<br/>
<br/>
<h3>Особенности Objective-C</h3><br/>
Файлы модулей на Objective-C имеют расширение “.m” (если использовалась смесь С++ и Objective-С, то расширение “.mm”). Заголовочные файлы – “.h”. Все, создаваемые в Objective-С объекты классов должны размещатся в динамической памяти. Поэтому особое значение приобретает тип id, который является указателем на объект любого класса (по сути void *). Нулевой указатель именуется константой nil. Таким образом, указатель на любой класс можно привести к типу id. Возникает проблема: как узнать к какому классу относится объект, скрывающийся под id? Это делается благодаря инварианту isa, который присутствует в любом объекте класса, унаследовавшего специальный базовый клас NSObject (приставка NS обозначает NeXT Step). Инвариант isa относится к зарезервированному типу Class. Объект такого типа позволяет узнавать имена своего и базового класса, набор инвариантов класса, а также прототипы всех методов, которые реализовал этот объект и их адреса (посредством локального списка селекторов). Все зарезервированные слова Objective-C, отличающиеся от зарезервированных слов языка С, начинаются с символа @ (например  @protocol,  <a href="https://habrahabr.ru/users/selector/" class="user_link">selector</a>,  <a href="https://habrahabr.ru/users/interface/" class="user_link">interface</a>). Обычно имена инвариантов классов с ограниченной областью видимости (@private,  <a href="https://habrahabr.ru/users/protected/" class="user_link">protected</a>) начинаются с символа подчеркивания. Для строк в Cocoa имеется очень удобный класс NSString. Строковая константа такого класса записывается как @”Hello world”, а не как обычная для С строковая константа “Hello world”. Тип BOOL (по сути unsigned char) может принимать константные значения YES и NO. Все особые для Objective-C зарезервированные слова (которые отличаются от языка С и находятся в заголовочном файле objc/objc.h) приведены ниже:<br/>
<ul>
<li> <a href="https://habrahabr.ru/users/interface/" class="user_link">interface</a> Начинает объявление класса или категории (категория – расширение класса дополнительными методами без наследования)</li>
<li>@implementation Начинает определение класса или категории</li>
<li> @protocol Начинает объявление протокола (аналог класса С++, состоящего из чисто виртуальных функций)</li>
<li> <a href="https://habrahabr.ru/users/end/" class="user_link">end</a> Завершает объявление\определение любого класса, категории или протокола</li>
<li>@private Ограничивает область видимости инвариантов класса методами класса (аналогично С++)</li>
<li> <a href="https://habrahabr.ru/users/protected/" class="user_link">protected</a> Стоит по умолчанию. Ограничивает область видимости инвариантов класса методами класса и методами производных классов (аналогично С++)</li>
<li>@public Удаляет ограничения на облать видимости (аналогично С++)</li>
<li> <a href="https://habrahabr.ru/users/try/" class="user_link">try</a> Определяет блок с возможной генерацией исключений (аналогично С++)</li>
<li> @throw Генерирует объект-исключение (аналогично С++)</li>
<li> <a href="https://habrahabr.ru/users/catch/" class="user_link">catch</a> () Обрабатывает исключение, сгенерированное в предшествующем блоке  <a href="https://habrahabr.ru/users/try/" class="user_link">try</a> (аналогично С++)</li>
<li> <a href="https://habrahabr.ru/users/finally/" class="user_link">finally</a> Определяет блок после блока  <a href="https://habrahabr.ru/users/try/" class="user_link">try</a>, в который предается куправление независимо от того, было или нет сгенерировано исключение</li>
<li>@class Сокращенная форма объявления класса (только имя (аналогично С++))</li>
<li> <a href="https://habrahabr.ru/users/selector/" class="user_link">selector</a>(method_name) Возвращает скомпилированный селектор для имени метода method_name</li>
<li> @protocol(protocol_name) Ворзвращает экземпляр класса-протокола с именем protocol_name</li>
<li>@encode(type_spec) Инициализирует строку символов, которая будет использована для шифрования данных типа type_spec</li>
<li>@synchronized() Определяет блок кода, выполняющегося только одной нитью в любой определенный момент времени</li>
</ul><br/>
<h3>Обмен сообщениями</h3><br/>
Чтобы заставить объект выполнить какой-нибудь метод нужно послать ему сообщение, именуемое так же, как и требуемый метод. Такое сообщение называется селектор метода. Синтаксис посылки таков:<br/>
<br/>
<pre><code class="cpp">[receiver method];
</code></pre><br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" data-src="https://habrastorage.org/storage/d18a0af3/844fdcce/1285d539/5e2f0c3b.png"/></div><br/>
В сообщении можно передавать параметры для вызываемого метода:<br/>
<br/>
<pre><code class="cpp">[receiver method: 20.0 : 30.0];
</code></pre><br/>
Перед каждым параметром необходимо ставить двоеточие. Сколько двоеточий – столько и параметров. Имя метода может продолжаться после каждого такого двоеточия-параметра:<br/>
<br/>
<pre><code class="cpp">[receiver methodWithFirstArgument: 10 andSecondArgument: 20];
</code></pre><br/>
Методы с неограниченным количством аргументов вызываюся следующим синтаксисом:<br/>
<br/>
<pre><code class="cpp">[receiver undefinedNumberParameters: one, two, three, four, five, six, seven];
</code></pre><br/>
Посылка сообщения, как и любая функция C, возвращает определенное (может void) значение:<br/>
<br/>
<pre><code class="cpp">BOOL booleanValue;
booleanValue = [reveiver method];
</code></pre><br/>
При посылке сообщения nil оно просто пропадает. При посылке сообщения объекту, который принадлежит классу, не реализовавшему заказанный метод, возникает исключение, которое, будучи не перехваченным, приводит всю программу к незапланированному завершению. Для проверки, отвечает ли данный объект на кокое-либо сообщение можно использовать следующий шаблон кода:<br/>
<br/>
<pre><code class="cpp">if ([anObject respondsToSelector: @selector(myMethodWith2Argumets::)])
{
//можно вызывать
[anObject myMethodWith2Argumetns: @”first” : @”second”];
}
else
{
//ни в коем случае не вызывать
}
</code></pre><br/>
<br/>
<h3>Как работает передача сообщений</h3><br/>
Посылка сообщения транслируется в С-функцию с прототипом:<br/>
<br/>
<pre><code class="cpp">id objc_msgSend(id receiver, SEL method, ...);
</code></pre><br/>
Тип SEL, по сути, определен как char const *, но лучше воспринимать его как int, поскольку во время выполнения все селекторы индексируются целыми значениями согласно глобальной таблице селекторов.<br/>
<br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" data-src="https://habrastorage.org/storage/194952d8/4bbdb524/3a81ab57/01842029.png"/></div><br/>
Пользуясь инвариантом isa объекта receiver (при использовании фреймворка Foundation, базового для Cocoa, все классы должны наследовать класс NSObject, поэтому наличие isa неизбежно), эта функция просматривает локальный список селекторов класса с целью определить, отвечает ли объект данного класса на сообщение method. Если такой селектор находится, то управление передается соответствующему методу класса, которому передается id объекта (указатель на его инварианты) и указанные после селектора параметры функции objc_msgSend(). Значение, возвращенное методом, отдается как результат посылки сообщения. Если у объекта-приемника данный селектор отсутствует, функции objc_msgSend() просматривает список селекторов его базового класса.<br/>
<br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" data-src="https://habrastorage.org/storage/8d94a5cd/18d3a791/33c7f9ac/a1811278.png"/></div><br/>
При такой схеме вызов, например:<br/>
<br/>
<pre><code class="cpp">[receiver аddObject: otherObject];
</code></pre><br/>
Транслируется в:<br/>
<br/>
<pre><code class="cpp">objc_msgSend(receiver, 12, otherObject);
</code></pre><br/>
Так как в глобальной таблице селекторов 12 соответствует строке “addObject:”. Далее функция objc_msgSend() выполняет поиск по списку селекторов объекта receiver и, найдя его (пусть это объект класса NSArray, который реализовал метод с селектором 12), производит вызов типа:<br/>
<br/>
<pre><code class="cpp">addObject(receiver, otherObject);
</code></pre><br/>
<br/>
<h3>Объявление метода</h3><br/>
Интересно отметить, что прототип метода addObject из предыдущего раздела в объявлении класса выглядел так:<br/>
<br/>
<pre><code class="cpp">- (void)addObject: (id)otherObject;
</code></pre><br/>
То есть принимал всего один параметр. Но, исходя из принципа объектно-ориентированной парадигмы, что методы – это подпрограммы, обрабатывающие определенные наборы данных, методу необходимо передавать адресс данных, подлежащих обработке. Поэтому такой параметр передается во всякий метод класса неявно. Компилятору об этом дополнительном параметре дает понять минус ("-"), стоящий первым в прототипе метода. Такой метод (с минусом впереди) называется методом объекта (или экземпляра), т.к. может быть вызван только для объекта какого-нибудь класса. В теле метода этот указатель на экземпляр данных (или адрес объекта, которому послали сообщение) доступен посредством зарезервированного слова self (аналог this в С++), а указатель на экземпляр базового класса – через зарезервированное слово super. Кроме того, в метод объекта также передается неявный параметр _cmd – селектор этого метода из глобальной таблицы селекторов. С точки зрения программиста С++ все методы объектов в Objective-C как-будто объявлены с ключевым словом virtual, и всегда следуют динамическому полиморфизму.<br/>
<br/>
Если в начале прототипа метода поставить знак плюс (“+”), то такой метод будет считаться методом класса, и, естественно, не будет принимать неявный параметр self (это аналогично объявлению static-метода в С++). А без инварианта isa объекта, на который указывает self, указатель super работать, конечно, тоже не будет.<br/>
Таким образом, прототип любого метода объявляется так:<br/>
<br/>
<pre><code class="cpp">-|+ (&lt;тип возвращаемого значения>) основнаяЧастьИмениМетода
[ : (&lt;тип первого параметра>)имяПервогоФормальногоПараметра
[ [дополнительнаяЧастьИмениМетода] : (&lt;тип второго параметра>)имяВторогоФормальногоПараметра]
… ]
</code></pre><br/>
Например:<br/>
<br/>
<pre><code class="cpp">+ (Class)class;
+ (id)alloc;
- (id)init;
- (void)addObject: (id)anObject;
+ (NSString *)stringWithCString: (const char*)aCString usingUncoding: (enum NSStringEncoding)encoding;
- (NSString *)initStringWithFormat: (NSString *)format, …;
</code></pre><br/>
Если метод возвращает некий объект (тип id) или класс (тип Class), можно воспользоваться вложенным синтаксисом вызова:<br/>
<br/>
<pre><code class="cpp">[myLabel setText: [[NSString stringWithString: @”Hello”] stringByAppendingString: @” world”]];
</code></pre><br/>
Здесь объекту класса UILabel из фреймворка UIKit устанавливается значение инварианта text равное строке @”Hello world”. Эта строка, в свою очередь, образована конкатенацией строк @”Hello” и @” world”. Первая является результатом посылке сообщения stringWithString классу NSString с параметром-константой @”Hello”. Такой вызов возвращает объект класса NSString, инициализированный строкой-параметром. Затем этому объекту посылается сообщение stringByAppendingString с параметром @” world”. Результат посылки этого сообщения и есть объект класса NSString, содержащий конкатенацию значения объекта-приемника и строкового аргумента. Этот объект и попадает как параметр в сообщение setText: объекта myLabel.<br/>
<br/>
<h3>Объявление класса</h3><br/>
Объявим простой класс комплексного числа в файле Complex.h:<br/>
<br/>
<pre><code class="cpp">#import &lt;Foundation/Foundation.h> //для NSObject и строк NSString

@interface Complex : NSObject
{
double _re; //инвариант для действительной части
double _im; //инвариант для мнимой части
NSString *_format; //строка формата для метода description
}
- (id)initWithRe: (double)re andIm: (double)im; //специализированный конструктор
+ (Complex *)complexWithRe: (double)re andIm: (double)im; //метод класса для одноэтапного создания объекта
- (Complex *)add: (Complex *)other; //метод для сложения
- (Complex *)sub: (Complex *)other; //метод для вычетания
- (NSString *)format; //метод доступа к _format
- (void)setFormat: (NSString *)format; //метод установки _format
- (double)re; //остальные методы доступа к действительной и мнимой частям
- (void)setRe: (double)re;
- (double)im;
- (void)setIm: (double)im;
@end
</code></pre><br/>
Как видим, все объявление заключено в ключевые слова  <a href="https://habrahabr.ru/users/interface/" class="user_link">interface</a> и  <a href="https://habrahabr.ru/users/end/" class="user_link">end</a>. Первым делом объявляются инварианты (в фигурных скобках). Вне фигурных скобок объявляются методы. Метод description отсутствует в объявлении класса не случайно. Дело в том, что он, как и метод dealloc и init, присутствует в определении класса. При посылке объекту класса Complex сообщения description будет рассмотрен его локальный список селекторов, куда, после компиляции, попадут селекторы всех методов, реализованных классом этого объекта, даже не объявленные в интерфейсной части. То есть init, description и dealloc будут вызывать абсолютно корректно.<br/>
<br/>
<h3>Создание объектов</h3><br/>
В связи с тем, что все объекты распределяютя в динамической памяти, cоздание объекта приходится проводить в два этапа: 1) выделении памяти (сообщение alloc) и 2) инициализация инвариантов (конструкторы класса).<br/>
<br/>
<pre><code class="cpp">MyClass *myObject = [[MyClass alloc] init];  //метод класса MyClass alloc выделяет участок памяти нужного размера и возвращает указатель на него, метод объекта init инициализирует инварианты объекта myObject
</code></pre><br/>
После создания объекта им можно смело пользоваться:<br/>
<br/>
<pre><code class="cpp">NSMutableArray *array = [[NSMutableArray alloc] init]; //создаем изменяемый массив
MyClass *myObject = [[MyClass alloc] init]; //наш объект
[myObject myMethod]; //посылка некоторого сообщения
[array addObject: myObject]; //помещаем объект в массив
MyClass *otherObject = [array getLastObject:]; //достаем его из массива, указываем на него другим указателем
[otherObject myOtherMethod: YES]; //посылаем ему другое сообщение с аргументом типа BOOL
</code></pre><br/>
Некоторые классы обладают методом для быстрого (в один этап) создания собственных экземпляров. Такие методы являются методами класса, возвращают указатель на объект своего класса и их имя обычно начинается с названия самого класса. Например метод:<br/>
<br/>
<pre><code class="cpp">+ (NSString *)stringWithCString: (char const *)string encoding: (NSStringEncoding)encoding;
</code></pre><br/>
Возвращает уже готовую строку, инициализированную соответствующей сторокой с завершающим нулем, без вызовов alloc и init:<br/>
<br/>
<pre><code class="cpp">NSString *myString = [NSString stringWithCString: “Bla-bla-bla” encoding: NSASCIIStringEncoding];
</code></pre><br/>
<br/>
<h3>Время жизни объекта</h3><br/>
Как только указатель на объект выходит за свою область видимости, память, выделенная под него, безвозвратно теряется (если, конечно, это был последний указатель на тот объект) и происходит утечка. Дабы избежать таких нежелательных последствий в Objective-C поддерживается парадигма подсчета ссылок на ресурсы. Таким образом, у каждого объекта есть целочисленный счетчик, который показывает количество ссылающихся на него указателей. По достижению этим счетчиком нуля, память, выделенная для данного объекта, возвращается системе. После вызова метода класса alloc, этот счетчик равен единице. Чтобы увеличить его значение необходимо послать объекту сообщение retain, а чтобы уменьшить – release. Все эти методу реализует NSObject, который любой наш класс непременно наследует. Интересно отметить, что значение счетчика для статических объектов класса NSString (например @”I am a string”) равно -1, то есть максимально возможное. Вот пример работы со счетчиком:<br/>
<br/>
<pre><code class="cpp">id anObject = [SomeClass alloc]; //вначале счетчик == 1
[anObject init]; //тут создаются инварианты объекта
[anObject reatin]; //увеличим его значение (теперь он == 2)
[anObject release]; //уменьшим (счетчик опять == 1 и объект по прежнему жизнеспособен)
[anObject release]; //счетчик обнуляется, уменьшаются на 1 счетчики инвариантов и выделенная под объект память возвращается ОС
</code></pre><br/>
Реализация init очень важна. Это конструктор класса. Конструкторы отличаются тем, что возвращаеют id и их названия всегда начинается со слова init, а конструктор по умолчанию – это и есть просто init. Схема любого конструктора примерно следующая:<br/>
<br/>
<pre><code class="cpp">- (id)init
{
self = [super init]; //вызываем конструктор базового класса для
//инициализации его инвариантов
if (self) //если в конструкторе базового класса все прошло удачно
//и он вернул корректный объект, а не освободив память вернул nil
{
//то тут можно смело инициализировать свои инварианты
}
return self; //и возвращать самого себя
}
</code></pre><br/>
Вот типичный специализированный (не по умолчанию) конструктор для класса с двумя членами типа некоторого класса и одним целочисленным инвариантом:<br/>
<br/>
<pre><code class="cpp">- (id)initWithInt: (int)number
{
if (self = [super init])
{
_myMember1 = [[SomeClass alloc] init]; //все как положено: выделили память, затем ее инициализировали
_myMember2 = [[SomeClass alloc] init];
_myIntMember = number; //здесь конструктор ни к чему
//инициализируем переданным параметром
}
return self;
}
</code></pre><br/>
Реализация release и retain для NSObject идеологически примерно следующая, и ее не нужно переопределять в производных классах, в силу отсутствия доступа к инварианту счетчика ссылок:<br/>
<br/>
<pre><code class="cpp">- (void)retain
{
[_internalLock lock]; //блокировка для синхронизации
_referenceCounter++; // пусть _referenceCounter – скрытый инвариант счетчика
[_internalLock unlock];
}
- (void)release
{
[_internalLock lock];
_referenceCounter--; //уменьшим счетчик
if (!_referenceCounter) //если он равен нулю
{
[_internalLock unlock];
[self dealloc]; //скажем себе, что пора умирать (блокировка освободится тут)
}
[_internalLock unlock];
}
</code></pre><br/>
То есть самому объекту посылается сообщение dealloc, в реализации метода которого он может, по необходимости, уменьшить счетчики своих инвариантов и передать аналогичное сообщение объекту базового класса, чтобы он сделал то же самое. Очевидно, реализация метода dealloc для NSObject освободит память, выделенную объекту. Обычно dealloc для какого-нибудь класса выглядит так:<br/>
<br/>
<pre><code class="cpp">- (void)dealloc
{
[_myMember1 release]; //уменьшим счетчик своего инварианта 
[_myMember2 release]; //уменьшим счетчик другого своего инварианта
//[_myIntMember release]; это полный бред, т.к. встроенные типы сообщений не принимают вообще и счетчиков не ведут
[super dealloc]; //cкажем объекту базового класса, что пора освобождать память
}
</code></pre><br/>
<br/>
<h3>Методы доступа</h3><br/>
Правильная работа с подсчетом ссылок очень важна при возврате адреса объекта из метода или инициализации инварианта формальным параметром. Обычно такими вещами занимаются так называемые методы доступа, возвращающие и устанавливающие инварианты объектов. Принято именовать метод, возвращающий значение инварианта, так же как и инвариант, а имя метода, устанавливающего его значение, начинать со слова set:<br/>
<br/>
<pre><code class="cpp">- (void)setRe: (double)re
{
_re = re;
}
</code></pre><br/>
Так как инвариант _re относится ко встроенному типу, никаких сложностей с изменением его значения не возникает. Но если инвариант – объект некоторого класса – то простым присваиванием не обойтись, ведь надо учитывать счетчики ссылок. Для решения этой проблемы применяются следующие три метода:<br/>
<br/>
<pre><code class="cpp">//например, нужно изменить текст у ярлыка
[label setText: @”Hello world”]; //устанавливаем инвариант text
//объекта label равным текстовой константе типа NSString *

//примерная реализация setText в классе UILabel (вариант №1)
- (void)setText: (NSString *)text
{
[text retain]; //увеличиваем счетчик ссылок на формальный параметр
[_text release]; //уменьшаем счетчик ссылок текущего значения своего инварианта _text
_text = text; //инициализируем инвариант новым значением
}

//примерная реализация setText в классе UILabel (вариант №2)
- (void)setText: (NSString *)text
{
if (_text != text) //cравниваем указатели на объекты
{
[_text release]; //уменьшаем счетчик ссылок текущего значения
//своего инварианта _text
_text = [text retain]; //увеличиваем счетчик ссылок
//на формальный параметр и инициализируем свой инвариант
}
}

//примерная реализация setText в классе UILabel (вариант №3 – нежелательный)
- (void)setText: (NSString *)text
{
if (_text != text)
{
[_text autorelease]; //скинем текущеe значения своего
//инварианта _text в самовыгружаемый пул
_text = [text retain]; //увеличиваем счетчик ссылок
//на формальный параметр и инициализируем свой инвариант
}
}
</code></pre><br/>
Вариант №3 не очень удачный потому, что засоряет текущий самовыгружаемый пул, а обычно это не очень желательно (см. следующий раздел).<br/>
Метод доступа для чтения значения инварианта всегда очень прост:<br/>
<br/>
<pre><code class="cpp">- (NSString *)text
{
return _text;
}
</code></pre><br/>
<br/>
<h3>Самовыгружаемый пул в нитях программы</h3><br/>
Теперь попробуем вернуть из метода созданный внутри него объект:<br/>
<br/>
<pre><code class="cpp">-(NSString *)sayHelloToName: (NSString *)name withSurname: (NSString *)surname 
{
NSString *retString = [[NSString alloc] initWithFormat: @”%@ %@!”, name, surname]; //инициализируем созданный объект посредством строки формата
return retString;
}
</code></pre><br/>
Строка формата соответствует стандарту языка С. Но если в ней необходимо указать тип id, то используется спецификатор формата %@. Каким образом метод, разбирающий формат, понимает какие символы подставить вместь id? Он просто подставит то, что вернет метод описания description данного объекта. Этот метод изначально объявлен для класса NSObject. NSString переопределил его на вывод своего строкового содержания. Переопределив его, любой объект может представлять свое строковое содержание. Например, так это может сделать класс комплексного числа с двумя инвариантами типа double:<br/>
<br/>
<pre><code class="cpp">- (NSString *)description
{
return [NSString stringWithFormat: @”re: %lf im: %lf”, _re, _im]; //возвращает строку @“re: 1.0 im: 2.5” для _re == 1.0 и _im == 2.5
}
</code></pre><br/>
После выполнения метода sayHelloToName:withSurname: определенно произойдет утечка памяти, так как вызывающий код скорей всего не догадывается, что возвращенному объекту нужно после обработки послать сообщение release. Даже если он догадается это сделать, возможно, что возвращался указатель на инвариант объекта, а значит его уничтожение чревато серьезными последствиями. Хотелось бы иметь механизм самоосвобождения объектов когда либо в будующем, чтобы пользовательский код вообще не думал об их освобождении. Решается эта проблема с помощью объекта класса NSAutoreleasePool – самовыгружаемого пула объектов.<br/>
<br/>
После создания объекта такого класса всем объектам, созданным после него, можно послать сообщения autorelease. При этом данный объект помещается в текущий (последний созданный) самовыгружаемый пул. Когда некий пул получит сообщение release, то он отошлет такое же сообщение и всем своим объектам, уменьшая их счетчик ссылок (по сути, уничтожая). Таким образом. Объект, помещенный в самовыгружаемый пул, продолжает жить и занимать память во все время жизни пула. Это удобно для небольших временных объектов, но может с течением времени занять значительную часть памяти. Потому рекомендуется циклы, способные порождать большое количество временных объектов, которые отправляются в самовыгружаемый пул, обрамлять локальными (вложенными) пулами.<br/>
<br/>
Любая нить в программе, использующей Cocoa, должна создавать объект класса NSAutoreleasePool в самом начале (прежде создания других объектов), и в самом конце его уничтожать (после уничтожения всех других объектов). Функция main(), являющаяся главной нитью любой программы на Objective-C, при использовании фреймворка Cocoa должна всегда выглядеть вот так:<br/>
<br/>
<pre><code class="cpp">int main(int argc, char *argv[]) // или же просто main()
{ 
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; //создаем пул, он автоматически становится текущим
int retVal;
//теперь можно программировать спокойно
[pool drain]; //освобождаем пул и все объекты, помещенные в него вызовами autorelease
return retVal;
}
</code></pre><br/>
А корректный метод sayHelloToName:withSurname: теперь будет выглядеть вот так:<br/>
<br/>
<pre><code class="cpp">-(NSString *)sayHelloToName: (NSString *)name withSurname: (NSString *)surname 
{
NSString *retString = [[NSString alloc] initWithFormat: @”%@ %@!”, name, surname]; //инициализируем созданный объект посредством строки формата
[retString autorelease]; //помещаем в пул, теперь retString освободится вместе с пулом
return retString;
}
</code></pre><br/>
К слову, метод drain самовыгружаемого пула аналогичен release с той лишь разницей, что, кроме освобождения себя самомго и всех содержащихся объектов, еще дает подсказку сборщику мусора вступить в игру. Однако, это актуально только для Mac OS 10.4 и выше, так как на iOS сборки мусора нет.<br/>
<br/>
<h3>Определение класса</h3><br/>
Теперь рассмотрим файл Complex.m с определением методов класса Complex:<br/>
<br/>
<pre><code class="cpp">#import “Complex.h”

@implementation Complex
- (id)init
{
return [self initWithRe: 0.0 andIm: 0.0];
}
- (id)initWithRe: (double)re andIm: (double)im
{
if (self = [super init])
{
_re = re;
_im = im;
_format = @”re: %.1lf im: %.1lf”; //формат вывода по умолчанию
}
}
+ (Complex *)complexWithRe: (double)re andIm: (double)im
{
return [[[Complex alloc] initWithRe: re andIm: im] autorelease];
}
- (Complex *)add: (Complex *)other
{
return [[Complex alloc] initWithRe: _re + other->_re andIm: _im + other->_im];
}
- (Complex *)sub: (Complex *)other
{
return [[Complex alloc] initWithRe: _re – other->_re andIm: _im – other->_im];
}
- (NSString *)format
{
return _format;
}
- (void)setFormat: (NSString *)format
{//стандартный порядок действий для инварианта-объекта
[format retain];
[_format release];
_format = format;
}
- (double)re
{
return _re;
}
- (void)setRe: (double)re
{
_re = re;
}
- (double)im
{
return _im;
}
- (void)setIm: (double)im
{
_im = im;
}
- (NSString *)description
{//используем установленный формат вывода
return [NSString stringWithFormat: _format, _re, _im]; 
}
- (void)dealloc
{
[_format release]; //для этого и переопределялся dealloc
[super dealloc];
}
@end
</code></pre><br/>
Конструктор по умолчанию вызывает специализированный конструктор с определенными начальными параметрами. Метод complexWithRe:andIm: возвращает инициализированный объект класса Complex, размещенный в текущем самовыгружаемом пуле. То же самое делает и метод description, возвращая объект класса NSString. Вот пример программы, где используется класс Complex:<br/>
<br/>
<pre><code class="cpp">#import “Complex.h”
#import &lt;stdio.h>  //для printf()

int main()
{ 
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
Complex *num1 = [[Complex alloc] init]; //0.0+0.0*i
Complex *num2 = [[Complex alloc] initWithRe: 1.5 andIm: -2];
//1.5-2.0*i
Complex *num3 = [Complex complexWithRe: 5 andIm: 7];
//5.0+7.0*i
printf(“%s\n”, [[num2 description] cStringUsingEncoding: NSASCIIStringEncoding]); //вывод> re: 1.5 im: -2.0
printf(“%s\n”, [[[num2 add: num3] description] cStringUsingEncoding: NSASCIIStringEncoding]); //вывод> re: 6.5 im: 5.0
[num1 setRe: [num2 re]]; //задаем _re для num1 как у num2
[num1 setIm: [num3 im]]; //задаем _im для num1 как у num3
[num1 setFormat: @”%.2lf+%.2lf*i”]; //меняем формат вывода для num1
printf(“%s\n”, [[num1 description] cStringUsingEncoding: NSASCIIStringEncoding]); //вывод> 1.50+7.00*i
[num1 release];
[num2 release];
//[num3 release]; не нужно, т.к. он уже в самовыгружаемом пуле
[pool drain];
return 0;
}
</code></pre><br/>
<br/>
<h3>Категории и расширения</h3><br/>
Если к уже написанному (а, возможно, и откомпилированному) классу нужно добавить\переопределить некоторые методы без наследования – категории позволяют это сделать без особых усилий:<br/>
<br/>
<pre><code class="cpp">//файл “CategorizedComplex.h”

#import “Complex.h”
@interfce Complex (CategorizedComplex)
- (Complex *)mul: (Complex *)other;
- (Complex *)div: (Complex *)other;
@end

//файл “CategorizedComplex.m”
#import “CategorizedComplex.h”

@implementation Complex (CategorizedComplex)
- (Complex *)mul: (Complex *)other
{
return [Complex complexWithRe: _re * other->_re - _im * other->_im andIm: _re * other->_im + _im * other->_re];
}
- (Complex *)div: (Complex *)other
{
double retRe, retIm, denominator;
denominator = other->_re * other->_re + other->_im * other->_im;
if (!denominator)
return nil;
retRe = (_re * other->_re + _im * other->_im) / denominator;
retIm = (_im * other->_re - _re * other->_im) / denominator;
return [Complex complexWithRe: retRe andIm: retIm];
}
@end
</code></pre><br/>
А пользоваться этим можно вот так:<br/>
<br/>
<pre><code class="cpp">CategorizеdComplex *num1 = [[CategorizedComplex alloc] initWithRe: 1 andIm: 999];
Complex *num2 = [Complex complexWithRe: 0 andIm: 0];
CategorizedComplex *num3 = [num1 div: num2]; //num3 == nil
</code></pre><br/>
Расширения несут добрую службу как безымянные категории:<br/>
<br/>
<pre><code class="cpp">//файл “CategorizedComplex.m”
#import “CategorizedComplex.h”
@interface Complex ()
- (void)zeroComplex; //тайный метод для обнуления числа
@end

@implementation Complex
- (void)zeroComplex //им могут пользоваться только методы самого класса
{
_re = 0;
_im = 0; 
}
@end
</code></pre><br/>
<br/>
<h3>Протоколы</h3><br/>
Протокол Objective-C – это формализованное объявление группы методов, которые, по желанию, может реализовать любой класс (аналог класса в С++, где все методы объявлены со спецификатором virtual … = 0). В версии языка 2.0 методы протокола могут быть требуемыми (спецификатор  @required, он считается умалчиваемым) и выборочными (спецификатор  @optional). Если какой либо класс реализовал требуемые методы протокола, то он называется классом, поддерживающим данный протокол. Протокол, и класс, его поддерживающий, объявляются вот так:<br/>
<br/>
<pre><code class="cpp">@protocol MyPrinterProtocol
@required
- (void)print;
- (BOOL)switchedOn;
@optional
- (void)loadPapaer: (int)numberOfPages;
@end

@interface MyPrinter : NSObject &lt;MyPrinterProtocol>
//теперь MyPrinter реализует методы MyPrinterProtocol
{
BOOL _state;
int _numberOfPages;
}
- (id)initWithState: (BOOL)state andPagesCount: (int)pages;
- (BOOL)state;
@end
</code></pre><br/>
Oбъекту класса MyPrinter можно гарантированно посылать сообщения print и switchedOn, и, после проверки на respondsToSelector:, можно посылать сообщение loadPaper:, та как в его реализации должны присутствовать определения одноименных методов. Объявление объекта класса, поддерживающего какой-либо протокол осуществляется так:<br/>
<br/>
<pre><code class="cpp">MyPrinter *printer;
id anotherPrinter = [[MyPrinter alloc] init];
[anotherPrinter print]; //безымянный объект отвечает на сообщение без предупреждений компилятора
</code></pre><br/>
Кроме того, один класс может удовлетворять нескольким протоколам. Для этого их можно перечислить через запятую в угловых скобках в объявлении класса.<br/>
<br/>
<pre><code class="cpp">@interface MyPrinter : NSObject &lt;MyPrinterProtocol, OtherProtocol>
</code></pre><br/>
А чтобы объявить объект неизвестного класса (id), соответствующий некоторому протоколу, пишут так:<br/>
<br/>
<pre><code class="cpp">id &lt;MyPrinterProtocol&amp;gt somePrinter;
</code></pre><br/>
<h3>Исключения</h3><br/>
Есть два основных подхода к обработке ошибок: глобальная статусная переменная, значение которой информирует об успешности выполнения предыдущей операции, и генерация исключений. Суть обоих в том, что код, в котором произошла ошибка, надеется, что решить ее сможет вызвавший его код, поэтому возвращает управление ему, сообщая о произошедшей ситуации как можно более подробно. Objective-C поддерживает оба эти подхода.<br/>
<br/>
Исключение – это объект некоторого класса. Он (даже своим типом) несет в себе некоторую информацию о произошедшей ситуации. Для удобства в Cocoa имеется класс NSException, который можно инициализировать двумя объектами NSString и одним объектом произвольного класса (тип id):<br/>
<br/>
<pre><code class="cpp">- (id)initWitnName: (NSString *)name reason: (NSString *)reason userInfo: (id)userInfo;
</code></pre><br/>
Сгенерировать исключение и, тем самым, запустить механизм раскрутки стека вызовов, можно с помощью оператора  @throw. Чтобы перхватить сгенерированное исключение, участок кода, где возможна его генерация, необходимо заключить в специальный блок с заглавием  <a href="https://habrahabr.ru/users/try/" class="user_link">try</a> (такие блоки могут быть вложенными). А затем, после этого блока, поставить блок с заглавием  <a href="https://habrahabr.ru/users/catch/" class="user_link">catch</a>(), где в круглых скобках указать тип предполагаемого исключения. Блоков  <a href="https://habrahabr.ru/users/catch/" class="user_link">catch</a>() после блока  <a href="https://habrahabr.ru/users/try/" class="user_link">try</a> может быть несколько. После генерации исключения управление, раскручивая стек, выходит из блока  <a href="https://habrahabr.ru/users/try/" class="user_link">try</a> и, проверяя по очереди все блоки  <a href="https://habrahabr.ru/users/catch/" class="user_link">catch</a>(), попадает именно в тот блок  <a href="https://habrahabr.ru/users/catch/" class="user_link">catch</a>(), в фигурных скобках которого стоит такой тип, к которому тип исключения приводится неявно (точное совпадение, указатель на базовый класс или id). Если исключение по типу не совпало ни с одним блоком  <a href="https://habrahabr.ru/users/catch/" class="user_link">catch</a>(), управление продолжает раскрутку стека. Если после блока с заглавием  <a href="https://habrahabr.ru/users/try/" class="user_link">try</a> стоит блок с заглавием  <a href="https://habrahabr.ru/users/finally/" class="user_link">finally</a>, то управление передастся ему независимо от того, произошло ли в блоке  <a href="https://habrahabr.ru/users/try/" class="user_link">try</a> исключение (и обработан какой-нибудь блок  <a href="https://habrahabr.ru/users/catch/" class="user_link">catch</a>()), или выполнилась его последняя инструкция. Ниже приведен пример работы с объектом класса Cup в методе fill которого происходит исключение:<br/>
<br/>
<pre><code class="cpp">Cup *cup = [[Cup alloc] init];
@try 
{
[cup fill]; //в fill генерируется исключение типа NSException
}
@catch (NSException *exception)
{//логируем произошедшее исключение с помощью NSLog
NSLog(@"main: Caught %@: %@", [exception name], [exception reason]);
}
@finally //сюда после @try мы попадем неизбежно
{
[cup release]; 
}
</code></pre><br/>
В блоке  <a href="https://habrahabr.ru/users/finally/" class="user_link">finally</a> удобно освобождать ресурсы, выделенные в блоке  <a href="https://habrahabr.ru/users/try/" class="user_link">try</a>, но не освобожденные по причине сгенерированного исключения.<br/>
<br/>
<h3>Свойства</h3><br/>
Для версии Objective-C 2.0 нашa реализация класса Complex явно избыточна: в ней слишком много методов доступа и их определение – сплошная рутина. Перепишем его с использованием свойств:<br/>
<br/>
<pre><code class="cpp">//файл “Complex.h”
#import &lt;Foundation/Foundation.h>  //для NSObject и строк NSString

@interface Complex : NSObject
{
double _re; //инвариант для действительной части
double _im; //инвариант для мнимой части
NSString *_format; //строка формата для метода description
}
- (id)initWithRe: (double)re andIm: (double)im; 
+ (Complex *)complexWithRe: (double)re andIm: (double)im; 
- (Complex *)add: (Complex *)other; //метод для сложения
- (Complex *)sub: (Complex *)other; //метод для вычетания
@property (nonatomic, retain) NSString *format; //объявим методы доступа
@property (nonatomic, assign) double re; //посредством объявления свойств
@property (nonatomic, assign) double im;
@end

//файл “Complex.m”
#import “Complex.h”

@implementation Complex
@synthesize format = _format; //сгенерируем методы доступа
@synthesize re = _re; //и заодно переменуим их
@synthesize im = _im; //чтобы в имени не было подчеркивания 
- (id)init
{
return [self initWithRe: 0.0 andIm: 0.0];
}
- (id)initWithRe: (double)re andIm: (double)im
{
if (self = [super init])
{
_re = re;
_im = im;
_format = @”re: %.1lf im: %.1lf”; //формат вывода по умолчанию
}
}
+ (Complex *)complexWithRe: (double)re andIm: (double)im
{
return [[[Complex alloc] initWithRe: re andIm: im] autorelease];
}
- (Complex *)add: (Complex *)other
{
return [[Complex alloc] initWithRe: _re + other.re andIm: _im + other.im]; //используем свойства re и im
}
- (Complex *)sub: (Complex *)other
{
return [[Complex alloc] initWithRe: _re – other.re andIm: _im – other.im]; //используем свойства re и im
}
@end
</code></pre><br/>
Свойство – это некоторое имя, доступное через указатель на объект посредством оператора точка “.”. Свойства используются вместо методов доступа чтобы получить или установить инвариант объекта. При объявлении свойства указывается рад параметров, описывающих особенности генерируемых свойством методов доступа.<br/>
<ul>
<li>getter=getterName, setter=setterName Указывает, что метод доступа для чтения будет называться getterName, а для изменения — setterName</li>
<li>readonly Не генерировать метод доступа для изменения</li>
<li>readwrite Генерировать оба метода доступа</li>
<li>assign Метод доступа на изменение реализовывать посредством простого присваивания</li>
<li>retain Принимаемому значению послать сообщение retain, предыдущему значению инварианта послать release и присвоить ему принимаемое значение</li>
<li>copy Использовать обычный оператор присваивания, но присвоить копию принимаемого значения (перед присваиванием емупосылается сообщение copy)</li>
<li>nonatomic Не использовать внутренние блокировки для синхронизации нескольких нитей в сгенерированных методах доступа (по умолчанию cинхронизация используется)</li>
</ul>Теперь в определении класса Complex нам не нужно вручную писать методы доступа. Они сгенерируются компилятором и будут идентичны тем, что были раньше.<br/>
<br/>
<b>Удачи!</b></div></div> <!----> <!----></div> <div class="tm-article-body__tags"><div class="tm-article-body__tags-links"><span class="tm-article-body__tags-title">Теги:</span> <span class="tm-article-body__tags-item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bobjective-c%5D" class="tm-article-body__tags-item-link">objective-c</a></span><span class="tm-article-body__tags-item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bmac%20os%20x%5D" class="tm-article-body__tags-item-link">mac os x</a></span></div> <div class="tm-article-body__tags-links"><span class="tm-article-body__tags-title">Хабы:</span> <span class="tm-article-body__tags-item"><a href="/ru/hub/ios_dev/" class="tm-article-body__tags-item-link">
                  Разработка под iOS
                </a></span></div></div></article> <div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 163: ↑155 и ↓8</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg> <span title="Всего голосов 163: ↑155 и ↓8" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+147</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <!----> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    1073
  </span></button> <div title="Читать комментарии" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/ru/post/107126/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value">
      61
    </span></a> <!----></div> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div></div> <!----></div> <!----> <div class="tm-page-article__additional-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body"><div class="tm-article-author tm-page-article__author"><!----> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-two-column"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/shoumikhin/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><svg class="tm-svg-img tm-image-placeholder tm-image-placeholder_green"><!----> <use xlink:href="/img/megazord-v24.cee85629.svg#placeholder-user"></use></svg></div></a> <div class="tm-user-card__meta"><div title=" 271 голос " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    20.7
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">0</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info"><div class="tm-user-card__title"><span class="tm-user-card__name">Anthony Shoumikhin</span> <a href="/ru/users/shoumikhin/" class="tm-user-card__nickname">
          @shoumikhin
        </a> <!----></div> <p class="tm-user-card__short-info">Software Engineer</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-two-column"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div></div> <!----></section> <div class="tm-page-article__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/107126/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 61 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <section class="tm-block tm-block_spacing-around"><header class="tm-block__header"><h2 class="tm-block__title">Похожие публикации</h2> <!----></header> <div class="tm-block__body"><ul class="tm-article-list-block__list"><li class="tm-article-list-block__item"><article class="tm-article-snippet-block-block tm-article-snippet-block-block_preview"><div class="tm-article-snippet-block__user-meta"><div class="tm-article-snippet-block__date"><time datetime="2020-12-22T19:57:04.000Z" title="2020-12-22, 22:57">22  декабря  2020 в 22:57</time></div></div> <h2 class="tm-article-title tm-article-title_block"><a href="/ru/post/534516/" class="tm-article-title__link"><span>Создание загрузочной флешки c HirensBootCD в mac os</span></a></h2> <div class="tm-data-icons"><!----> <div class="tm-votes-meter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_small"><title>Всего голосов 7: ↑6 и ↓1</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg> <span title="Всего голосов 7: ↑6 и ↓1" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_small">+5</span></div> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">3.1K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    18
  </span></button> <div title="Читать комментарии" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/ru/post/534516/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value">
      3
    </span></a> <!----></div> <!----> <DIV class="v-portal" style="display:none;"></DIV></div></article></li><li class="tm-article-list-block__item"><article class="tm-article-snippet-block-block tm-article-snippet-block-block_preview"><div class="tm-article-snippet-block__user-meta"><div class="tm-article-snippet-block__date"><time datetime="2020-07-29T18:10:41.000Z" title="2020-07-29, 21:10">29  июля  2020 в 21:10</time></div></div> <h2 class="tm-article-title tm-article-title_block"><a href="/ru/news/t/513050/" class="tm-article-title__link"><span>Разработчик создал из Mac OS 8 приложение для современных ПК на macOS, Windows и Linux</span></a></h2> <div class="tm-data-icons"><!----> <div class="tm-votes-meter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_small"><title>Всего голосов 32: ↑28 и ↓4</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg> <span title="Всего голосов 32: ↑28 и ↓4" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_small">+24</span></div> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">14K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    20
  </span></button> <div title="Читать комментарии" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/ru/news/t/513050/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value">
      12
    </span></a> <!----></div> <!----> <DIV class="v-portal" style="display:none;"></DIV></div></article></li><li class="tm-article-list-block__item"><article class="tm-article-snippet-block-block tm-article-snippet-block-block_preview"><div class="tm-article-snippet-block__user-meta"><div class="tm-article-snippet-block__date"><time datetime="2020-06-23T13:12:15.000Z" title="2020-06-23, 16:12">23  июня  2020 в 16:12</time></div></div> <h2 class="tm-article-title tm-article-title_block"><a href="/ru/company/otus/blog/507908/" class="tm-article-title__link"><span>Управление несколькими JDK в Mac OS, Linux и Windows WSL2</span></a></h2> <div class="tm-data-icons"><!----> <div class="tm-votes-meter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_small"><title>Всего голосов 16: ↑14 и ↓2</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg> <span title="Всего голосов 16: ↑14 и ↓2" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_small">+12</span></div> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">5K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    41
  </span></button> <div title="Читать комментарии" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/ru/company/otus/blog/507908/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value">
      6
    </span></a> <!----></div> <!----> <DIV class="v-portal" style="display:none;"></DIV></div></article></li> <!----></ul></div> <!----></section> <!----> <!----> <section class="tm-block tm-block_spacing-around"><header class="tm-block__header"><h2 class="tm-block__title">Лучшие публикации за сутки</h2> <!----></header> <div class="tm-block__body"><ul class="tm-article-list-block__list"><li class="tm-article-list-block__item"><article class="tm-article-snippet-block-block tm-article-snippet-block-block_preview"><div class="tm-article-snippet-block__user-meta"><div class="tm-article-snippet-block__date"><time datetime="2021-09-28T14:25:12.000Z" title="2021-09-28, 17:25">вчера в 17:25</time></div></div> <h2 class="tm-article-title tm-article-title_block"><a href="/ru/post/580516/" class="tm-article-title__link"><span>Лучший язык программирования</span></a></h2> <div class="tm-data-icons"><!----> <div class="tm-votes-meter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_small"><title>Всего голосов 161: ↑156 и ↓5</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg> <span title="Всего голосов 161: ↑156 и ↓5" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_small">+151</span></div> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">35K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    165
  </span></button> <div title="Читать комментарии" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/ru/post/580516/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value">
      86
    </span></a> <!----></div> <!----> <DIV class="v-portal" style="display:none;"></DIV></div></article></li><li class="tm-article-list-block__item"><article class="tm-article-snippet-block-block tm-article-snippet-block-block_preview"><div class="tm-article-snippet-block__user-meta"><div class="tm-article-snippet-block__date"><time datetime="2021-09-29T06:19:53.000Z" title="2021-09-29, 09:19">сегодня в 09:19</time></div></div> <h2 class="tm-article-title tm-article-title_block"><a href="/ru/post/580582/" class="tm-article-title__link"><span>Конфиденциальность пользователей Telegram снова нарушена. Представители мессенджера требуют не раскрывать подробностей</span></a></h2> <div class="tm-data-icons"><!----> <div class="tm-votes-meter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_small"><title>Всего голосов 154: ↑151 и ↓3</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg> <span title="Всего голосов 154: ↑151 и ↓3" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_small">+148</span></div> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">22K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    17
  </span></button> <div title="Читать комментарии" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/ru/post/580582/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value">
      59
    </span></a> <!----></div> <!----> <DIV class="v-portal" style="display:none;"></DIV></div></article></li><li class="tm-article-list-block__item"><article class="tm-article-snippet-block-block tm-article-snippet-block-block_preview"><div class="tm-article-snippet-block__user-meta"><div class="tm-article-snippet-block__date"><time datetime="2021-09-28T17:18:57.000Z" title="2021-09-28, 20:18">вчера в 20:18</time></div></div> <h2 class="tm-article-title tm-article-title_block"><a href="/ru/post/580034/" class="tm-article-title__link"><span>Пыль, пылевые клещи и их аллергены. Профилактика и защита</span></a></h2> <div class="tm-data-icons"><!----> <div class="tm-votes-meter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_small"><title>Всего голосов 58: ↑54 и ↓4</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg> <span title="Всего голосов 58: ↑54 и ↓4" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_small">+50</span></div> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">9.9K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    53
  </span></button> <div title="Читать комментарии" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/ru/post/580034/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value">
      39
    </span></a> <!----></div> <!----> <DIV class="v-portal" style="display:none;"></DIV></div></article></li><li class="tm-article-list-block__item"><article class="tm-article-snippet-block-block tm-article-snippet-block-block_preview"><div class="tm-article-snippet-block__user-meta"><div class="tm-article-snippet-block__date"><time datetime="2021-09-29T00:18:17.000Z" title="2021-09-29, 03:18">сегодня в 03:18</time></div></div> <h2 class="tm-article-title tm-article-title_block"><a href="/ru/company/selectel/blog/579530/" class="tm-article-title__link"><span>Лучше поздно, чем никогда: Microsoft решила продолжить историю Skype</span></a></h2> <div class="tm-data-icons"><!----> <div class="tm-votes-meter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_small"><title>Всего голосов 37: ↑35 и ↓2</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg> <span title="Всего голосов 37: ↑35 и ↓2" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_small">+33</span></div> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">15K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    5
  </span></button> <div title="Читать комментарии" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/ru/company/selectel/blog/579530/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value">
      54
    </span></a> <!----></div> <!----> <DIV class="v-portal" style="display:none;"></DIV></div></article></li><li class="tm-article-list-block__item"><article class="tm-article-snippet-block-block tm-article-snippet-block-block_preview"><div class="tm-article-snippet-block__user-meta"><div class="tm-article-snippet-block__date"><time datetime="2021-09-29T09:00:14.000Z" title="2021-09-29, 12:00">сегодня в 12:00</time></div></div> <h2 class="tm-article-title tm-article-title_block"><a href="/ru/company/funcorp/blog/580392/" class="tm-article-title__link"><span>Дообучаем готовую нейросеть для классификации данных</span></a></h2> <div class="tm-data-icons"><!----> <div class="tm-votes-meter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_small"><title>Всего голосов 32: ↑31 и ↓1</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg> <span title="Всего голосов 32: ↑31 и ↓1" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_small">+30</span></div> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">445</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    27
  </span></button> <div title="Читать комментарии" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/ru/company/funcorp/blog/580392/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value">
      0
    </span></a> <!----></div> <!----> <DIV class="v-portal" style="display:none;"></DIV></div></article></li> <!----></ul></div> <!----></section> <!----> <!----></div></div></div> <div class="tm-page__sidebar"><div hl="ru" id="107126" class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/107126/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/107126/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"107126":{"id":"107126","timePublished":"2010-10-29T13:40:01+00:00","isCorporative":false,"lang":"ru","titleHtml":"Objective-C с нуля","leadData":{"textHtml":"\u003Cimg align=\"left\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Ff1073050\u002F7aff6749\u002F77739192\u002Ffd020592.png\"\u002F\u003EУ любого желающего писать программы для продукции фирмы Apple в жизни наступает такой момент, когда ему приходиться изучить новый язык программирования — Objective-C. Когда-то этот счастливый момент постиг и меня. А чтобы лучше запомнить основные особенности этого языка, решил законспектировать свои мысли во время осмысления его документации, которыми и делюсь с вами. \u003Cbr\u002F\u003E\r\n","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"editorVersion":"1.0","postType":"article","postLabels":[],"author":{"scoreStats":{"score":20.7,"votesCount":271},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"59212","alias":"shoumikhin","fullname":"Anthony Shoumikhin","avatarUrl":null,"speciality":"Software Engineer"},"statistics":{"commentsCount":61,"favoritesCount":1073,"readingCount":407548,"score":147,"votesCount":163},"hubs":[{"relatedData":null,"id":"548","alias":"ios_dev","type":"collective","title":"Разработка под iOS","titleHtml":"Разработка под iOS","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cimg align=\"left\" src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Ff1073050\u002F7aff6749\u002F77739192\u002Ffd020592.png\"\u002F\u003EУ любого желающего писать программы для продукции фирмы Apple в жизни наступает такой момент, когда ему приходиться изучить новый язык программирования — Objective-C. Когда-то этот счастливый момент постиг и меня. А чтобы лучше запомнить основные особенности этого языка, решил законспектировать свои мысли во время осмысления его документации, которыми и делюсь с вами. \u003Cbr\u002F\u003E\r\n\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EБанальная теория возникновения ООП\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nПроблема повторного использования написанного кода и его переносимость постоянно заставляет программистов искать все новые пути его упорядочивания, структуризации и абстрагирования. Для решения этих проблем создаются новые парадигмы программирования, шаблоны проектирования, новые языки, компиляторы и стандартные библиотеки к ним, программные платформы и фреймворки. Так образовались парадигма подпрограмм (процедур), реализуемая при помощи процессорных команд CALL\\RET и стека (по сути, перенос потока выполнения по адресу произвольной, а не следующей за текущей команды, с последующим возвратом). Затем, парадигма модулей (каждый файл – отдельная единица трансляции), породившая двухэтапную трансляцию: компиляция модулей, а затем их компоновка (статическая или динамическая) в исполняемый модуль.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ следствии увеличения объема кода в проектах и сложностей его поддержки, с 1960х начинает образовываться новая, объектно-ориентированная парадигма программирования, разбившая программы на еще более мелкие составляющие – типы данных. Ее суть заключается во взаимодействии сущностей (объектов) посредством посылки друг другу сообщений. Каждый объект является переменной определенного программистом типа данных (так называемого класса). Определение такого специального пользовательского типа данных (класса) заключается в двух вещах: определении набора данных (инвариантов, членов) и набора подпрограмм (методов), которые будут их обслуживать.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002F29b3f167\u002F006356ff\u002F88414a4a\u002Fcb4d17e5.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nКласс обычно оформляется как определенный программистом тип, основанный на встроенных (языковых) типах данных и\\или других классах. Для языка С, не поддерживающего объектно-ориентированную парадигму, это может быть структура (struct). А набор подпрограмм реализуется как обычные функции, обязательно принимающие как минимум один параметр — указатель на набор данных, подлежащих обработке.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОсновным преимуществом объектно-ориентированного подхода стала возможность создавать новые классы на основе уже написанных (добавлять инварианты и методы, переопределять методы, использовать определенные в базовом классе методы как свои), названное наследованием.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002F53e1c6cb\u002F4d30e3d1\u002Fecfababe\u002F9dcb8d2a.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nНабор методов представляет собой интерфейс для взаимодействия с инвариантами. Невозможность непосредственной модификации данных класса (без задействования его интерфейса) отражает принцип инкапсуляции. На рисунке показан класс и его объекты. Имеется инвариант x типа float и к нему интерфейс (метод) doubleX, возвращающий значение инварианта.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nБывает, что необходимо послать сообщение объекту, который на него определенно отвечает (т.е. вызвать для объекта класса такой метод, который он реализовал), но, по ситуации, конкретный класс этого объекта неизвестен. Например, каждому элементу списка указателей на объекты класса Auto нужно послать сообщение Move, а известно что в списке находятся указатели на объекты не только класса Auto, но также и указатели на производные (наследованные) классы Ford и Subaru. Это возможно сделать только благодаря принципу полиморфизма, заключающегося в том, что при посылке определенного сообщения объекту из некой иерархии классов, в которой все объекты способны принять такое сообщение, этот объект реагирует на него соответственно своему, а не базовому для данной иерархии классу.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПервым языком с поддержкой объектно-ориентированного подхода стал Simula67. Затем появился Smalltalk. А в 80х начал оформляться С++ — основной язык современного системного программирования. Его расширение и усовершенствование в 90х породило ряд парадигм и шаблонов проектирования, и оказало необратимое влияние на современное видение объектно-ориентированного подхода, в том числе, и на язык Objective-C.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EЧуть-чуть истории\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nObjective-C возник в 80-x как модификация С в сторону Smalltalk. Причем модификация эта состояла в добавлении новых синтаксических конструкций и специальном препроцессоре для них (который, проходя по коду преобразовывал их в обычные вызовы функций С), а также библиотеке времени выполнения (эти вызовы обрабатывающей). Таким образом, изначально Objective-C воспринимался как надстройка над C. В каком-то смысле это так и до сих пор: можно написать программу на чистом С, а после добавить к ней немного конструкций из Objective-C (при необходимости), или же наоборот, свободно пользоваться С в программах на Objective-C. Кроме того, все это касается и программ на С++. В 1988 NeXT (а в последствии Apple) лицензировала Objective-C и написала для него компилятор и стандартную библиотеку (по сути SDK). В 1992 к усовершенствованию языка и компилятора подключились разработчики проекта GNU в рамках проекта OpenStep. С тех пор GCC поддерживает Objective-C. После покупки NeXT, Apple взяля их SDK (компилятор, библиотеки, IDE) за основу для своих дальнейших разработок. IDE для кода назвали Xcode, а для GUI – Interface Builder. Фреймворк Cocoa для GUI разработок (и не только) на сегодня является наиболее значимой средой разработки программ на Objective-C.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EОсобенности Objective-C\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nФайлы модулей на Objective-C имеют расширение “.m” (если использовалась смесь С++ и Objective-С, то расширение “.mm”). Заголовочные файлы – “.h”. Все, создаваемые в Objective-С объекты классов должны размещатся в динамической памяти. Поэтому особое значение приобретает тип id, который является указателем на объект любого класса (по сути void *). Нулевой указатель именуется константой nil. Таким образом, указатель на любой класс можно привести к типу id. Возникает проблема: как узнать к какому классу относится объект, скрывающийся под id? Это делается благодаря инварианту isa, который присутствует в любом объекте класса, унаследовавшего специальный базовый клас NSObject (приставка NS обозначает NeXT Step). Инвариант isa относится к зарезервированному типу Class. Объект такого типа позволяет узнавать имена своего и базового класса, набор инвариантов класса, а также прототипы всех методов, которые реализовал этот объект и их адреса (посредством локального списка селекторов). Все зарезервированные слова Objective-C, отличающиеся от зарезервированных слов языка С, начинаются с символа @ (например  @protocol,  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Fselector\u002F\" class=\"user_link\"\u003Eselector\u003C\u002Fa\u003E,  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Finterface\u002F\" class=\"user_link\"\u003Einterface\u003C\u002Fa\u003E). Обычно имена инвариантов классов с ограниченной областью видимости (@private,  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Fprotected\u002F\" class=\"user_link\"\u003Eprotected\u003C\u002Fa\u003E) начинаются с символа подчеркивания. Для строк в Cocoa имеется очень удобный класс NSString. Строковая константа такого класса записывается как @”Hello world”, а не как обычная для С строковая константа “Hello world”. Тип BOOL (по сути unsigned char) может принимать константные значения YES и NO. Все особые для Objective-C зарезервированные слова (которые отличаются от языка С и находятся в заголовочном файле objc\u002Fobjc.h) приведены ниже:\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Finterface\u002F\" class=\"user_link\"\u003Einterface\u003C\u002Fa\u003E Начинает объявление класса или категории (категория – расширение класса дополнительными методами без наследования)\u003C\u002Fli\u003E\r\n\u003Cli\u003E@implementation Начинает определение класса или категории\u003C\u002Fli\u003E\r\n\u003Cli\u003E @protocol Начинает объявление протокола (аналог класса С++, состоящего из чисто виртуальных функций)\u003C\u002Fli\u003E\r\n\u003Cli\u003E \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Fend\u002F\" class=\"user_link\"\u003Eend\u003C\u002Fa\u003E Завершает объявление\\определение любого класса, категории или протокола\u003C\u002Fli\u003E\r\n\u003Cli\u003E@private Ограничивает область видимости инвариантов класса методами класса (аналогично С++)\u003C\u002Fli\u003E\r\n\u003Cli\u003E \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Fprotected\u002F\" class=\"user_link\"\u003Eprotected\u003C\u002Fa\u003E Стоит по умолчанию. Ограничивает область видимости инвариантов класса методами класса и методами производных классов (аналогично С++)\u003C\u002Fli\u003E\r\n\u003Cli\u003E@public Удаляет ограничения на облать видимости (аналогично С++)\u003C\u002Fli\u003E\r\n\u003Cli\u003E \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Ftry\u002F\" class=\"user_link\"\u003Etry\u003C\u002Fa\u003E Определяет блок с возможной генерацией исключений (аналогично С++)\u003C\u002Fli\u003E\r\n\u003Cli\u003E @throw Генерирует объект-исключение (аналогично С++)\u003C\u002Fli\u003E\r\n\u003Cli\u003E \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Fcatch\u002F\" class=\"user_link\"\u003Ecatch\u003C\u002Fa\u003E () Обрабатывает исключение, сгенерированное в предшествующем блоке  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Ftry\u002F\" class=\"user_link\"\u003Etry\u003C\u002Fa\u003E (аналогично С++)\u003C\u002Fli\u003E\r\n\u003Cli\u003E \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Ffinally\u002F\" class=\"user_link\"\u003Efinally\u003C\u002Fa\u003E Определяет блок после блока  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Ftry\u002F\" class=\"user_link\"\u003Etry\u003C\u002Fa\u003E, в который предается куправление независимо от того, было или нет сгенерировано исключение\u003C\u002Fli\u003E\r\n\u003Cli\u003E@class Сокращенная форма объявления класса (только имя (аналогично С++))\u003C\u002Fli\u003E\r\n\u003Cli\u003E \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Fselector\u002F\" class=\"user_link\"\u003Eselector\u003C\u002Fa\u003E(method_name) Возвращает скомпилированный селектор для имени метода method_name\u003C\u002Fli\u003E\r\n\u003Cli\u003E @protocol(protocol_name) Ворзвращает экземпляр класса-протокола с именем protocol_name\u003C\u002Fli\u003E\r\n\u003Cli\u003E@encode(type_spec) Инициализирует строку символов, которая будет использована для шифрования данных типа type_spec\u003C\u002Fli\u003E\r\n\u003Cli\u003E@synchronized() Определяет блок кода, выполняющегося только одной нитью в любой определенный момент времени\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EОбмен сообщениями\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nЧтобы заставить объект выполнить какой-нибудь метод нужно послать ему сообщение, именуемое так же, как и требуемый метод. Такое сообщение называется селектор метода. Синтаксис посылки таков:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E[receiver method];\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fd18a0af3\u002F844fdcce\u002F1285d539\u002F5e2f0c3b.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nВ сообщении можно передавать параметры для вызываемого метода:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E[receiver method: 20.0 : 30.0];\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПеред каждым параметром необходимо ставить двоеточие. Сколько двоеточий – столько и параметров. Имя метода может продолжаться после каждого такого двоеточия-параметра:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E[receiver methodWithFirstArgument: 10 andSecondArgument: 20];\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nМетоды с неограниченным количством аргументов вызываюся следующим синтаксисом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E[receiver undefinedNumberParameters: one, two, three, four, five, six, seven];\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПосылка сообщения, как и любая функция C, возвращает определенное (может void) значение:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EBOOL booleanValue;\nbooleanValue = [reveiver method];\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПри посылке сообщения nil оно просто пропадает. При посылке сообщения объекту, который принадлежит классу, не реализовавшему заказанный метод, возникает исключение, которое, будучи не перехваченным, приводит всю программу к незапланированному завершению. Для проверки, отвечает ли данный объект на кокое-либо сообщение можно использовать следующий шаблон кода:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eif ([anObject respondsToSelector: @selector(myMethodWith2Argumets::)])\n{\n\u002F\u002Fможно вызывать\n[anObject myMethodWith2Argumetns: @”first” : @”second”];\n}\nelse\n{\n\u002F\u002Fни в коем случае не вызывать\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EКак работает передача сообщений\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nПосылка сообщения транслируется в С-функцию с прототипом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eid objc_msgSend(id receiver, SEL method, ...);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТип SEL, по сути, определен как char const *, но лучше воспринимать его как int, поскольку во время выполнения все селекторы индексируются целыми значениями согласно глобальной таблице селекторов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002F194952d8\u002F4bbdb524\u002F3a81ab57\u002F01842029.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nПользуясь инвариантом isa объекта receiver (при использовании фреймворка Foundation, базового для Cocoa, все классы должны наследовать класс NSObject, поэтому наличие isa неизбежно), эта функция просматривает локальный список селекторов класса с целью определить, отвечает ли объект данного класса на сообщение method. Если такой селектор находится, то управление передается соответствующему методу класса, которому передается id объекта (указатель на его инварианты) и указанные после селектора параметры функции objc_msgSend(). Значение, возвращенное методом, отдается как результат посылки сообщения. Если у объекта-приемника данный селектор отсутствует, функции objc_msgSend() просматривает список селекторов его базового класса.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002F8d94a5cd\u002F18d3a791\u002F33c7f9ac\u002Fa1811278.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nПри такой схеме вызов, например:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E[receiver аddObject: otherObject];\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТранслируется в:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eobjc_msgSend(receiver, 12, otherObject);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТак как в глобальной таблице селекторов 12 соответствует строке “addObject:”. Далее функция objc_msgSend() выполняет поиск по списку селекторов объекта receiver и, найдя его (пусть это объект класса NSArray, который реализовал метод с селектором 12), производит вызов типа:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EaddObject(receiver, otherObject);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EОбъявление метода\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nИнтересно отметить, что прототип метода addObject из предыдущего раздела в объявлении класса выглядел так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E- (void)addObject: (id)otherObject;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТо есть принимал всего один параметр. Но, исходя из принципа объектно-ориентированной парадигмы, что методы – это подпрограммы, обрабатывающие определенные наборы данных, методу необходимо передавать адресс данных, подлежащих обработке. Поэтому такой параметр передается во всякий метод класса неявно. Компилятору об этом дополнительном параметре дает понять минус (\"-\"), стоящий первым в прототипе метода. Такой метод (с минусом впереди) называется методом объекта (или экземпляра), т.к. может быть вызван только для объекта какого-нибудь класса. В теле метода этот указатель на экземпляр данных (или адрес объекта, которому послали сообщение) доступен посредством зарезервированного слова self (аналог this в С++), а указатель на экземпляр базового класса – через зарезервированное слово super. Кроме того, в метод объекта также передается неявный параметр _cmd – селектор этого метода из глобальной таблицы селекторов. С точки зрения программиста С++ все методы объектов в Objective-C как-будто объявлены с ключевым словом virtual, и всегда следуют динамическому полиморфизму.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли в начале прототипа метода поставить знак плюс (“+”), то такой метод будет считаться методом класса, и, естественно, не будет принимать неявный параметр self (это аналогично объявлению static-метода в С++). А без инварианта isa объекта, на который указывает self, указатель super работать, конечно, тоже не будет.\u003Cbr\u002F\u003E\r\nТаким образом, прототип любого метода объявляется так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E-|+ (&lt;тип возвращаемого значения\u003E) основнаяЧастьИмениМетода\n[ : (&lt;тип первого параметра\u003E)имяПервогоФормальногоПараметра\n[ [дополнительнаяЧастьИмениМетода] : (&lt;тип второго параметра\u003E)имяВторогоФормальногоПараметра]\n… ]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nНапример:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E+ (Class)class;\n+ (id)alloc;\n- (id)init;\n- (void)addObject: (id)anObject;\n+ (NSString *)stringWithCString: (const char*)aCString usingUncoding: (enum NSStringEncoding)encoding;\n- (NSString *)initStringWithFormat: (NSString *)format, …;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЕсли метод возвращает некий объект (тип id) или класс (тип Class), можно воспользоваться вложенным синтаксисом вызова:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E[myLabel setText: [[NSString stringWithString: @”Hello”] stringByAppendingString: @” world”]];\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗдесь объекту класса UILabel из фреймворка UIKit устанавливается значение инварианта text равное строке @”Hello world”. Эта строка, в свою очередь, образована конкатенацией строк @”Hello” и @” world”. Первая является результатом посылке сообщения stringWithString классу NSString с параметром-константой @”Hello”. Такой вызов возвращает объект класса NSString, инициализированный строкой-параметром. Затем этому объекту посылается сообщение stringByAppendingString с параметром @” world”. Результат посылки этого сообщения и есть объект класса NSString, содержащий конкатенацию значения объекта-приемника и строкового аргумента. Этот объект и попадает как параметр в сообщение setText: объекта myLabel.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EОбъявление класса\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nОбъявим простой класс комплексного числа в файле Complex.h:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E#import &lt;Foundation\u002FFoundation.h\u003E \u002F\u002Fдля NSObject и строк NSString\n\n@interface Complex : NSObject\n{\ndouble _re; \u002F\u002Fинвариант для действительной части\ndouble _im; \u002F\u002Fинвариант для мнимой части\nNSString *_format; \u002F\u002Fстрока формата для метода description\n}\n- (id)initWithRe: (double)re andIm: (double)im; \u002F\u002Fспециализированный конструктор\n+ (Complex *)complexWithRe: (double)re andIm: (double)im; \u002F\u002Fметод класса для одноэтапного создания объекта\n- (Complex *)add: (Complex *)other; \u002F\u002Fметод для сложения\n- (Complex *)sub: (Complex *)other; \u002F\u002Fметод для вычетания\n- (NSString *)format; \u002F\u002Fметод доступа к _format\n- (void)setFormat: (NSString *)format; \u002F\u002Fметод установки _format\n- (double)re; \u002F\u002Fостальные методы доступа к действительной и мнимой частям\n- (void)setRe: (double)re;\n- (double)im;\n- (void)setIm: (double)im;\n@end\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКак видим, все объявление заключено в ключевые слова  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Finterface\u002F\" class=\"user_link\"\u003Einterface\u003C\u002Fa\u003E и  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Fend\u002F\" class=\"user_link\"\u003Eend\u003C\u002Fa\u003E. Первым делом объявляются инварианты (в фигурных скобках). Вне фигурных скобок объявляются методы. Метод description отсутствует в объявлении класса не случайно. Дело в том, что он, как и метод dealloc и init, присутствует в определении класса. При посылке объекту класса Complex сообщения description будет рассмотрен его локальный список селекторов, куда, после компиляции, попадут селекторы всех методов, реализованных классом этого объекта, даже не объявленные в интерфейсной части. То есть init, description и dealloc будут вызывать абсолютно корректно.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EСоздание объектов\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nВ связи с тем, что все объекты распределяютя в динамической памяти, cоздание объекта приходится проводить в два этапа: 1) выделении памяти (сообщение alloc) и 2) инициализация инвариантов (конструкторы класса).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EMyClass *myObject = [[MyClass alloc] init];  \u002F\u002Fметод класса MyClass alloc выделяет участок памяти нужного размера и возвращает указатель на него, метод объекта init инициализирует инварианты объекта myObject\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПосле создания объекта им можно смело пользоваться:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003ENSMutableArray *array = [[NSMutableArray alloc] init]; \u002F\u002Fсоздаем изменяемый массив\nMyClass *myObject = [[MyClass alloc] init]; \u002F\u002Fнаш объект\n[myObject myMethod]; \u002F\u002Fпосылка некоторого сообщения\n[array addObject: myObject]; \u002F\u002Fпомещаем объект в массив\nMyClass *otherObject = [array getLastObject:]; \u002F\u002Fдостаем его из массива, указываем на него другим указателем\n[otherObject myOtherMethod: YES]; \u002F\u002Fпосылаем ему другое сообщение с аргументом типа BOOL\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nНекоторые классы обладают методом для быстрого (в один этап) создания собственных экземпляров. Такие методы являются методами класса, возвращают указатель на объект своего класса и их имя обычно начинается с названия самого класса. Например метод:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E+ (NSString *)stringWithCString: (char const *)string encoding: (NSStringEncoding)encoding;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВозвращает уже готовую строку, инициализированную соответствующей сторокой с завершающим нулем, без вызовов alloc и init:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003ENSString *myString = [NSString stringWithCString: “Bla-bla-bla” encoding: NSASCIIStringEncoding];\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EВремя жизни объекта\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nКак только указатель на объект выходит за свою область видимости, память, выделенная под него, безвозвратно теряется (если, конечно, это был последний указатель на тот объект) и происходит утечка. Дабы избежать таких нежелательных последствий в Objective-C поддерживается парадигма подсчета ссылок на ресурсы. Таким образом, у каждого объекта есть целочисленный счетчик, который показывает количество ссылающихся на него указателей. По достижению этим счетчиком нуля, память, выделенная для данного объекта, возвращается системе. После вызова метода класса alloc, этот счетчик равен единице. Чтобы увеличить его значение необходимо послать объекту сообщение retain, а чтобы уменьшить – release. Все эти методу реализует NSObject, который любой наш класс непременно наследует. Интересно отметить, что значение счетчика для статических объектов класса NSString (например @”I am a string”) равно -1, то есть максимально возможное. Вот пример работы со счетчиком:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eid anObject = [SomeClass alloc]; \u002F\u002Fвначале счетчик == 1\n[anObject init]; \u002F\u002Fтут создаются инварианты объекта\n[anObject reatin]; \u002F\u002Fувеличим его значение (теперь он == 2)\n[anObject release]; \u002F\u002Fуменьшим (счетчик опять == 1 и объект по прежнему жизнеспособен)\n[anObject release]; \u002F\u002Fсчетчик обнуляется, уменьшаются на 1 счетчики инвариантов и выделенная под объект память возвращается ОС\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nРеализация init очень важна. Это конструктор класса. Конструкторы отличаются тем, что возвращаеют id и их названия всегда начинается со слова init, а конструктор по умолчанию – это и есть просто init. Схема любого конструктора примерно следующая:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E- (id)init\n{\nself = [super init]; \u002F\u002Fвызываем конструктор базового класса для\n\u002F\u002Fинициализации его инвариантов\nif (self) \u002F\u002Fесли в конструкторе базового класса все прошло удачно\n\u002F\u002Fи он вернул корректный объект, а не освободив память вернул nil\n{\n\u002F\u002Fто тут можно смело инициализировать свои инварианты\n}\nreturn self; \u002F\u002Fи возвращать самого себя\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВот типичный специализированный (не по умолчанию) конструктор для класса с двумя членами типа некоторого класса и одним целочисленным инвариантом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E- (id)initWithInt: (int)number\n{\nif (self = [super init])\n{\n_myMember1 = [[SomeClass alloc] init]; \u002F\u002Fвсе как положено: выделили память, затем ее инициализировали\n_myMember2 = [[SomeClass alloc] init];\n_myIntMember = number; \u002F\u002Fздесь конструктор ни к чему\n\u002F\u002Fинициализируем переданным параметром\n}\nreturn self;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nРеализация release и retain для NSObject идеологически примерно следующая, и ее не нужно переопределять в производных классах, в силу отсутствия доступа к инварианту счетчика ссылок:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E- (void)retain\n{\n[_internalLock lock]; \u002F\u002Fблокировка для синхронизации\n_referenceCounter++; \u002F\u002F пусть _referenceCounter – скрытый инвариант счетчика\n[_internalLock unlock];\n}\n- (void)release\n{\n[_internalLock lock];\n_referenceCounter--; \u002F\u002Fуменьшим счетчик\nif (!_referenceCounter) \u002F\u002Fесли он равен нулю\n{\n[_internalLock unlock];\n[self dealloc]; \u002F\u002Fскажем себе, что пора умирать (блокировка освободится тут)\n}\n[_internalLock unlock];\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТо есть самому объекту посылается сообщение dealloc, в реализации метода которого он может, по необходимости, уменьшить счетчики своих инвариантов и передать аналогичное сообщение объекту базового класса, чтобы он сделал то же самое. Очевидно, реализация метода dealloc для NSObject освободит память, выделенную объекту. Обычно dealloc для какого-нибудь класса выглядит так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E- (void)dealloc\n{\n[_myMember1 release]; \u002F\u002Fуменьшим счетчик своего инварианта \n[_myMember2 release]; \u002F\u002Fуменьшим счетчик другого своего инварианта\n\u002F\u002F[_myIntMember release]; это полный бред, т.к. встроенные типы сообщений не принимают вообще и счетчиков не ведут\n[super dealloc]; \u002F\u002Fcкажем объекту базового класса, что пора освобождать память\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EМетоды доступа\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nПравильная работа с подсчетом ссылок очень важна при возврате адреса объекта из метода или инициализации инварианта формальным параметром. Обычно такими вещами занимаются так называемые методы доступа, возвращающие и устанавливающие инварианты объектов. Принято именовать метод, возвращающий значение инварианта, так же как и инвариант, а имя метода, устанавливающего его значение, начинать со слова set:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E- (void)setRe: (double)re\n{\n_re = re;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТак как инвариант _re относится ко встроенному типу, никаких сложностей с изменением его значения не возникает. Но если инвариант – объект некоторого класса – то простым присваиванием не обойтись, ведь надо учитывать счетчики ссылок. Для решения этой проблемы применяются следующие три метода:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E\u002F\u002Fнапример, нужно изменить текст у ярлыка\n[label setText: @”Hello world”]; \u002F\u002Fустанавливаем инвариант text\n\u002F\u002Fобъекта label равным текстовой константе типа NSString *\n\n\u002F\u002Fпримерная реализация setText в классе UILabel (вариант №1)\n- (void)setText: (NSString *)text\n{\n[text retain]; \u002F\u002Fувеличиваем счетчик ссылок на формальный параметр\n[_text release]; \u002F\u002Fуменьшаем счетчик ссылок текущего значения своего инварианта _text\n_text = text; \u002F\u002Fинициализируем инвариант новым значением\n}\n\n\u002F\u002Fпримерная реализация setText в классе UILabel (вариант №2)\n- (void)setText: (NSString *)text\n{\nif (_text != text) \u002F\u002Fcравниваем указатели на объекты\n{\n[_text release]; \u002F\u002Fуменьшаем счетчик ссылок текущего значения\n\u002F\u002Fсвоего инварианта _text\n_text = [text retain]; \u002F\u002Fувеличиваем счетчик ссылок\n\u002F\u002Fна формальный параметр и инициализируем свой инвариант\n}\n}\n\n\u002F\u002Fпримерная реализация setText в классе UILabel (вариант №3 – нежелательный)\n- (void)setText: (NSString *)text\n{\nif (_text != text)\n{\n[_text autorelease]; \u002F\u002Fскинем текущеe значения своего\n\u002F\u002Fинварианта _text в самовыгружаемый пул\n_text = [text retain]; \u002F\u002Fувеличиваем счетчик ссылок\n\u002F\u002Fна формальный параметр и инициализируем свой инвариант\n}\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВариант №3 не очень удачный потому, что засоряет текущий самовыгружаемый пул, а обычно это не очень желательно (см. следующий раздел).\u003Cbr\u002F\u003E\r\nМетод доступа для чтения значения инварианта всегда очень прост:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E- (NSString *)text\n{\nreturn _text;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EСамовыгружаемый пул в нитях программы\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nТеперь попробуем вернуть из метода созданный внутри него объект:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E-(NSString *)sayHelloToName: (NSString *)name withSurname: (NSString *)surname \n{\nNSString *retString = [[NSString alloc] initWithFormat: @”%@ %@!”, name, surname]; \u002F\u002Fинициализируем созданный объект посредством строки формата\nreturn retString;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nСтрока формата соответствует стандарту языка С. Но если в ней необходимо указать тип id, то используется спецификатор формата %@. Каким образом метод, разбирающий формат, понимает какие символы подставить вместь id? Он просто подставит то, что вернет метод описания description данного объекта. Этот метод изначально объявлен для класса NSObject. NSString переопределил его на вывод своего строкового содержания. Переопределив его, любой объект может представлять свое строковое содержание. Например, так это может сделать класс комплексного числа с двумя инвариантами типа double:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E- (NSString *)description\n{\nreturn [NSString stringWithFormat: @”re: %lf im: %lf”, _re, _im]; \u002F\u002Fвозвращает строку @“re: 1.0 im: 2.5” для _re == 1.0 и _im == 2.5\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПосле выполнения метода sayHelloToName:withSurname: определенно произойдет утечка памяти, так как вызывающий код скорей всего не догадывается, что возвращенному объекту нужно после обработки послать сообщение release. Даже если он догадается это сделать, возможно, что возвращался указатель на инвариант объекта, а значит его уничтожение чревато серьезными последствиями. Хотелось бы иметь механизм самоосвобождения объектов когда либо в будующем, чтобы пользовательский код вообще не думал об их освобождении. Решается эта проблема с помощью объекта класса NSAutoreleasePool – самовыгружаемого пула объектов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПосле создания объекта такого класса всем объектам, созданным после него, можно послать сообщения autorelease. При этом данный объект помещается в текущий (последний созданный) самовыгружаемый пул. Когда некий пул получит сообщение release, то он отошлет такое же сообщение и всем своим объектам, уменьшая их счетчик ссылок (по сути, уничтожая). Таким образом. Объект, помещенный в самовыгружаемый пул, продолжает жить и занимать память во все время жизни пула. Это удобно для небольших временных объектов, но может с течением времени занять значительную часть памяти. Потому рекомендуется циклы, способные порождать большое количество временных объектов, которые отправляются в самовыгружаемый пул, обрамлять локальными (вложенными) пулами.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЛюбая нить в программе, использующей Cocoa, должна создавать объект класса NSAutoreleasePool в самом начале (прежде создания других объектов), и в самом конце его уничтожать (после уничтожения всех других объектов). Функция main(), являющаяся главной нитью любой программы на Objective-C, при использовании фреймворка Cocoa должна всегда выглядеть вот так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eint main(int argc, char *argv[]) \u002F\u002F или же просто main()\n{ \nNSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; \u002F\u002Fсоздаем пул, он автоматически становится текущим\nint retVal;\n\u002F\u002Fтеперь можно программировать спокойно\n[pool drain]; \u002F\u002Fосвобождаем пул и все объекты, помещенные в него вызовами autorelease\nreturn retVal;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nА корректный метод sayHelloToName:withSurname: теперь будет выглядеть вот так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E-(NSString *)sayHelloToName: (NSString *)name withSurname: (NSString *)surname \n{\nNSString *retString = [[NSString alloc] initWithFormat: @”%@ %@!”, name, surname]; \u002F\u002Fинициализируем созданный объект посредством строки формата\n[retString autorelease]; \u002F\u002Fпомещаем в пул, теперь retString освободится вместе с пулом\nreturn retString;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nК слову, метод drain самовыгружаемого пула аналогичен release с той лишь разницей, что, кроме освобождения себя самомго и всех содержащихся объектов, еще дает подсказку сборщику мусора вступить в игру. Однако, это актуально только для Mac OS 10.4 и выше, так как на iOS сборки мусора нет.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EОпределение класса\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nТеперь рассмотрим файл Complex.m с определением методов класса Complex:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E#import “Complex.h”\n\n@implementation Complex\n- (id)init\n{\nreturn [self initWithRe: 0.0 andIm: 0.0];\n}\n- (id)initWithRe: (double)re andIm: (double)im\n{\nif (self = [super init])\n{\n_re = re;\n_im = im;\n_format = @”re: %.1lf im: %.1lf”; \u002F\u002Fформат вывода по умолчанию\n}\n}\n+ (Complex *)complexWithRe: (double)re andIm: (double)im\n{\nreturn [[[Complex alloc] initWithRe: re andIm: im] autorelease];\n}\n- (Complex *)add: (Complex *)other\n{\nreturn [[Complex alloc] initWithRe: _re + other-\u003E_re andIm: _im + other-\u003E_im];\n}\n- (Complex *)sub: (Complex *)other\n{\nreturn [[Complex alloc] initWithRe: _re – other-\u003E_re andIm: _im – other-\u003E_im];\n}\n- (NSString *)format\n{\nreturn _format;\n}\n- (void)setFormat: (NSString *)format\n{\u002F\u002Fстандартный порядок действий для инварианта-объекта\n[format retain];\n[_format release];\n_format = format;\n}\n- (double)re\n{\nreturn _re;\n}\n- (void)setRe: (double)re\n{\n_re = re;\n}\n- (double)im\n{\nreturn _im;\n}\n- (void)setIm: (double)im\n{\n_im = im;\n}\n- (NSString *)description\n{\u002F\u002Fиспользуем установленный формат вывода\nreturn [NSString stringWithFormat: _format, _re, _im]; \n}\n- (void)dealloc\n{\n[_format release]; \u002F\u002Fдля этого и переопределялся dealloc\n[super dealloc];\n}\n@end\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКонструктор по умолчанию вызывает специализированный конструктор с определенными начальными параметрами. Метод complexWithRe:andIm: возвращает инициализированный объект класса Complex, размещенный в текущем самовыгружаемом пуле. То же самое делает и метод description, возвращая объект класса NSString. Вот пример программы, где используется класс Complex:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E#import “Complex.h”\n#import &lt;stdio.h\u003E  \u002F\u002Fдля printf()\n\nint main()\n{ \nNSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\nComplex *num1 = [[Complex alloc] init]; \u002F\u002F0.0+0.0*i\nComplex *num2 = [[Complex alloc] initWithRe: 1.5 andIm: -2];\n\u002F\u002F1.5-2.0*i\nComplex *num3 = [Complex complexWithRe: 5 andIm: 7];\n\u002F\u002F5.0+7.0*i\nprintf(“%s\\n”, [[num2 description] cStringUsingEncoding: NSASCIIStringEncoding]); \u002F\u002Fвывод\u003E re: 1.5 im: -2.0\nprintf(“%s\\n”, [[[num2 add: num3] description] cStringUsingEncoding: NSASCIIStringEncoding]); \u002F\u002Fвывод\u003E re: 6.5 im: 5.0\n[num1 setRe: [num2 re]]; \u002F\u002Fзадаем _re для num1 как у num2\n[num1 setIm: [num3 im]]; \u002F\u002Fзадаем _im для num1 как у num3\n[num1 setFormat: @”%.2lf+%.2lf*i”]; \u002F\u002Fменяем формат вывода для num1\nprintf(“%s\\n”, [[num1 description] cStringUsingEncoding: NSASCIIStringEncoding]); \u002F\u002Fвывод\u003E 1.50+7.00*i\n[num1 release];\n[num2 release];\n\u002F\u002F[num3 release]; не нужно, т.к. он уже в самовыгружаемом пуле\n[pool drain];\nreturn 0;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EКатегории и расширения\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nЕсли к уже написанному (а, возможно, и откомпилированному) классу нужно добавить\\переопределить некоторые методы без наследования – категории позволяют это сделать без особых усилий:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E\u002F\u002Fфайл “CategorizedComplex.h”\n\n#import “Complex.h”\n@interfce Complex (CategorizedComplex)\n- (Complex *)mul: (Complex *)other;\n- (Complex *)div: (Complex *)other;\n@end\n\n\u002F\u002Fфайл “CategorizedComplex.m”\n#import “CategorizedComplex.h”\n\n@implementation Complex (CategorizedComplex)\n- (Complex *)mul: (Complex *)other\n{\nreturn [Complex complexWithRe: _re * other-\u003E_re - _im * other-\u003E_im andIm: _re * other-\u003E_im + _im * other-\u003E_re];\n}\n- (Complex *)div: (Complex *)other\n{\ndouble retRe, retIm, denominator;\ndenominator = other-\u003E_re * other-\u003E_re + other-\u003E_im * other-\u003E_im;\nif (!denominator)\nreturn nil;\nretRe = (_re * other-\u003E_re + _im * other-\u003E_im) \u002F denominator;\nretIm = (_im * other-\u003E_re - _re * other-\u003E_im) \u002F denominator;\nreturn [Complex complexWithRe: retRe andIm: retIm];\n}\n@end\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nА пользоваться этим можно вот так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003ECategorizеdComplex *num1 = [[CategorizedComplex alloc] initWithRe: 1 andIm: 999];\nComplex *num2 = [Complex complexWithRe: 0 andIm: 0];\nCategorizedComplex *num3 = [num1 div: num2]; \u002F\u002Fnum3 == nil\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nРасширения несут добрую службу как безымянные категории:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E\u002F\u002Fфайл “CategorizedComplex.m”\n#import “CategorizedComplex.h”\n@interface Complex ()\n- (void)zeroComplex; \u002F\u002Fтайный метод для обнуления числа\n@end\n\n@implementation Complex\n- (void)zeroComplex \u002F\u002Fим могут пользоваться только методы самого класса\n{\n_re = 0;\n_im = 0; \n}\n@end\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EПротоколы\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nПротокол Objective-C – это формализованное объявление группы методов, которые, по желанию, может реализовать любой класс (аналог класса в С++, где все методы объявлены со спецификатором virtual … = 0). В версии языка 2.0 методы протокола могут быть требуемыми (спецификатор  @required, он считается умалчиваемым) и выборочными (спецификатор  @optional). Если какой либо класс реализовал требуемые методы протокола, то он называется классом, поддерживающим данный протокол. Протокол, и класс, его поддерживающий, объявляются вот так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E@protocol MyPrinterProtocol\n@required\n- (void)print;\n- (BOOL)switchedOn;\n@optional\n- (void)loadPapaer: (int)numberOfPages;\n@end\n\n@interface MyPrinter : NSObject &lt;MyPrinterProtocol\u003E\n\u002F\u002Fтеперь MyPrinter реализует методы MyPrinterProtocol\n{\nBOOL _state;\nint _numberOfPages;\n}\n- (id)initWithState: (BOOL)state andPagesCount: (int)pages;\n- (BOOL)state;\n@end\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nOбъекту класса MyPrinter можно гарантированно посылать сообщения print и switchedOn, и, после проверки на respondsToSelector:, можно посылать сообщение loadPaper:, та как в его реализации должны присутствовать определения одноименных методов. Объявление объекта класса, поддерживающего какой-либо протокол осуществляется так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EMyPrinter *printer;\nid anotherPrinter = [[MyPrinter alloc] init];\n[anotherPrinter print]; \u002F\u002Fбезымянный объект отвечает на сообщение без предупреждений компилятора\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКроме того, один класс может удовлетворять нескольким протоколам. Для этого их можно перечислить через запятую в угловых скобках в объявлении класса.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E@interface MyPrinter : NSObject &lt;MyPrinterProtocol, OtherProtocol\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nА чтобы объявить объект неизвестного класса (id), соответствующий некоторому протоколу, пишут так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eid &lt;MyPrinterProtocol&amp;gt somePrinter;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EИсключения\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nЕсть два основных подхода к обработке ошибок: глобальная статусная переменная, значение которой информирует об успешности выполнения предыдущей операции, и генерация исключений. Суть обоих в том, что код, в котором произошла ошибка, надеется, что решить ее сможет вызвавший его код, поэтому возвращает управление ему, сообщая о произошедшей ситуации как можно более подробно. Objective-C поддерживает оба эти подхода.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИсключение – это объект некоторого класса. Он (даже своим типом) несет в себе некоторую информацию о произошедшей ситуации. Для удобства в Cocoa имеется класс NSException, который можно инициализировать двумя объектами NSString и одним объектом произвольного класса (тип id):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E- (id)initWitnName: (NSString *)name reason: (NSString *)reason userInfo: (id)userInfo;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nСгенерировать исключение и, тем самым, запустить механизм раскрутки стека вызовов, можно с помощью оператора  @throw. Чтобы перхватить сгенерированное исключение, участок кода, где возможна его генерация, необходимо заключить в специальный блок с заглавием  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Ftry\u002F\" class=\"user_link\"\u003Etry\u003C\u002Fa\u003E (такие блоки могут быть вложенными). А затем, после этого блока, поставить блок с заглавием  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Fcatch\u002F\" class=\"user_link\"\u003Ecatch\u003C\u002Fa\u003E(), где в круглых скобках указать тип предполагаемого исключения. Блоков  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Fcatch\u002F\" class=\"user_link\"\u003Ecatch\u003C\u002Fa\u003E() после блока  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Ftry\u002F\" class=\"user_link\"\u003Etry\u003C\u002Fa\u003E может быть несколько. После генерации исключения управление, раскручивая стек, выходит из блока  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Ftry\u002F\" class=\"user_link\"\u003Etry\u003C\u002Fa\u003E и, проверяя по очереди все блоки  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Fcatch\u002F\" class=\"user_link\"\u003Ecatch\u003C\u002Fa\u003E(), попадает именно в тот блок  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Fcatch\u002F\" class=\"user_link\"\u003Ecatch\u003C\u002Fa\u003E(), в фигурных скобках которого стоит такой тип, к которому тип исключения приводится неявно (точное совпадение, указатель на базовый класс или id). Если исключение по типу не совпало ни с одним блоком  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Fcatch\u002F\" class=\"user_link\"\u003Ecatch\u003C\u002Fa\u003E(), управление продолжает раскрутку стека. Если после блока с заглавием  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Ftry\u002F\" class=\"user_link\"\u003Etry\u003C\u002Fa\u003E стоит блок с заглавием  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Ffinally\u002F\" class=\"user_link\"\u003Efinally\u003C\u002Fa\u003E, то управление передастся ему независимо от того, произошло ли в блоке  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Ftry\u002F\" class=\"user_link\"\u003Etry\u003C\u002Fa\u003E исключение (и обработан какой-нибудь блок  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Fcatch\u002F\" class=\"user_link\"\u003Ecatch\u003C\u002Fa\u003E()), или выполнилась его последняя инструкция. Ниже приведен пример работы с объектом класса Cup в методе fill которого происходит исключение:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003ECup *cup = [[Cup alloc] init];\n@try \n{\n[cup fill]; \u002F\u002Fв fill генерируется исключение типа NSException\n}\n@catch (NSException *exception)\n{\u002F\u002Fлогируем произошедшее исключение с помощью NSLog\nNSLog(@\"main: Caught %@: %@\", [exception name], [exception reason]);\n}\n@finally \u002F\u002Fсюда после @try мы попадем неизбежно\n{\n[cup release]; \n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ блоке  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Ffinally\u002F\" class=\"user_link\"\u003Efinally\u003C\u002Fa\u003E удобно освобождать ресурсы, выделенные в блоке  \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Ftry\u002F\" class=\"user_link\"\u003Etry\u003C\u002Fa\u003E, но не освобожденные по причине сгенерированного исключения.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EСвойства\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nДля версии Objective-C 2.0 нашa реализация класса Complex явно избыточна: в ней слишком много методов доступа и их определение – сплошная рутина. Перепишем его с использованием свойств:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E\u002F\u002Fфайл “Complex.h”\n#import &lt;Foundation\u002FFoundation.h\u003E  \u002F\u002Fдля NSObject и строк NSString\n\n@interface Complex : NSObject\n{\ndouble _re; \u002F\u002Fинвариант для действительной части\ndouble _im; \u002F\u002Fинвариант для мнимой части\nNSString *_format; \u002F\u002Fстрока формата для метода description\n}\n- (id)initWithRe: (double)re andIm: (double)im; \n+ (Complex *)complexWithRe: (double)re andIm: (double)im; \n- (Complex *)add: (Complex *)other; \u002F\u002Fметод для сложения\n- (Complex *)sub: (Complex *)other; \u002F\u002Fметод для вычетания\n@property (nonatomic, retain) NSString *format; \u002F\u002Fобъявим методы доступа\n@property (nonatomic, assign) double re; \u002F\u002Fпосредством объявления свойств\n@property (nonatomic, assign) double im;\n@end\n\n\u002F\u002Fфайл “Complex.m”\n#import “Complex.h”\n\n@implementation Complex\n@synthesize format = _format; \u002F\u002Fсгенерируем методы доступа\n@synthesize re = _re; \u002F\u002Fи заодно переменуим их\n@synthesize im = _im; \u002F\u002Fчтобы в имени не было подчеркивания \n- (id)init\n{\nreturn [self initWithRe: 0.0 andIm: 0.0];\n}\n- (id)initWithRe: (double)re andIm: (double)im\n{\nif (self = [super init])\n{\n_re = re;\n_im = im;\n_format = @”re: %.1lf im: %.1lf”; \u002F\u002Fформат вывода по умолчанию\n}\n}\n+ (Complex *)complexWithRe: (double)re andIm: (double)im\n{\nreturn [[[Complex alloc] initWithRe: re andIm: im] autorelease];\n}\n- (Complex *)add: (Complex *)other\n{\nreturn [[Complex alloc] initWithRe: _re + other.re andIm: _im + other.im]; \u002F\u002Fиспользуем свойства re и im\n}\n- (Complex *)sub: (Complex *)other\n{\nreturn [[Complex alloc] initWithRe: _re – other.re andIm: _im – other.im]; \u002F\u002Fиспользуем свойства re и im\n}\n@end\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nСвойство – это некоторое имя, доступное через указатель на объект посредством оператора точка “.”. Свойства используются вместо методов доступа чтобы получить или установить инвариант объекта. При объявлении свойства указывается рад параметров, описывающих особенности генерируемых свойством методов доступа.\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Egetter=getterName, setter=setterName Указывает, что метод доступа для чтения будет называться getterName, а для изменения — setterName\u003C\u002Fli\u003E\r\n\u003Cli\u003Ereadonly Не генерировать метод доступа для изменения\u003C\u002Fli\u003E\r\n\u003Cli\u003Ereadwrite Генерировать оба метода доступа\u003C\u002Fli\u003E\r\n\u003Cli\u003Eassign Метод доступа на изменение реализовывать посредством простого присваивания\u003C\u002Fli\u003E\r\n\u003Cli\u003Eretain Принимаемому значению послать сообщение retain, предыдущему значению инварианта послать release и присвоить ему принимаемое значение\u003C\u002Fli\u003E\r\n\u003Cli\u003Ecopy Использовать обычный оператор присваивания, но присвоить копию принимаемого значения (перед присваиванием емупосылается сообщение copy)\u003C\u002Fli\u003E\r\n\u003Cli\u003Enonatomic Не использовать внутренние блокировки для синхронизации нескольких нитей в сгенерированных методах доступа (по умолчанию cинхронизация используется)\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003EТеперь в определении класса Complex нам не нужно вручную писать методы доступа. Они сгенерируются компилятором и будут идентичны тем, что были раньше.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EУдачи!\u003C\u002Fb\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"objective-c"},{"titleHtml":"mac os x"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F107126\u002F68a66d15c08113e69ea1745d4b3941ff\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F107126\u002F68a66d15c08113e69ea1745d4b3941ff\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F107126\\\u002F\"},\"headline\":\"Objective-C с нуля\",\"datePublished\":\"2010-10-29T17:40:01+04:00\",\"dateModified\":\"2011-03-23T12:48:28+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Anthony Shoumikhin\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"У любого желающего писать программы для продукции фирмы Apple в жизни наступает такой момент, когда ему приходиться изучить новый язык программирования &mdash; Objecti...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F107126\\\u002F#post-content-body\",\"about\":[\"h_ios_dev\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Ff1073050\\\u002F7aff6749\\\u002F77739192\\\u002Ffd020592.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002F29b3f167\\\u002F006356ff\\\u002F88414a4a\\\u002Fcb4d17e5.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002F53e1c6cb\\\u002F4d30e3d1\\\u002Fecfababe\\\u002F9dcb8d2a.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fd18a0af3\\\u002F844fdcce\\\u002F1285d539\\\u002F5e2f0c3b.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002F194952d8\\\u002F4bbdb524\\\u002F3a81ab57\\\u002F01842029.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002F8d94a5cd\\\u002F18d3a791\\\u002F33c7f9ac\\\u002Fa1811278.png\"]}","metaDescription":"У любого желающего писать программы для продукции фирмы Apple в жизни наступает такой момент, когда ему приходиться изучить новый язык программирования — Objective-C. Когда-то этот счастливый момент...","mainImageUrl":null,"amp":false},"polls":[],"commentsEnabled":true,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false},"578690":{"id":"578690","timePublished":"2021-09-29T09:00:02+00:00","isCorporative":true,"lang":"ru","titleHtml":"Пишем драйвер виртуального EEPROM для STM32F030","editorVersion":"1.0","postType":"article","postLabels":[],"author":{"id":"1705055","alias":"Neoprog","fullname":"Алексей","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F829\u002F06a\u002F3e1\u002F82906a3e13b5a04dee9b4deead9ffd8c.png","speciality":"Инженер-программист"},"statistics":{"commentsCount":11,"favoritesCount":24,"readingCount":968,"score":21,"votesCount":23},"hubs":[{"relatedData":null,"id":"19791","alias":"ruvds","type":"corporative","title":"Блог компании RUVDS.com","titleHtml":"Блог компании RUVDS.com","isProfiled":false},{"relatedData":null,"id":"359","alias":"programming","type":"collective","title":"Программирование","titleHtml":"Программирование","isProfiled":true},{"relatedData":null,"id":"19737","alias":"controllers","type":"collective","title":"Программирование микроконтроллеров","titleHtml":"Программирование микроконтроллеров","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"leadData":{"textHtml":"\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fruvds\u002Fblog\u002F578690\u002F\"\u003E\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Ftn\u002Fn0\u002Fm6\u002Ftnn0m62rtstlnjf-sl8axn3zves.png\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fa\u003E\u003Cbr\u003E\r\nКто хотел сохранять какие-либо данные в FLASH микроконтроллера во время работы устройства сталкивались с особенностями работы с этим видом памяти. Из-за необходимости стирания страницы большого объёма для перезаписи ячейки FLASH памяти, возникает угроза потери данных из-за отключения питания во время процесса обновления (один из вариантов). В этой статье я расскажу как можно упростить работу с FLASH, да и ещё с гарантией сохранения данных при прерывании процедуры обновления на любом этапе. Реализуем это на STM32F030.\u003Cbr\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"veeprom"},{"titleHtml":"flash-память"},{"titleHtml":"ruvds_статьи"},{"titleHtml":"программирование микроконтроллеров"}]},"578788":{"id":"578788","timePublished":"2021-09-28T17:03:01+00:00","isCorporative":true,"lang":"ru","titleHtml":"Принцип работы планировщика задач в Linux","editorVersion":"1.0","postType":"article","postLabels":[{"type":"translation","data":{"originalAuthorName":"Eliran","originalUrl":"https:\u002F\u002Fcodingkaiser.blog\u002F2021\u002F09\u002F16\u002Fprocess-scheduling-in-linux\u002F"}}],"author":{"id":"2488151","alias":"Bright_Translate","fullname":"Дмитрий Брайт","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Ff9c\u002Fff9\u002F7d9\u002Ff9cff97d9c0677af28dab451897f88e4.jpg","speciality":"Переводчик"},"statistics":{"commentsCount":11,"favoritesCount":59,"readingCount":4344,"score":29,"votesCount":33},"hubs":[{"relatedData":null,"id":"19791","alias":"ruvds","type":"corporative","title":"Блог компании RUVDS.com","titleHtml":"Блог компании RUVDS.com","isProfiled":false},{"relatedData":null,"id":"221","alias":"sys_admin","type":"collective","title":"Системное администрирование","titleHtml":"Системное администрирование","isProfiled":true},{"relatedData":null,"id":"7289","alias":"nix","type":"collective","title":"*nix","titleHtml":"*nix","isProfiled":true},{"relatedData":null,"id":"19727","alias":"linux_dev","type":"collective","title":"Разработка под Linux","titleHtml":"Разработка под Linux","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"6","alias":"admin","title":"Администрирование"}],"relatedData":null,"leadData":{"textHtml":"\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fruvds\u002Fblog\u002F578788\u002F\"\u003E\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fhf\u002Fx2\u002Fht\u002Fhfx2htdiptolxklsfgogcobnvkc.png\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fa\u003E\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nПланирование – это процесс распределения ресурсов системы для выполнения задач. В статье мы рассмотрим его вариант, в котором ресурсом является одно или несколько ядер процессора, а задачи представлены потоками или процессами, которые нужно выполнить.","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"ruvds_перевод"},{"titleHtml":"linux"},{"titleHtml":"планировщик"}]},"579530":{"id":"579530","timePublished":"2021-09-29T00:18:17+00:00","isCorporative":true,"lang":"ru","titleHtml":"Лучше поздно, чем никогда: Microsoft решила продолжить историю Skype","editorVersion":"1.0","postType":"article","postLabels":[],"author":{"id":"2413033","alias":"kkxen","fullname":null,"avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fdeb\u002Fc7f\u002Fe41\u002Fdebc7fe41d3a22ed05b308e454b3f3fd.jpg","speciality":"Influencer-marketing manager"},"statistics":{"commentsCount":54,"favoritesCount":5,"readingCount":14707,"score":33,"votesCount":37},"hubs":[{"relatedData":null,"id":"14740","alias":"selectel","type":"corporative","title":"Блог компании Selectel","titleHtml":"Блог компании Selectel","isProfiled":false},{"relatedData":null,"id":"92","alias":"instant_messaging","type":"collective","title":"Мессенджеры","titleHtml":"Мессенджеры","isProfiled":true},{"relatedData":null,"id":"20688","alias":"research","type":"collective","title":"Исследования и прогнозы в IT","titleHtml":"Исследования и прогнозы в IT","isProfiled":false},{"relatedData":null,"id":"21906","alias":"history","type":"collective","title":"История IT","titleHtml":"История IT","isProfiled":false}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"3","alias":"management","title":"Менеджмент"},{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"leadData":{"textHtml":"\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F8fc\u002Ff2b\u002F5e4\u002F8fcf2b5e48070f436d4ac6f9d4fe6558.png\"\u003E\u003C\u002Fdiv\u003E\u003Cbr\u003E\r\nКорпорация Microsoft приобрела VoIP-сервис Skype в 2011 году, можно сказать, на пике его популярности, за $8,5 млрд. И сейчас это огромная даже по меркам IT-отрасли сумма, а в 2011 году она была еще более внушительной. \u003Cbr\u003E\r\n\u003Cbr\u003E\r\nКомпания, по словам ее экс-руководителя Стива Баллмера, собиралась развивать вместе со Skype коммуникации, создав простую среду для общения друзей, родственников и коллег. В целом, все выглядело неплохо, ведь тогда количество пользователей составляло 663 млн человек, при должном старании Skype (а значит, и Microsoft) мог стать едва ли не монополистом среди коммуникационных инструментов. Но что-то пошло не так. \u003Cbr\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"skype"},{"titleHtml":"мессенджер"},{"titleHtml":"развитие"},{"titleHtml":"Microsoft"}]},"579626":{"id":"579626","timePublished":"2021-09-29T10:52:57+00:00","isCorporative":true,"lang":"ru","titleHtml":"Если крысе не давать спать, она умрёт через 3 недели — как работают мозг и сон","editorVersion":"1.0","postType":"article","postLabels":[],"author":{"id":"2221530","alias":"Asya_Dyu","fullname":"Анастасия","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Ffec\u002F943\u002F098\u002Ffec943098e84d65a162934040de8b9ed.gif","speciality":"Иллюстратор"},"statistics":{"commentsCount":0,"favoritesCount":20,"readingCount":1831,"score":11,"votesCount":11},"hubs":[{"relatedData":null,"id":"17357","alias":"timeweb","type":"corporative","title":"Блог компании Timeweb","titleHtml":"Блог компании Timeweb","isProfiled":false},{"relatedData":null,"id":"21910","alias":"popular_science","type":"collective","title":"Научно-популярное","titleHtml":"Научно-популярное","isProfiled":false},{"relatedData":null,"id":"21990","alias":"brain","type":"collective","title":"Мозг","titleHtml":"Мозг","isProfiled":false},{"relatedData":null,"id":"21996","alias":"health","type":"collective","title":"Здоровье","titleHtml":"Здоровье","isProfiled":false},{"relatedData":null,"id":"22750","alias":"biology","type":"collective","title":"Биология","titleHtml":"Биология","isProfiled":false}],"flows":[{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"leadData":{"textHtml":"\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F28\u002Fy8\u002Fzh\u002F28y8zheruspll4hf0lhvc4igdce.gif\"\u003E\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nПосмотрела 2х-часовую лекцию профессора МГУ про влияние сна на мозг и мозга на сон. Под катом конспект минут на 20 чтения. Если попытаться сжать до 1 минуты, то получится что-то вроде этого:\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EСколько нужно спать. Индивидуально, от 6 до 10 часов — для взрослого человека в пределах нормы.\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#Example\"\u003EГигиена сна\u003C\u002Fa\u003E. Просто якорь на слайд-список.\u003C\u002Fli\u003E\r\n\u003Cli\u003EБиологические часы — реальный физиологический процесс, который ориентируется на циркадные ритмы. Смена часовых поясов и работа по сменам «расшатывает» механизмы биологических часов. \u003C\u002Fli\u003E\r\n\u003Cli\u003EСпать надо ложиться не позже, чем… — фигня. Просто в одно и то же время.\u003C\u002Fli\u003E\r\n\u003Cli\u003EЕсли вы спите днем, купите себе хорошие шторы. Мелатонин коррелирует с освещением. Если в глаза (даже закрытые) светит солнце, вы не отдыхаете полноценно.\u003C\u002Fli\u003E\r\n\u003Cli\u003EСколько можно не спать. Без необратимых серьезных последствий взрослый человек выдержит до 4-х суток. \u003C\u002Fli\u003E\r\n\u003Cli\u003EСон делится на медленную и парадоксальную фазы. \u003C\u002Fli\u003E\r\n\u003Cli\u003EМедленная фаза сна — про очищение. Если нет медленной фазы сна, иммунитет, эндокринка, обменные процессы и гомеостаз идут лесом. Экспериментальные крысы умирают на 15-20 день без сна от воспаления, когда кишечные бактерии попадают в кровь.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПарадоксальная фаза сна участвует в обработке информации. По уровню электрической активности мозга она близка к состоянию активного решения сложных задач. \u003C\u002Fli\u003E\r\n\u003Cli\u003EКогда правильно просыпаться. На переходе от парадоксальной фазы к медленной. \u003C\u002Fli\u003E\r\n\u003Cli\u003EКак определить на глаз, когда можно будить. Когда человек лежал спокойно и начал ворочаться, можно будить.\u003C\u002Fli\u003E\r\n\u003Cli\u003EКофеин не позволяет организму получить сигнал об усталости, но не дает дополнительную энергию.\u003C\u002Fli\u003E\r\n\u003Cli\u003EКак затормозить перевозбужденную нервную систему нежно. Фенобарбитал в малых дозах — корвалол, валокордин, валосердин. Противогистаминные препараты. \u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"здоровье"},{"titleHtml":"сон"},{"titleHtml":"мозг"},{"titleHtml":"нейрофизиология"},{"titleHtml":"нейробиология"},{"titleHtml":"нейроны"}]},"579960":{"id":"579960","timePublished":"2021-09-28T17:50:38+00:00","isCorporative":false,"lang":"ru","titleHtml":"Архитектура Вселенной, часть 1: Сознание","editorVersion":"2.0","postType":"article","postLabels":[],"author":{"id":"248181","alias":"SergioShpadi","fullname":"Сергей Шпадырев","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F4c0\u002Fe3f\u002F7f3\u002F4c0e3f7f3dd535053b9bd3bbcc7fbfde.png","speciality":"Software Engineer"},"statistics":{"commentsCount":100,"favoritesCount":65,"readingCount":6636,"score":13,"votesCount":23},"hubs":[{"relatedData":null,"id":"21910","alias":"popular_science","type":"collective","title":"Научно-популярное","titleHtml":"Научно-популярное","isProfiled":false}],"flows":[{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003E\u003Cem\u003E'По одной капле воды человек, умеющий мыслить логически, может сделать вывод о возможности существования Атлантического океана или Ниагарского водопада, даже если он не видал ни того, ни другого и никогда о них не слыхал' -&nbsp;Артур Конан-Дойль, «Этюд в багровых тонах».\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cp\u003EМеня всегда восхищали древние философы, которые не имея никаких инструментов познания мира кроме собственного разума, бесстрашно погружались в пучины тайн мироздания. С помощью одних лишь только рассуждений они обретали исключительно глубокое понимание принципов работы механизма Вселенной, тем самым расширяя наши представления о мире.\u003C\u002Fp\u003E\u003Cp\u003EТрудно переоценить влияние философии на науку, так как наука произошла именно от философии. Использующаяся для формализации процесса рассуждений математика стала первенцем философии. Даже сами слова \"философия\" и \"математика\" произошли из терминов религиозной школы одного из величайших философов античности - Пифагора. Физика, названию которой мы обязаны другому великому античному философу - Аристотелю, примерно до XVIII века именовалась натуральной философией. Ему же мы обязаны появлением логики - науки о мышлении. Кроме того, философы, изучавшие процесс познания и его ограничения, создали важнейший инструмент исследования природы - научный метод. \u003C\u002Fp\u003E\u003Cp\u003EДаже многие научные открытия последних веков были вдохновлены философией. Иоганн Кеплер, Николай Коперник и Исаак Ньютон вдохновлялись теорией о гармонии мира Пифагора, о чем сами и писали в своих научных трудах. Альберт Эйнштейн был ярым приверженцем философии средневекового философа Бенедикта Спинозы, но также считал себя в некотором смысле платоником и пифагорейцем. Один из основоположников квантовой механики Эрвин Шрёдингер написал целую книгу о том, как его открытия в квантовой механике согласуются с индийской философией веданты. \u003C\u002Fp\u003E\u003Cp\u003EДо сих пор в западных университетах всем специалистам в точных и естественных науках, успешно защитившим свою диссертацию, присваивают почетное звание доктора философии - \u003Cem\u003EPhilosophiæ Doctor\u003C\u002Fem\u003E, часто сокращаемое в речи и на письме до простого PhD. Тем самым университеты подчеркивают, что философия лежит в самом основании всего человеческого знания. Но чем именно занимается философия, в чем состоит её роль?\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fd13\u002Fd45\u002F8ea\u002Fd13d458ea0fe8e643a0444a0133f0472.jpg","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fd13\u002Fd45\u002F8ea\u002Fd13d458ea0fe8e643a0444a0133f0472.jpg","fit":"cover","positionY":53.409090909091,"positionX":3.974358974359}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"сознание"},{"titleHtml":"квалиа"},{"titleHtml":"философский зомби"},{"titleHtml":"цвет"},{"titleHtml":"дэвид чалмерс"},{"titleHtml":"шредингер"},{"titleHtml":"макс планк"},{"titleHtml":"спиноза"}]},"580034":{"id":"580034","timePublished":"2021-09-28T17:18:57+00:00","isCorporative":false,"lang":"ru","titleHtml":"Пыль, пылевые клещи и их аллергены. Профилактика и защита","editorVersion":"1.0","postType":"article","postLabels":[{"type":"tutorial","data":null}],"author":{"id":"1841275","alias":"steanlab","fullname":"Cергей Бесараб (Siarhei Besarab) EU1AEY","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F2d8\u002Fb91\u002F145\u002F2d8b911451a45b7d469e3eead16f750d.jpg","speciality":"Хабра-химик, турист, авантюрист и радиолюбитель :)"},"statistics":{"commentsCount":39,"favoritesCount":53,"readingCount":9883,"score":50,"votesCount":58},"hubs":[{"relatedData":null,"id":"21910","alias":"popular_science","type":"collective","title":"Научно-популярное","titleHtml":"Научно-популярное","isProfiled":false},{"relatedData":null,"id":"21996","alias":"health","type":"collective","title":"Здоровье","titleHtml":"Здоровье","isProfiled":false},{"relatedData":null,"id":"22010","alias":"Chemistry","type":"collective","title":"Химия","titleHtml":"Химия","isProfiled":false},{"relatedData":null,"id":"22012","alias":"Ecology","type":"collective","title":"Экология","titleHtml":"Экология","isProfiled":false},{"relatedData":null,"id":"22750","alias":"biology","type":"collective","title":"Биология","titleHtml":"Биология","isProfiled":false}],"flows":[{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"leadData":{"textHtml":"Пыль и пылевые клещи в ней есть практически везде и всегда. Уничтожить их удается возможно только в условиях «чистых комнат» на производстве полупроводников. Приходится с этим мириться, и жить допуская, что все что нам под силу — уменьшить их количество. Считается, что если концентрация клещей &lt; 100 штук на грамм пыли — аллергия у большинства не возникает. После того как пришлось пару-тройку минут чихать без остановки — у меня накопилось достаточно злобы, чтобы \u003Ca href=\"https:\u002F\u002Ft.me\u002Fjoinchat\u002FAAAAAFFhzPKyiLO85pRxUA\" rel=\"nofollow noopener noreferrer\"\u003Eрассмотреть\u003C\u002Fa\u003E, что же представляет из себя пыль в квартире и что и кто в этой пыли живет. А теперь вот нашлось время, чтобы познакомить с «нашими маленькими друзьями» и читателей Хабра. В заметке рассуждения о некоторых особенностях биологии вездесущего домашнего паразита и методикам его контроля. То, что под катом можешь смело давать почитать жене, %username%!\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F580034\u002F\"\u003E\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fw0\u002F9u\u002Fzv\u002Fw09uzvckqowxlqadjnpx414mf6y.jpeg\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fa\u003E\u003Cbr\u003E","imageUrl":null,"buttonTextHtml":"Дружно скажем НЕТ пыли и ее обитателям","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"пыль"},{"titleHtml":"пыль это"},{"titleHtml":"пыль под микроскопом"},{"titleHtml":"пыль аллергия"},{"titleHtml":"пыль бытовая"},{"titleHtml":"мебельные клещи"},{"titleHtml":"пыль в воздухе"},{"titleHtml":"пыль текстура"},{"titleHtml":"из чего состоит пыль"},{"titleHtml":"пыль откуда берется"},{"titleHtml":"пыль от постельного белья"},{"titleHtml":"пыль обветшания"},{"titleHtml":"пыль размер частиц"},{"titleHtml":"пыль уборка"},{"titleHtml":"пыль химический состав"},{"titleHtml":"пыль что это"},{"titleHtml":"что такое пыль"},{"titleHtml":"откуда берется пыль"},{"titleHtml":"пыль это кожа"},{"titleHtml":"пылевые клещи как избавиться"},{"titleHtml":"пылевые клещи аллергия"},{"titleHtml":"пылевые клещи размер"},{"titleHtml":"где живут пылевые клещи"},{"titleHtml":"пылевые клещи борьба с ними"},{"titleHtml":"пылевые клещи борьба"},{"titleHtml":"пылевые клещи боятся холода"},{"titleHtml":"клещи пылевые"},{"titleHtml":"пылевые клещи в подушках"},{"titleHtml":"в постели"},{"titleHtml":"в матрасе"},{"titleHtml":"в постельном белье"},{"titleHtml":"в мягких игрушках"},{"titleHtml":"в одежде"},{"titleHtml":"в каждом доме"},{"titleHtml":"в диване"},{"titleHtml":"в ковре"},{"titleHtml":"пылевые клещи вред"},{"titleHtml":"пылевые клещи дезинфекция"},{"titleHtml":"пылевые клещи и ультрафиолет"},{"titleHtml":"пылевые клещи избавление"},{"titleHtml":"пыль и пылевые клещи"},{"titleHtml":"пылевые клещи мороз"},{"titleHtml":"пылевые клещи обработка"},{"titleHtml":"пылевые клещи профилактика"},{"titleHtml":"клещи при стирке"},{"titleHtml":"средства от клещей"},{"titleHtml":"пылевые клещи температура"},{"titleHtml":"клещи озон"},{"titleHtml":"аллергия на пыль"},{"titleHtml":"плесень"},{"titleHtml":"Валлемия"},{"titleHtml":"микотоксины"},{"titleHtml":"никто не читает тэги"}]},"580118":{"id":"580118","timePublished":"2021-09-29T09:34:41+00:00","isCorporative":true,"lang":"ru","titleHtml":"Вычисляем на видеокартах. Технология OpenCL. Часть 1a. Как работает OpenCL","editorVersion":"1.0","postType":"article","postLabels":[],"author":{"id":"2690813","alias":"xjossy","fullname":"Georgy Osipov","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F5c1\u002Ff73\u002F5f3\u002F5c1f735f3c77ebd66743a8e2f38a98b2.png","speciality":"Пользователь"},"statistics":{"commentsCount":2,"favoritesCount":29,"readingCount":988,"score":11,"votesCount":11},"hubs":[{"relatedData":null,"id":"22588","alias":"yandex_praktikum","type":"corporative","title":"Блог компании Яндекс.Практикум","titleHtml":"Блог компании Яндекс.Практикум","isProfiled":false},{"relatedData":null,"id":"4","alias":"hi","type":"collective","title":"Высокая производительность","titleHtml":"Высокая производительность","isProfiled":true},{"relatedData":null,"id":"359","alias":"programming","type":"collective","title":"Программирование","titleHtml":"Программирование","isProfiled":true},{"relatedData":null,"id":"9233","alias":"gpgpu","type":"collective","title":"GPGPU","titleHtml":"GPGPU","isProfiled":true},{"relatedData":null,"id":"21944","alias":"videocards","type":"collective","title":"Видеокарты","titleHtml":"Видеокарты","isProfiled":false}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"leadData":{"textHtml":"22 июня автор курса \u003Ca href=\"https:\u002F\u002Fpracticum.yandex.ru\u002Fcpp?utm_source=pr&amp;utm_medium=content&amp;utm_content=28_09_21&amp;utm_campaign=pr_content_cpp_habr\" rel=\"nofollow noopener noreferrer\"\u003E«Разработчик C++» \u003C\u002Fa\u003Eв Яндекс.Практикуме Георгий Осипов провёл вебинар \u003Ca href=\"https:\u002F\u002Fyoutu.be\u002FyPCeYXxSLjA\" rel=\"nofollow noopener noreferrer\"\u003E«Вычисляем на видеокартах. Технология OpenCL».\u003C\u002Fa\u003E\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Ca href=\"https:\u002F\u002Fyoutu.be\u002FyPCeYXxSLjA\" rel=\"nofollow noopener noreferrer\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fwq\u002Frf\u002Fap\u002Fwqrfaphypdz0hchnq36fsinwes8.png\"\u003E\u003C\u002Fa\u003E\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nМы подготовили для вас его текстовую версию, для удобства разбив её на смысловые блоки.\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fyandex_praktikum\u002Fblog\u002F575484\u002F\"\u003E0. Зачем мы здесь собрались. Краткая история GPGPU.\u003C\u002Fa\u003E\u003Cbr\u003E\r\n \u003Cb\u003E1a. Как работает OpenCL.\u003C\u002Fb\u003E\u003Cbr\u003E\r\n 1b. Пишем для OpenCL.\u003Cbr\u003E\r\n 2. Алгоритмы в условиях массового параллелизма.\u003Cbr\u003E\r\n 3. Сравнение технологий.\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nМы обещали, что разберём написание полноценной программы уже в этой части, но материала оказалось слишком много, и мы разбили эту часть надвое. В первой половине расскажем про основные принципы, которые должен знать каждый OpenCL-разработчик, а во второй напишем программу.\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Ci\u003EЕсть мнение, что для написания эффективного кода для GPU программист обязан понимать архитектуру видеокарты. И это мнение не чьё-нибудь там, а NVIDIA (см. \u003Ca href=\"https:\u002F\u002Fwww.nvidia.ru\u002Fcontent\u002FEMEAI\u002FCUDA\u002Flecture_documents\u002FLecture_11.pdf\" rel=\"nofollow noopener noreferrer\"\u003EЛекции NVIDIA по GPGPU\u003C\u002Fa\u003E). Не будем спорить и разберём базовые принципы работы видеокарты.\u003C\u002Fi\u003E\u003Cbr\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"OpenCL"},{"titleHtml":"CUDA"},{"titleHtml":"GPU"},{"titleHtml":"GPGPU"},{"titleHtml":"NVIDIA"},{"titleHtml":"OpenGL"},{"titleHtml":"видеокарты"},{"titleHtml":"высокая производительность"},{"titleHtml":"курс Разработчик C++"},{"titleHtml":"высокопроизводительные"},{"titleHtml":"многопоточные вычисления"},{"titleHtml":"Яндекс Практикум"}]},"580222":{"id":"580222","timePublished":"2021-09-28T13:07:07+00:00","isCorporative":true,"lang":"ru","titleHtml":"Ортодонтия во взрослом возрасте: зачем вам это надо и что лучше знать до начала лечения","editorVersion":"1.0","postType":"article","postLabels":[],"author":{"id":"2793023","alias":"magomedovazuzu","fullname":"Магомедова Зузу","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fd25\u002Fd7f\u002Fc69\u002Fd25d7fc697c903cbe6dfdf1423b5b7ba.jpg","speciality":"Врач стоматолог-ортопед"},"statistics":{"commentsCount":16,"favoritesCount":32,"readingCount":6703,"score":25,"votesCount":35},"hubs":[{"relatedData":null,"id":"22616","alias":"belayaraduga","type":"corporative","title":"Блог компании Белая Радуга","titleHtml":"Блог компании Белая Радуга","isProfiled":false},{"relatedData":null,"id":"21910","alias":"popular_science","type":"collective","title":"Научно-популярное","titleHtml":"Научно-популярное","isProfiled":false},{"relatedData":null,"id":"21996","alias":"health","type":"collective","title":"Здоровье","titleHtml":"Здоровье","isProfiled":false}],"flows":[{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"leadData":{"textHtml":"\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fph\u002Fy_\u002Fys\u002Fphy_ysqfi51itdfzul5g9ujtcpe.png\" alt=\"image\"\u003E\u003Cbr\u003E\r\n\u003Ci\u003E\u003Ca href=\"https:\u002F\u002Forthodonticassoc.com\u002Fblog\u002Fthe-evolution-of-orthodontic-braces\u002F\" rel=\"nofollow noopener noreferrer\"\u003EПримерно \u003C\u002Fa\u003Eтак в конце XIX века выпрямляли зубы\u003C\u002Fi\u003E\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nВ современном мире не принято умирать от кривых зубов. Максимум, что с вами случится, — станет не очень приятно широко открывать рот, вылетит челюстной сустав, вырастут амортизационные издержки на периодонт зубов, да и со стоматологом вы начнёте видеться чаще. \u003Cbr\u003E\r\n\u003Cbr\u003E\r\nВ принципе 99% проблем с расположением зубов сегодня можно исправить без проблем. Для этого есть опоры, создающие давление на зубы и кости, двигающие их. Брекеты несъёмные фиксируются с внешней или внутренней стороны зубов, ими можно решить много проблем, но они требуют постоянного ухода и посещения клиники раз в месяц. Альтернатива — элайнеры, прозрачные капы. Их можно снимать, чистить зубы как обычно и есть всё подряд. \u003Cbr\u003E\r\n\u003Cbr\u003E\r\nВ большинстве случаев ортодонтическое лечение требует от 8 месяцев до 2 лет в зависимости от сложности случая. На масштабные изменения вроде перемещения соседнего седьмого зуба на место отсутствующего шестого может уйти и 3 года. Плюс есть вероятность неуспеха, потому что нужно много считать.\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nСмоделировать возможную ситуацию можно на основе данных КТ, телерентгенограммы и 3D-моделирования (это после съёмки полости рта сканером). Это более-менее страхует от скрытых кист, сверхкомплектных зубов и прочих радостей, которые могут вылезти в процессе лечения. \u003Cbr\u003E\r\n\u003Cbr\u003E\r\nИтак, сегодня: \u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E Что умеет современная ортодонтия и сколько она стоит.\u003C\u002Fli\u003E\r\n\u003Cli\u003E Как мы корректируем прикус с помощью брекетов и элайнеров. \u003C\u002Fli\u003E\r\n\u003Cli\u003E Зачем используем в дополнение минивинты (импланты) и нёбные расширители.\u003C\u002Fli\u003E\r\n\u003Cli\u003E Когда будет результат. И что мы делаем, чтобы его закрепить. \u003C\u002Fli\u003E\r\n\u003Cli\u003E Что может пойти не так при установке брекетов или элайнеров.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"зуб"},{"titleHtml":"ортодонтия"},{"titleHtml":"лечение"},{"titleHtml":"элайнеры"},{"titleHtml":"брекеты"},{"titleHtml":"стоматология"}]},"580296":{"id":"580296","timePublished":"2021-09-28T17:06:29+00:00","isCorporative":true,"lang":"ru","titleHtml":"О чём .NET-разработчикам расскажут на DotNext 2021 Moscow","editorVersion":"2.0","postType":"article","postLabels":[],"author":{"id":"2238368","alias":"k_tultseva","fullname":"Christina","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F44b\u002Fd20\u002F52c\u002F44bd2052c476b5ee251ae790021fcde4.jpg","speciality":"Редактор"},"statistics":{"commentsCount":1,"favoritesCount":7,"readingCount":1341,"score":10,"votesCount":10},"hubs":[{"relatedData":null,"id":"18226","alias":"jugru","type":"corporative","title":"Блог компании JUG Ru Group","titleHtml":"Блог компании JUG Ru Group","isProfiled":false},{"relatedData":null,"id":"4","alias":"hi","type":"collective","title":"Высокая производительность","titleHtml":"Высокая производительность","isProfiled":true},{"relatedData":null,"id":"546","alias":"net","type":"collective","title":".NET","titleHtml":".NET","isProfiled":true},{"relatedData":null,"id":"20754","alias":"tech_events","type":"collective","title":"Конференции","titleHtml":"Конференции","isProfiled":false}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"4","alias":"marketing","title":"Маркетинг"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EПорой жизнь разработчика превращается в кошмар. Называться это может по-разному: «миграция большого проекта», «отладка асинхронного кода», «запущенное легаси» или даже «зоопарк технологий для распределённых приложений». Уже скоро мы проведем .NET-конференцию \u003Cstrong\u003E\u003Ca href=\"https:\u002F\u002Fdotnext-moscow.ru\u002F?utm_source=habr&amp;utm_medium=580296\"\u003E\u003Cu\u003EDotNext\u003C\u002Fu\u003E\u003C\u002Fa\u003E\u003C\u002Fstrong\u003E, и поучаствовать в ней не только интересно, но и может помогать от кошмаров.\u003C\u002Fp\u003E\u003Cp\u003EСреди тем конференции — и низкоуровневый хардкор, и нестандартные подходы, и личные истории преодоления препятствий. А рассказывать обо всём этом будут яркие спикеры, уже знакомые многим .NET-разработчикам: например, Скотт Влашин, Дилан Битти, Стивен Тауб, Егор Богатов, Евгений Пешков.\u003C\u002Fp\u003E\u003Cp\u003EВ программу сейчас вносятся последние штрихи, так что возможны маленькие изменения, но в целом доклады будет такими, как описано под катом. А кроме докладов, будут ещё и активности от программного комитета (вроде игры в формате ЧГК), о них позже расскажем отдельно.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Faee\u002F58c\u002F604\u002Faee58c604114791cf6e493e61c72f433.png","buttonTextHtml":"Смотреть программу","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Faee\u002F58c\u002F604\u002Faee58c604114791cf6e493e61c72f433.png","fit":"cover","positionY":0,"positionX":0}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":".net"},{"titleHtml":".net development"},{"titleHtml":"конференция"},{"titleHtml":"dotnext"}]},"580392":{"id":"580392","timePublished":"2021-09-29T09:00:14+00:00","isCorporative":true,"lang":"ru","titleHtml":"Дообучаем готовую нейросеть для классификации данных","editorVersion":"2.0","postType":"article","postLabels":[],"author":{"id":"2072505","alias":"MrNightSky","fullname":"Yaroslav Murzaev","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F9ce\u002F822\u002Fa59\u002F9ce822a590f5ae38e2ccd2507deaf9ef.jpg","speciality":"Data Scientist, ML engineer"},"statistics":{"commentsCount":0,"favoritesCount":27,"readingCount":445,"score":30,"votesCount":32},"hubs":[{"relatedData":null,"id":"18232","alias":"funcorp","type":"corporative","title":"Блог компании FUNCORP","titleHtml":"Блог компании FUNCORP","isProfiled":false},{"relatedData":null,"id":"340","alias":"python","type":"collective","title":"Python","titleHtml":"Python","isProfiled":true},{"relatedData":null,"id":"17175","alias":"image_processing","type":"collective","title":"Обработка изображений","titleHtml":"Обработка изображений","isProfiled":true},{"relatedData":null,"id":"19439","alias":"machine_learning","type":"collective","title":"Машинное обучение","titleHtml":"Машинное обучение","isProfiled":true},{"relatedData":null,"id":"22374","alias":"data_engineering","type":"collective","title":"Data Engineering","titleHtml":"Data Engineering","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"6","alias":"admin","title":"Администрирование"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EВ \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Ffuncorp\u002Fblog\u002F576658\u002F\"\u003E\u003Cu\u003Eпрошлой статье\u003C\u002Fu\u003E\u003C\u002Fa\u003E мы научились классифицировать данные без разметки с помощью понижения размерности и методов кластеризации. По итогам получили первичную разметку данных и узнали, что это картинки. С такими начальными условиями можно придумать что-то более серьёзное, например, дообучить существующую нейросеть на наши классы, даже если до этого она их никогда не видела. В iFunny на первом уровне модерации мы выделяем три основных класса:&nbsp;\u003C\u002Fp\u003E\u003Cp\u003E• approved — картинки идут в раздел collective (развлекательный контент и мемы);\u003Cbr\u003E• not suitable — не попадают в общую ленту, но остаются в ленте пользователя (селфи, пейзажи и другие);\u003Cbr\u003E• risked — получают бан и удаляются из приложения (расизм, порнография, расчленёнка и всё, что попадает под определение «противоправный контент»).\u003C\u002Fp\u003E\u003Cp\u003EСегодня расскажу на наглядных примерах, как мы перестраивали модель под наши классы, обучали её и выделяли паттерны распознавания картинок. Технические подробности — под катом.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F3d9\u002F2b4\u002F678\u002F3d92b46781695b6ccf2e69c5b4b4fe3c.jpg","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F3d9\u002F2b4\u002F678\u002F3d92b46781695b6ccf2e69c5b4b4fe3c.jpg","fit":"cover","positionY":0,"positionX":0}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"обработка данных"},{"titleHtml":"машинное обучение"},{"titleHtml":"python"},{"titleHtml":"machine learning"},{"titleHtml":"data engineering"},{"titleHtml":"классификация изображений"},{"titleHtml":"нейросети"},{"titleHtml":"классификатор данных"},{"titleHtml":"data science"}]},"580468":{"id":"580468","timePublished":"2021-09-28T12:04:47+00:00","isCorporative":true,"lang":"ru","titleHtml":"Проект «Горирожа»: про двойной подбородок","editorVersion":"1.0","postType":"article","postLabels":[],"author":{"id":"1588913","alias":"elena_pastukhova","fullname":"Елена Пастухова","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F1dc\u002F879\u002Fc33\u002F1dc879c33e39127162333771dba2137a.jpg","speciality":"Пользователь"},"statistics":{"commentsCount":31,"favoritesCount":30,"readingCount":6977,"score":24,"votesCount":62},"hubs":[{"relatedData":null,"id":"21848","alias":"geltek","type":"corporative","title":"Блог компании Гельтек-Медика","titleHtml":"Блог компании Гельтек-Медика","isProfiled":false},{"relatedData":null,"id":"21910","alias":"popular_science","type":"collective","title":"Научно-популярное","titleHtml":"Научно-популярное","isProfiled":false},{"relatedData":null,"id":"21996","alias":"health","type":"collective","title":"Здоровье","titleHtml":"Здоровье","isProfiled":false}],"flows":[{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"leadData":{"textHtml":"Борода у мужчин — это самый действенный способ скрыть жир. \u003Cbr\u003E\r\n\u003Cbr\u003E\r\nЕсть люди, которым повезло с квадратной челюстью: тогда всё прямо натянуто, и когда у обычного человека уже был бы тройной подбородок, у них — только двойной. Но если у вас славянский тип лица, то это не про вас. У нас прекрасный профиль, но в профиль будет видно даже минимальное количество жира. У азиатского типа — высокие скулы, которые тянут жир в другую сторону, а у нас нет никаких подобных генетических конструкций, поэтому при деформационном типе старения всё это ползёт вниз. Формируется либо второй подбородок, либо жировой компартмент располагается на щеках, и появляются так называемые «бульдожьи щёки». \u003Cbr\u003E\r\n\u003Cbr\u003E\r\nПоскольку жир там точно такой же, как на пузе и боках у мальчиков и на попе у девочек, то бороться с ним можно дефицитом калорий и физической нагрузкой. Ещё можно уменьшить склонность к отёчности и поднять тонус кожи через увлажнение. \u003Cbr\u003E\r\n\u003Cbr\u003E\r\nСюрпризом стало то, что испытуемые из тестовой группы проекта Thermo Intensive (более известного вам как «\u003Ca href=\"https:\u002F\u002Fgeltek-medica.ru\u002Fcatalog\u002Fkosmetika\u002Fseriya-body-care\u002Fanticellyulitnyj-gel-thermo-intensive\u002F\u002F\" rel=\"nofollow noopener noreferrer\"\u003EГорижопа\u003C\u002Fa\u003E» ) начали мазать средство не в целевую область, а ещё и на лицо, рассчитывая, что жир там будет убираться так же быстро. Мы сразу запретили им это делать (потому что щитовидка рядом, а мажут они широко) и сразу задумались про новое средство. \u003Cbr\u003E\r\n \u003Cbr\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fbk\u002Fsd\u002Ffy\u002Fbksdfyfl8jwg3mvvmrjs4xzibz4.png\" alt=\"image\"\u003E\u003Cbr\u003E\r\n\u003Ci\u003EПервая стадия, когда борода ещё не особо нужна. \u003Ca href=\"https:\u002F\u002Fmelmagazine.com\u002Fwp-content\u002Fuploads\u002F2018\u002F08\u002F1SmLNcqJD9Ao7TSeV1MwobA.png\" rel=\"nofollow noopener noreferrer\"\u003EИсточник\u003C\u002Fa\u003E\u003C\u002Fi\u003E\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nПотому что бета-тестеры обозначили нам рыночную нишу. \u003Cbr\u003E\r\n\u003Cbr\u003E\r\nСобственно, вы его тогда спрашивали и в комментариях, сразу раскусив, как можно неправильно использовать состав. И вот теперь у меня есть что показать.","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"горирожа"},{"titleHtml":"второй подбородок"},{"titleHtml":"жир"},{"titleHtml":"артикулярная гимнастика"},{"titleHtml":"средство"},{"titleHtml":"гель"}]},"580476":{"id":"580476","timePublished":"2021-09-28T12:24:47+00:00","isCorporative":true,"lang":"ru","titleHtml":"Технологии спасают планету","editorVersion":"2.0","postType":"article","postLabels":[],"author":{"id":"935654","alias":"mvideo","fullname":"М.Видео-Эльдорадо","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fbcf\u002F338\u002F8e9\u002Fbcf3388e983673974b2ad11ce87d1b98.png","speciality":"Розничная компания №1 с технологией OneRetail"},"statistics":{"commentsCount":5,"favoritesCount":8,"readingCount":1013,"score":10,"votesCount":12},"hubs":[{"relatedData":null,"id":"21218","alias":"mvideo","type":"corporative","title":"Блог компании М.Видео-Эльдорадо","titleHtml":"Блог компании М.Видео-Эльдорадо","isProfiled":false},{"relatedData":null,"id":"20742","alias":"read","type":"collective","title":"Читальный зал","titleHtml":"Читальный зал","isProfiled":false},{"relatedData":null,"id":"22012","alias":"Ecology","type":"collective","title":"Экология","titleHtml":"Экология","isProfiled":false}],"flows":[{"id":"3","alias":"management","title":"Менеджмент"},{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EСегодня все чаще вспоминают об экологии. Зеленые технологии, альтернативные источники энергии, осознанное потребление и так далее. Но давайте же посмотрим на примеры того, какие технологии и идеи помогают делать нашу планету реально чище и безопасней.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fbdd\u002Fd49\u002Fe92\u002Fbddd49e92d2f43864a817f77025b5d44.jpg","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fbdd\u002Fd49\u002Fe92\u002Fbddd49e92d2f43864a817f77025b5d44.jpg","fit":"cover","positionY":0,"positionX":0}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"Эльдорадо"},{"titleHtml":"Экодрон"},{"titleHtml":"Экозон"},{"titleHtml":"Хакатон"},{"titleHtml":"м.видео"},{"titleHtml":"м.каталог"}]},"580500":{"id":"580500","timePublished":"2021-09-28T13:43:38+00:00","isCorporative":false,"lang":"ru","titleHtml":"Поколение, выросшее вместе с Google, заставляет учителей менять структуру преподавания","editorVersion":"1.0","postType":"article","postLabels":[{"type":"translation","data":{"originalAuthorName":"Monica Chin","originalUrl":"https:\u002F\u002Fwww.theverge.com\u002F22684730\u002Fstudents-file-folder-directory-structure-education-gen-z"}}],"author":{"id":"60351","alias":"SLY_G","fullname":"Вячеслав Голованов","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F329\u002Ffc8\u002F9e5\u002F329fc89e55a9132bf200ff315065f3f7.jpg","speciality":"Научпоп. Проповедую в храме науки."},"statistics":{"commentsCount":99,"favoritesCount":36,"readingCount":12295,"score":17,"votesCount":27},"hubs":[{"relatedData":null,"id":"20696","alias":"study","type":"collective","title":"Учебный процесс в IT","titleHtml":"Учебный процесс в IT","isProfiled":false},{"relatedData":null,"id":"21906","alias":"history","type":"collective","title":"История IT","titleHtml":"История IT","isProfiled":false}],"flows":[{"id":"3","alias":"management","title":"Менеджмент"},{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"leadData":{"textHtml":"\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F357\u002F1b9\u002F4ee\u002F3571b94eea301ce372e5b22d5d882b80.webp\"\u003E\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nАстрофизик Кэтрин Гарланд впервые столкнулась с этой проблемой в 2017-м. Она преподавала инженерное дело, а её ученики использовали симуляторы для моделирования турбин реактивных самолётов. Она чётко сформулировала задачу, но один за другим студенты просили её помочь им. Все они получали одно и тоже сообщение об ошибке: программа не могла найти файлы.\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nГарланд думала, что это легко исправить. Она спрашивала каждого из этих учеников, где они сохранили свой проект. На рабочем столе? На общем диске? Но каждый раз её встречало непонимание. «О чём вы говорите?» – недоумевали студенты. Они не только не знали, где сохранили свои файлы – они просто не понимали вопроса.\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nПостепенно Гарланд начала понимать то, к чему её коллеги-преподаватели приходили в последние четыре года. Концепция папок, директорий, файлов, необходимая предыдущему поколению пользователей для понимания работы компьютера, современным ученикам кажется тарабарщиной.\u003Cbr\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"файлы"},{"titleHtml":"каталоги"},{"titleHtml":"папки"},{"titleHtml":"директории"},{"titleHtml":"компьютерная грамотность"}]},"580516":{"id":"580516","timePublished":"2021-09-28T14:25:12+00:00","isCorporative":false,"lang":"ru","titleHtml":"Лучший язык программирования","editorVersion":"2.0","postType":"article","postLabels":[],"author":{"id":"8114","alias":"markshevchenko","fullname":"Марк Шевченко","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fb16\u002F6c1\u002Fc82\u002Fb166c1c82387bf9406fcd39f40dc264e.jpg","speciality":"программист"},"statistics":{"commentsCount":86,"favoritesCount":165,"readingCount":34844,"score":151,"votesCount":161},"hubs":[{"relatedData":null,"id":"359","alias":"programming","type":"collective","title":"Программирование","titleHtml":"Программирование","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EВопрос, который часто задают начинающие программисты&nbsp;— какой язык программирования изучать? Вопрос звучит разумно. Хочется выбрать самый лучший, чтобы потом не пришлось переучиваться.\u003C\u002Fp\u003E\u003Cp\u003EМожно ли на него ответить?\u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать далее","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"образование"},{"titleHtml":"языки программирования"}]},"580520":{"id":"580520","timePublished":"2021-09-28T14:46:39+00:00","isCorporative":false,"lang":"ru","titleHtml":"Сборка Linux и CPSS на отладке Marvell RD-AC3X-48G4X2XL-A с Ethernet-коммутатором Prestera DX","editorVersion":"2.0","postType":"article","postLabels":[{"type":"tutorial","data":null}],"author":{"id":"57711","alias":"Promwad","fullname":"Команда компании Promwad","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fe4b\u002Fdc5\u002Fd7a\u002Fe4bdc5d7ac683edcb2a87e974ab1d291.png","speciality":"Разработка и производство электронных устройств"},"statistics":{"commentsCount":0,"favoritesCount":8,"readingCount":953,"score":11,"votesCount":11},"hubs":[{"relatedData":null,"id":"144","alias":"open_source","type":"collective","title":"Open source","titleHtml":"Open source","isProfiled":true},{"relatedData":null,"id":"17123","alias":"network_technologies","type":"collective","title":"Сетевые технологии","titleHtml":"Сетевые технологии","isProfiled":true},{"relatedData":null,"id":"17720","alias":"lua","type":"collective","title":"Lua","titleHtml":"Lua","isProfiled":true},{"relatedData":null,"id":"19727","alias":"linux_dev","type":"collective","title":"Разработка под Linux","titleHtml":"Разработка под Linux","isProfiled":true},{"relatedData":null,"id":"21484","alias":"electronics","type":"collective","title":"Производство и разработка электроники","titleHtml":"Производство и разработка электроники","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"6","alias":"admin","title":"Администрирование"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EМы подготовили статью-гайд для пошаговой сборки и запуска базовой прошивки с CPSS на отладочной плате Marvell RD-AC3X-48G4X2XL-A. Эта плата предназначена для проектирования и отладки управляемых коммутаторов до 48 портов. Чем она примечательна для инженера-разработчика? У нее на борту установлен коммутатор Marvell Prestera DX 98DX3257 с мощной СнК семейства Prestera. А Ethernet-коммутаторы Prestera DX позволяют реализовать 5G при самой низкой в отрасли мощности и занимаемой площади.&nbsp;\u003C\u002Fp\u003E\u003Cp\u003EА что касается CPSS, то это базовый программный уровень для железа Marvell Prestera или, другими словами, Core Prestera Software Suite. CPSS используется в проекте Open Compute Project как часть открытой операционной системы SONiC. Эта операционка расширяет функции центра обработки данных в сложных системах, например, в системах интеллектуального хранения данных и машинного обучения. \u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fa2b\u002F295\u002F428\u002Fa2b295428058f0f24634dcaa3c2b89f1.jpg","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fa2b\u002F295\u002F428\u002Fa2b295428058f0f24634dcaa3c2b89f1.jpg","fit":"cover","positionY":0,"positionX":0}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"open compute project"},{"titleHtml":"promwad"},{"titleHtml":"marvell"},{"titleHtml":"Prestera DX"},{"titleHtml":"коммутаторы"},{"titleHtml":"CPSS"},{"titleHtml":"sonic"},{"titleHtml":"l2"},{"titleHtml":"capwap"},{"titleHtml":"cnc"}]},"580534":{"id":"580534","timePublished":"2021-09-28T16:33:56+00:00","isCorporative":false,"lang":"ru","titleHtml":"Виниловый проигрыватель своими руками","editorVersion":"2.0","postType":"article","postLabels":[{"type":"sandbox","data":null}],"author":{"id":"365505","alias":"Gromushka","fullname":null,"avatarUrl":"","speciality":""},"statistics":{"commentsCount":59,"favoritesCount":19,"readingCount":6330,"score":13,"votesCount":21},"hubs":[{"relatedData":null,"id":"21976","alias":"DIY","type":"collective","title":"DIY или Сделай сам","titleHtml":"DIY или Сделай сам","isProfiled":false},{"relatedData":null,"id":"21988","alias":"sound","type":"collective","title":"Звук","titleHtml":"Звук","isProfiled":false}],"flows":[{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EДля многих старый звук с пластинок - это ностальгия. Кому-то нравится просто вид вращающегося диска, другим нравится пощелкивание и поскрипывание в процессе проигрывания. \u003C\u002Fp\u003E\u003Cp\u003EСовременные пластмассовые балалайки - не выдерживают критики, редкие модели можно использовать действительно для извлечения звука, а не стонов. Более интересные модели - слишком дороги, а винтаж стар и требует внимания, кроме того, не каждый винтаж хорош, а действительно интересные предложения совсем не дешевые. \u003C\u002Fp\u003E\u003Cp\u003EА вот сделать самому, используя не сильно большой бюджет - вертушку с хорошими возможностями и всеми необходимыми функциями - это интересно. \u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2a1\u002F9a0\u002F730\u002F2a19a073018436be3f5821b68c8cbe9f.jpg","fit":"cover","positionY":0,"positionX":0}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"винил"},{"titleHtml":"аудио"},{"titleHtml":"винтаж"},{"titleHtml":"звук"},{"titleHtml":"сделай сам"},{"titleHtml":"проигрыватель винила"},{"titleHtml":"проигрыватель пластинок"}]},"580572":{"id":"580572","timePublished":"2021-09-29T03:42:38+00:00","isCorporative":false,"lang":"ru","titleHtml":"Байконур, часть 4: МИК «Протонов»","editorVersion":"2.0","postType":"article","postLabels":[],"author":{"id":"368687","alias":"lozga","fullname":"Филипп Терехов","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F817\u002F6fa\u002Fd6b\u002F8176fad6ba9b8839f4372de9d0187146.png","speciality":"Тестировщик и популяризатор космонавтики"},"statistics":{"commentsCount":0,"favoritesCount":2,"readingCount":3256,"score":13,"votesCount":13},"hubs":[{"relatedData":null,"id":"21910","alias":"popular_science","type":"collective","title":"Научно-популярное","titleHtml":"Научно-популярное","isProfiled":false},{"relatedData":null,"id":"21962","alias":"space","type":"collective","title":"Космонавтика","titleHtml":"Космонавтика","isProfiled":false}],"flows":[{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EУже после того, как модуль \"Наука\" отправился на старт, мы получили возможность зайти в монтажно-испытательный комплекс (МИК), где его устанавливали на ракету-носитель. Нам несколько раз говорили, что мы стали первыми посторонними посетителями этого МИКа. И по количеству просьб не снимать эта локация заняла первое место со значительным отрывом.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F707\u002Fc87\u002Fa1c\u002F707c87a1cd773efcc1e03242fdd40502.jpg","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F707\u002Fc87\u002Fa1c\u002F707c87a1cd773efcc1e03242fdd40502.jpg","fit":"cover","positionY":0,"positionX":0}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"Космодром Байконур"},{"titleHtml":"ракеты-носители"},{"titleHtml":"ракета &quot;Протон&quot;"},{"titleHtml":"репортаж"},{"titleHtml":"экскурсия"}]},"580582":{"id":"580582","timePublished":"2021-09-29T06:19:53+00:00","isCorporative":false,"lang":"ru","titleHtml":"Конфиденциальность пользователей Telegram снова нарушена. Представители мессенджера требуют не раскрывать подробностей","editorVersion":"2.0","postType":"article","postLabels":[],"author":{"id":"1800409","alias":"ne555","fullname":null,"avatarUrl":"","speciality":""},"statistics":{"commentsCount":59,"favoritesCount":17,"readingCount":22104,"score":148,"votesCount":154},"hubs":[{"relatedData":null,"id":"50","alias":"infosecurity","type":"collective","title":"Информационная безопасность","titleHtml":"Информационная безопасность","isProfiled":true},{"relatedData":null,"id":"92","alias":"instant_messaging","type":"collective","title":"Мессенджеры","titleHtml":"Мессенджеры","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EВ конце февраля 2021 года выходит обновленный релиз клиента Telegram с заголовком: ‘\u003Cem\u003EАвтоудаление, виджеты и временные ссылки для приглашений’.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cp\u003EНа красивой, художественной \u003Ca href=\"https:\u002F\u002Ftelegram.org\u002Ffile\u002F464001519\u002F2\u002Fpw2YpXpzBFk.222382\u002F9ec672b0125c50ad34\" rel=\"noopener noreferrer nofollow\"\u003Eобложке\u003C\u002Fa\u003E к пресс-релизу новой верси Tg-мессенджера пользователи видят корзину с таймером и уничтоженными данными, а так же лицезреют главных героев из культового хакерского сериала \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%9C%D0%B8%D1%81%D1%82%D0%B5%D1%80_%D0%A0%D0%BE%D0%B1%D0%BE%D1%82#%D0%9D%D0%B0%D0%B3%D1%80%D0%B0%D0%B4%D1%8B_%D0%B8_%D0%BD%D0%BE%D0%BC%D0%B8%D0%BD%D0%B0%D1%86%D0%B8%D0%B8\" rel=\"noopener noreferrer nofollow\"\u003EМистер Робот\u003C\u002Fa\u003E. Но действительно ли все так круто с зачисткой следов как и в сериале? Подробности об одной щекотливой bug bounty в этой статье.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F1e9\u002F2a3\u002F6cc\u002F1e92a36cc8aeb8ec3f80bd8c3dd26b44.jpeg","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F1e9\u002F2a3\u002F6cc\u002F1e92a36cc8aeb8ec3f80bd8c3dd26b44.jpeg","fit":"cover","positionY":0,"positionX":0}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"telegram"},{"titleHtml":"уязвимость"}]},"580588":{"id":"580588","timePublished":"2021-09-29T07:57:53+00:00","isCorporative":true,"lang":"ru","titleHtml":"Техподдержка без бюрократии: автоматизации под капотом ServiceDesk Яндекса","editorVersion":"1.0","postType":"article","postLabels":[],"author":{"id":"2792513","alias":"arvidasgafiulin","fullname":"Арвидас Гафиулин","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F463\u002Fe51\u002Ff5d\u002F463e51f5d7d8eaf0704e3db17fdee1e5.jpg","speciality":"Руководитель отдела эксплуатации и развития"},"statistics":{"commentsCount":3,"favoritesCount":8,"readingCount":1067,"score":14,"votesCount":14},"hubs":[{"relatedData":null,"id":"4991","alias":"yandex","type":"corporative","title":"Блог компании Яндекс","titleHtml":"Блог компании Яндекс","isProfiled":false},{"relatedData":null,"id":"17739","alias":"crm","type":"collective","title":"CRM-системы","titleHtml":"CRM-системы","isProfiled":true},{"relatedData":null,"id":"19369","alias":"service_desk","type":"collective","title":"Service Desk","titleHtml":"Service Desk","isProfiled":true},{"relatedData":null,"id":"21904","alias":"office","type":"collective","title":"Офисы IT-компаний","titleHtml":"Офисы IT-компаний","isProfiled":false},{"relatedData":null,"id":"22026","alias":"itcompanies","type":"collective","title":"IT-компании","titleHtml":"IT-компании","isProfiled":false}],"flows":[{"id":"3","alias":"management","title":"Менеджмент"},{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"leadData":{"textHtml":"Привет! Меня зовут Арвидас Гафиулин, я руководитель отдела эксплуатации и развития ИТ-инфраструктуры в Яндексе. Важнейшее направление работы отдела — наша внутренняя служба поддержки, ServiceDesk. Именно команда SD отвечает за то, чтобы у сотрудников компании была возможность работать из офиса или на удалёнке со всеми необходимыми доступами, оборудованием и комфортом. В среднем служба получает 10 тысяч запросов каждую неделю и постоянно работает над тем, чтобы решать их качественнее и быстрее, а также предотвращать новые инциденты, устраняя корни проблем. \u003Cbr\u003E\r\n\u003Cbr\u003E\r\nМы уже писали на Хабр о том, как работает \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fyandex\u002Fblog\u002F487078\u002F\"\u003Eвендомат ServiceDesk\u003C\u002Fa\u003E, выдающий расходники и компьютерные аксессуары без согласований и бумажек, а сегодня расскажем, как выглядит работа службы изнутри и какие технические решения живут у ServiceDesk «под капотом», помогая нам автоматизировать львиную долю задач. Добро пожаловать под кат, если вам интересно, откуда техподдержка знает, кому уже пора апгрейдить технику, а кому придётся ещё немного подождать, у кого устарела версия ОС или доживает последние дни жёсткий диск, какие автоматизации мы можем создавать на основе пользовательских данных, а главное — от скольких часов ожидания и кругов согласований это избавляет сотрудников Яндекса.\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fao\u002Fg-\u002Fgv\u002Faog-gvbfx0gynbv_nderxmcmooi.jpeg\"\u003E\u003Cbr\u003E\r\n\u003Csup\u003EWelcome-зона службы ИТ-поддержки в одном из офисов\u003C\u002Fsup\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"служба поддержки"},{"titleHtml":"service desk"},{"titleHtml":"автоматизация"},{"titleHtml":"data lake"},{"titleHtml":"crm"},{"titleHtml":"api"}]},"580604":{"id":"580604","timePublished":"2021-09-29T08:11:26+00:00","isCorporative":false,"lang":"ru","titleHtml":"Поговорим о высшем образовании, требованиях и ожиданиях","editorVersion":"2.0","postType":"article","postLabels":[],"author":{"id":"56016","alias":"onlinehead","fullname":"Anton Kostenko","avatarUrl":"","speciality":"DevOps\u002FSRE"},"statistics":{"commentsCount":13,"favoritesCount":10,"readingCount":2044,"score":12,"votesCount":16},"hubs":[{"relatedData":null,"id":"20696","alias":"study","type":"collective","title":"Учебный процесс в IT","titleHtml":"Учебный процесс в IT","isProfiled":false},{"relatedData":null,"id":"20740","alias":"career","type":"collective","title":"Карьера в IT-индустрии","titleHtml":"Карьера в IT-индустрии","isProfiled":false}],"flows":[{"id":"3","alias":"management","title":"Менеджмент"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EОчень много комментариев собрал \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F579998\u002Fhttps:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F579998\u002F\" rel=\"noopener noreferrer nofollow\"\u003Eпост\u003C\u002Fa\u003E молодого человека, первокурсника, пришедшего учиться на \"программиста\", но получившего несколько не то, что он ожидал. Я сам 15 лет назад поступил в региональный университет на \"айтишную\" специальность и мне это близко. \u003C\u002Fp\u003E\u003Cp\u003EКак это обычно и бывает для постов, поднявших весьма больную тему, комментарии оказались как бы не интереснее самого поста. \u003C\u002Fp\u003E\u003Cp\u003EВ них эдаким лейтмотивом проходит несколько мыслей, которые я бы и хотел выделить, обсудить и в некотором роде постараться опровергнуть или, как минимум, поставить под сомнение.\u003C\u002Fp\u003E\u003Cp\u003EЯ заранее извиняюсь у авторов комментариев за то, что не буду упоминать их ники. Одна и та же мысль могла быть высказана десятки раз в разных формах и я не вижу никакой разумной возможности найти и упомянуть их всех, поэтому ограничусь или переформулированной идеей, или небольшой прямой цитатой там, где это совершенно необходимо.\u003C\u002Fp\u003E\u003Cp\u003EАналогично, я оговорюсь, что в некоторых ВУЗах все может быть по-другому. Частные случаи хорошо подсвечивают проблему, но никак не отменяют её наличия.\u003C\u002Fp\u003E\u003Cp\u003EКроме этого, я бы не хотел рассуждать о причинах проблем и\\или предлагать какие-либо способы решения. Но, конечно же, это всегда можно обсудить в комментариях.\u003C\u002Fp\u003E\u003Cp\u003EИтак, примем к рассмотрению следующие тезисы, которые достаточно массово высказывались в комментариях:\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F3a1\u002Fe0c\u002F854\u002F3a1e0c854b5d502922bcbb9528301fc1.jpg","buttonTextHtml":"Три тезиса, о которых мы поговорим","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F3a1\u002Fe0c\u002F854\u002F3a1e0c854b5d502922bcbb9528301fc1.jpg","fit":"cover","positionY":89.772727272727,"positionX":0}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"высшее образование"},{"titleHtml":"проблемы образования"},{"titleHtml":"проблемы профессии it"},{"titleHtml":"образование в ит"},{"titleHtml":"образование в it"},{"titleHtml":"образование"},{"titleHtml":"государство"},{"titleHtml":"государственные учереждения"}]}},"articlesIds":{"ARTICLES_LIST_TOP_PERIOD_DAILY":["580516","580582","580034","579530","580392","578788","580222","580468","578690","580500","580588","580572","579960","580534","580604","579626","580118","580520","580296","580476"]},"isLoading":false,"pagesCount":{"ARTICLES_LIST_TOP_PERIOD_DAILY":3},"route":{"name":"ARTICLES_LIST_TOP_PERIOD","params":{"period":"daily"},"query":{}},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":["534516","513050","507908"],"similarListRefs":{"507908":{"id":"507908","timePublished":"2020-06-23T13:12:15+00:00","isCorporative":true,"lang":"ru","titleHtml":"Управление несколькими JDK в Mac OS, Linux и Windows WSL2","editorVersion":"1.0","postType":"article","postLabels":[{"type":"translation","data":{"originalAuthorName":"Bruno Borges","originalUrl":"https:\u002F\u002Fmedium.com\u002F@brunoborges\u002Fmanage-multiple-jdks-on-mac-os-linux-and-windows-wsl2-3a73467b685c"}}],"author":{"id":"1547287","alias":"MaxRokatansky","fullname":"OTUS","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fb9f\u002Fbaf\u002F5f9\u002Fb9fbaf5f96ae52973706a0716bd9216e.jpg","speciality":"Редактор"},"statistics":{"commentsCount":6,"favoritesCount":41,"readingCount":5014,"score":12,"votesCount":16},"hubs":[{"id":"21052","alias":"otus","type":"corporative","title":"Блог компании OTUS","titleHtml":"Блог компании OTUS","isProfiled":false},{"id":"359","alias":"programming","type":"collective","title":"Программирование","titleHtml":"Программирование","isProfiled":true},{"id":"375","alias":"java","type":"collective","title":"Java","titleHtml":"Java","isProfiled":true},{"id":"19253","alias":"osx_dev","type":"collective","title":"Разработка под MacOS","titleHtml":"Разработка под MacOS","isProfiled":true},{"id":"19727","alias":"linux_dev","type":"collective","title":"Разработка под Linux","titleHtml":"Разработка под Linux","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка","titleHtml":"Разработка"}],"relatedData":null,"leadData":{"textHtml":"\u003Ci\u003E\u003Cb\u003EИ снова здравствуйте. В преддверии старта курса \u003Ca href=\"https:\u002F\u002Fotus.pw\u002Fwr0F\u002F\" rel=\"nofollow\"\u003E«Разработчик Java»\u003C\u002Fa\u003E подготовили для вас перевод интересной статьи.\u003C\u002Fb\u003E\u003C\u002Fi\u003E\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fai\u002Fsn\u002Fq-\u002Faisnq-g_10timdpcukmlvkrdhk8.png\"\u003E\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Chr\u003E\u003Cbr\u003E\r\nЕсли вам, как и мне, приходится одновременно работать с несколькими проектами (как с легаси, так и с современными), а возможно, вы разрабатываете какую-то библиотеку или утилиту для пользователей с разными версиями Java, то вы поймете проблему с переключением между разными JDK.\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F79\u002Fz0\u002Fb9\u002F79z0b9cqo9__29r_zf8lwmu4t80.jpeg\"\u003E\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nВ наши дни установка, управление и переключение между JDK при разработке становится непростой задачей, потому что большое количество разработчиков все еще работает с Java 8, хотя многие уже переходят на Java 11. Эта проблема может быть решена разными способами. В этой статье мы рассмотрим некоторые из них.","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"status":"published","plannedPublishTime":null,"checked":null},"513050":{"id":"513050","timePublished":"2020-07-29T18:10:41+00:00","isCorporative":false,"lang":"ru","titleHtml":"Разработчик создал из Mac OS 8 приложение для современных ПК на macOS, Windows и Linux","editorVersion":"1.0","postType":"news","postLabels":[],"author":{"id":"780987","alias":"denis-19","fullname":"Денис","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F6a0\u002Ff31\u002F235\u002F6a0f31235bb26134f3c7a741c03e4efb.jpg","speciality":"Инженер, редакция Хабра"},"statistics":{"commentsCount":12,"favoritesCount":20,"readingCount":14282,"score":24,"votesCount":32},"hubs":[{"id":"357","alias":"javascript","type":"collective","title":"JavaScript","titleHtml":"JavaScript","isProfiled":true},{"id":"18790","alias":"github","type":"collective","title":"GitHub","titleHtml":"GitHub","isProfiled":false},{"id":"21906","alias":"history","type":"collective","title":"История IT","titleHtml":"История IT","isProfiled":false},{"id":"21980","alias":"games","type":"collective","title":"Игры и игровые приставки","titleHtml":"Игры и игровые приставки","isProfiled":false}],"flows":[{"id":"1","alias":"develop","title":"Разработка","titleHtml":"Разработка"},{"id":"7","alias":"popsci","title":"Научпоп","titleHtml":"Научпоп"}],"relatedData":null,"leadData":{"textHtml":"\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fel\u002Fxf\u002Fzg\u002Felxfzgffyrjfu-8qtnam1zjzpdc.jpeg\"\u003E\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nРазработчик из компании Slack Феликс Ризеберг (Felix Rieseberg) портировал Mac OS 8.1 с Macintosh Quadra 1991 года с процессором Motorola на современную компьютерную архитектуру с помощью JavaScript. Этот проект он назвал macintosh.js и \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ffelixrieseberg\u002Fmacintosh.js\" rel=\"nofollow\"\u003Eопубликовал\u003C\u002Fa\u003E на GitHub для всех энтузиастов и ценителей IT-истории, чтобы они могли просто поностальгировать.\u003Cbr\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"status":"published","plannedPublishTime":null,"checked":null},"534516":{"id":"534516","timePublished":"2020-12-22T19:57:04+00:00","isCorporative":false,"lang":"ru","titleHtml":"Создание загрузочной флешки c HirensBootCD в mac os","editorVersion":"1.0","postType":"article","postLabels":[{"type":"sandbox","data":null}],"author":{"id":"1856061","alias":"soda55","fullname":null,"avatarUrl":null,"speciality":null},"statistics":{"commentsCount":3,"favoritesCount":18,"readingCount":3052,"score":5,"votesCount":7},"hubs":[{"id":"221","alias":"sys_admin","type":"collective","title":"Системное администрирование","titleHtml":"Системное администрирование","isProfiled":true}],"flows":[{"id":"6","alias":"admin","title":"Администрирование","titleHtml":"Администрирование"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EПредисловие: в моем случае нужен был загрузочный usb накопитель c &quot;HirensBootCD&quot;, но потратил день я так и не нашел нормальной статьи как его сделать из под mac os, а также все они были основаны на установки образа с помощью &quot;Unetbootin и Eather&quot;.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ итоге все заканчивается тем что usb накопитель не грузится. Почему так ?\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВозьмем &quot;Unetbootin&quot; он просто напросто не создает загрузочную область на usb накопителе по крайне мере в mac os, а &quot;Eather&quot; не умеет создавать загрузочную область если ее нет изначально в образе iso, но зато установочные образы live linux подобные успешно грузятся.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ так начнем.\u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"status":"published","plannedPublishTime":null,"checked":null}}},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{"shoumikhin":{"scoreStats":{"score":20.7,"votesCount":271},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"59212","alias":"shoumikhin","fullname":"Anthony Shoumikhin","avatarUrl":null,"speciality":"Software Engineer"}},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.670ab961.js" defer></script><script src="https://assets.habr.com/habr-web/js/chunk-f458c7c4.6e221df6.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.76acc47b.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
