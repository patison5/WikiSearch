<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Три парадигмы F# / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.0f7bdd8f.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.670ab961.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.01bb2993.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.76acc47b.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-f458c7c4.e48e8f79.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-f458c7c4.6e221df6.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.0f7bdd8f.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.01bb2993.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-f458c7c4.e48e8f79.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.4f7c12b4e1b1b4c0e44ef6f9f33b1f9f.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/55272\/"},"headline":"Три парадигмы F#","datePublished":"2009-03-23T18:00:50+03:00","dateModified":"2018-02-12T15:34:58+03:00","author":{"@type":"Person","name":"Дмитрий Ейбоженко"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Введение Все, кто так или иначе связан с .NET программированием знает, что уже в следующую версию Visual Studio будет встроен новый язык программирования &mdash; F#, к...","url":"https:\/\/habr.com\/ru\/post\/55272\/#post-content-body","about":["h_programming","h_fsharp","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/55272\/22d5b53406eed729bca715f8054ef09c\/"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.47.1">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Три парадигмы F#" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Три парадигмы F#" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Три парадигмы F#" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Введение
Все, кто так или иначе связан с .NET программированием знает, что уже в следующую версию Visual Studio будет встроен новый язык программирования — F#, который позиционируется как..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Введение
Все, кто так или иначе связан с .NET программированием знает, что уже в следующую версию Visual Studio будет встроен новый язык программирования — F#, который позиционируется как..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Введение
Все, кто так или иначе связан с .NET программированием знает, что уже в следующую версию Visual Studio будет встроен новый язык программирования — F#, который позиционируется как..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Введение
Все, кто так или иначе связан с .NET программированием знает, что уже в следующую версию Visual Studio будет встроен новый язык программирования — F#, который позиционируется как..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Введение
Все, кто так или иначе связан с .NET программированием знает, что уже в следующую версию Visual Studio будет встроен новый язык программирования — F#, который позиционируется как..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/55272/22d5b53406eed729bca715f8054ef09c/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/55272/22d5b53406eed729bca715f8054ef09c/" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/55272/22d5b53406eed729bca715f8054ef09c/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/55272/22d5b53406eed729bca715f8054ef09c/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/55272/22d5b53406eed729bca715f8054ef09c/" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="55272" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2009-03-23T15:00:50.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/55272/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/55272/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/55272/22d5b53406eed729bca715f8054ef09c/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.cee85629.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
              Как стать автором
            </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.cee85629.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.cee85629.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.cee85629.svg#pull-arrow"></use></svg></div></div> <!----> <div class="tm-page-article__body"><article class="tm-page-article__content tm-page-article__content_inner"><div class="tm-page-article__head-wrapper"><!----> <div class="tm-article-snippet tm-page-article__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/Meroving/" title="Meroving" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/fec/c12/fb5/fecc12fb5c667b1fa4aac44040d7f2c9.jpg" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/Meroving/" class="tm-user-info__username">
      Meroving
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2009-03-23T15:00:50.000Z" title="2009-03-23, 18:00">23  марта  2009 в 18:00</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Три парадигмы F#</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/programming/" class="tm-article-snippet__hubs-item-link"><span>Программирование</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/fsharp/" class="tm-article-snippet__hubs-item-link"><span>F#</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <!----> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><h2>Введение</h2><br/>
Все, кто так или иначе связан с .NET программированием знает, что уже в следующую версию Visual Studio будет встроен новый язык программирования — F#, который позиционируется как функциональный, чем сразу, так уж повелось, вызывает подозрения в бесполезности. Для того, чтобы показать, что F# — куда больше, чем просто ФЯП (хотя и просто ФЯП — это очень немало), я и написал все нижеследующее.<br/>
Эта статья, несмотря на изрядную длину, не претендует на то, чтобы полностью описать всю функциональность языка. Это всего лишь краткий обзор, призванный продемонстрировать широкий спектр возможностей, каждая из которых заслуживает отдельной статьи, и даже не одной. <br/>
Кроме того, написав такой пространный пост, я хотел сделать задел на будущее, чтобы в дальнейшем мне не отвлекаться на незначительные вещи базового уровня. Конечно, сразу головой в пруд — это действенно, но и какой-никакой фундамент не помешает. <br/>
А уже в следующий раз я приведу пример на волнующую тему пригодности F# для обычной профессиональной программистской деятельности.<br/>
И еще раз, под катом действительно МНОГО текста. И не говорите потом, что я вас не предупреждал. =)<br/>
<a name="habracut"></a><br/>
<h2>F# функциональный</h2><br/>
Конечно, в первую очередь F# — функциональный язык, а значит именно поддержка функциональной парадигмы в нем реализована наиболее полно. Как известно, много ключевых слов и литералов в нем заимствовано из OCaml, что неудивительно, так как Дон Сайм (Don Syme), главный создатель F# когда-то приложил руку и к OCaml. <br/>
Много знаний о F#, как о чистом функциональном языке программирования читатель мог почерпнуть уже из прошлых моих постов, однако исключительно ради того, чтобы создать полное впечатление о языке, я кратко повторю все их еще раз.<br/>
<br/>
<h4>Идентификаторы, ключевые слова, функции.</h4><br/>
Итак, F#, как ни странно, позволяет программисту определять идентификаторы, с помощью которых можно будет в последствии обращаться к функциям. Делается это с помощью ключевого слова <font color="#0000ff">let</font>, за которым следует имя идентификатора, список параметров, а после знака равенства — выражения, определяющего функцию. Примерно так:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> k = 3.14<br/>
    <font color="#0000ff">let</font> square x = x**2.0<br/>
</font></code></blockquote><br/>
В отличие от императивного программирования, первое выражение определяет не переменную, а скорее константу, так как значение ее нельзя изменять во время выполнения программы. Вообще говоря, F# не делает различия между функциями и значениями — любая функция является значением, которое так же свободно можно передавать в качестве параметра.<br/>
Список всех ключевых слов F# можно увидеть <a href="http://stuff.mit.edu/afs/athena/software/fsharp_v1.1.12/FSharp-1.1.12.3/manual/lexyacc.html#Keywords">здесь</a>. Слова из второго приведенного по ссылке списка не используются в данный момент, но зарезервированы на будущее. Их можно использовать, но компилятор при этом выдаст предупреждение.<br/>
F# поддерживает <a href="http://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%80%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">каррированные</a> функции, в которые можно передавать не все параметры сразу:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> add a b = a + b <font color="#A31515">//'a -> 'a -> 'a</font><br/>
    <font color="#0000ff">let</font> addFour = add 4 <font color="#A31515">//'a -> 'a</font><br/>
</font></code></blockquote><br/>
Второй идентификатор задает функцию уже от одного свободного параметра, другой определен как 4. Это еще раз демонстрирует тезис, что функция есть значение. Поскольку функция — значение, то не получив полного набора параметров, она попросту возвращает другую функцию, которая тоже является значением.<br/>
Однако все функции из .NET не обладают свойством каррируемости, и для их применения в F# используются кортежи — наборы нескольких разнотипных значений. Кортеж может содержать множество различных параметров внутри себя, однако рассматривается F# как один параметр, и как следствие применяется только целиком. Записываются кортежи в круглых скобках, через запятую.<br/>
<blockquote><code><font color="black"> <br/>
    <font color="#0000ff">let</font> add (a,b) = a + b<br/>
    <font color="#0000ff">let</font> addFour = add 4<br/>
</font></code></blockquote><br/>
Такой код не будет скомпилирован, так как по мнению F# мы пытаемся применить функцию к параметру несоответствующего типа, а именно int вместо 'a * 'b.<br/>
Однако следует помнить, что при разработке собственных функций, особенно тех, которые будут использоваться другими программистами, следует по возможности делать их каррируемыми, так как они очевидно обладают большей гибкостью в использовании.<br/>
Как я полагаю, читатель уже заметил, в F# в функциях не нужно явно определять возвращаемое значение. Однако при этом непонятно, как вычислять промежуточные значения внутри функции? Здесь F# использует способ, о существовании которого многие, думаю, успели подзабыть — с помощью пробелов. Внутренние вычисления в функции обычно отделяются четырьмя пробелами:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> midValue a b =<br/>
        <font color="#0000ff">let</font> dif = b - a<br/>
        <font color="#0000ff">let</font> mid = dif / 2<br/>
        mid + a<br/>
</font></code></blockquote><br/>
Кстати, если кого-то из видевших программы на F# удивляло постоянное присутствие в коде команды <font color="#0000ff">#light</font>, то один из ее эффектов как раз и заключается в том, что пробелы становятся важны. Это позволяет избежать использования множества ключевых слов и знаков, пришедших из OCaml, таких как <font color="#0000ff">in</font>, ;;, <font color="#0000ff">begin</font>, <font color="#0000ff">end</font>. <br/>
Каждый из идентфикаторов имеет свою область применения, которая начинается от места его определения (то есть применять его выше по коду, чем место его определения, нельзя), а заканчивается в конце секции, где он был определен. Например, промежуточные идентификаторы dif и mid из предыдущего примера не будут действовать за пределами функции midValue.<br/>
Идентификаторы, определенные внутри функций имеют некоторую особенность в сравнении с теми, что определены на внешнем уровне — они могут быть переопределены с помощью слова <font color="#0000ff">let</font>. Это полезно, так как позволяет не изобретать все новые, и чаще всего мало что значащие имена для держания промежуточных значений. Например, в предыдущем примере мы могли бы написать так:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> midValue a b = <br/>
        <font color="#0000ff">let</font> k = b - a<br/>
        <font color="#0000ff">let</font> k = k / 2<br/>
        k + a<br/>
</font></code></blockquote><br/>
Более того, поскольку это переопределение в полном смысле, а не изменение значения переменной, то мы вполне можем поменять не только значение идентификатора, но и его тип.<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> changingType () = <br/>
        <font color="#0000ff">let</font> k = 1<br/>
        <font color="#0000ff">let</font> k = <font color="#A31515">"string"</font><br/>
</font></code></blockquote><br/>
F# позволяет в большинстве случаев обходиться вовсе без циклов за счет пакетных функций обработки последовательностей map, list, fold и.т.д., однако в тех случаях, где это необходимо, можно использовать рекурсию. Что легче для понимания, цикл или рекурсия — вопрос в целом открытый, на мой взгляд и то и другое вполне посильно. Для того, чтобы функция в F# могла обратиться к себе внутри своего определения, необходимо добавить после <font color="#0000ff">let</font> ключевое слово <font color="#0000ff">rec</font>.<br/>
<br/>
F# является сильно типизированным языком, то есть нельзя использовать функции с значениями неподходящего типа. Функции, как и любые значения, имеют свой тип. F# во многих случаях сам выводит тип функции, при этом он может быть определен неоднозначно, например:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> square x = x*x<br/>
</font></code></blockquote> <br/>
имеет тип 'a <font color="#0000ff">-></font> 'a, где 'a может быть int, float, и вообще говоря любым, для которого перегружен оператор *.<br/>
При необходимости тип параметра функции можно задать самому (например, когда надо использовать методы класса):<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> parent (x:XmlNode) = x.ParentNode<br/>
</font></code></blockquote><br/>
<br/>
<h4>Лямбды и операторы</h4><br/>
F# поддерживает анонимные функции или лямбды, которые используются, если нет необходимости присваивать функции имя, когда она передается в качестве параметра для другой функции. Пример лямбды ниже:<br/>
<blockquote><code><font color="black">    List.map (fun x <font color="#0000ff">-></font> x**2) [1..10]<br/>
</font></code></blockquote><br/>
Данная функция выдаст список, состоящий из квадратов всех чисел от одного до десяти.<br/>
Кроме того, в F# существует и еще один способ определения лямбды с помощью ключевого слова <font color="#0000ff">function</font>. Определенная таким образом лямбда может содержать внутри себя операцию сравнения с шаблоном (pattern matching), однако она принимает только один параметр. Но даже и в этом случае можно сохранить каррируемость функции:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">function</font> x <font color="#0000ff">-></font> <font color="#0000ff">function</font> y <font color="#0000ff">-></font> x + y<br/>
</font></code></blockquote><br/>
Лямбды в F# поддерживают <a href="http://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">замыкание</a>, однако об этом будет подробнее рассказано во второй части обзора. <br/>
В F# операторы (унарные и бинарные) можно рассматривать как более эстетичный способ вызова функций. Так же как и в C#, операторы перегружены, так что могут использоваться с различными типами, однако в отличие от C#, здесь нельзя применять оператор к операндам различного типа, то есть нельзя складывать строки с числами (и даже целые с вещественными), необходимо всегда делать приведение.<br/>
F# позволяет перегружать операторы, или определять собственные. <br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> (+) a b = a - b<br/>
    printfn "%d" (1 + 1) <font color="#A31515">// "0"</font><br/>
</font></code></blockquote><br/>
Операторы могут являться любой последовательностью следующих символов !$%&amp;*+_./&lt;=>?@^|~:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> (+:*) a b = (a + b) * a * b<br/>
    printfn <font color="#A31515">"%d"</font> (1 +:* 2) <font color="#A31515">// "6"</font><br/>
</font></code></blockquote><br/>
<br/>
<h4>Инициализация списков</h4><br/>
Еще одной мощной техникой F# является инициализация списков, которая позволяет создавать достаточно сложные списки, массивы и последовательности (эквивалент IEnumerable) напрямую, с помощью использования специального синтаксиса. Списки задаются в прямоугольных скобках [ ], последовательности — в {}, массивы — в [| |].<br/>
Простейший способ — определение промежутка, который задается с использованием (..), например:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> lst = [1 .. 10]<br/>
    <font color="#0000ff">let</font> seq = {<font color="#A31515">'a'</font>..<font color="#A31515">'z'</font>}<br/>
    </font></code></blockquote><br/>
Также с помощью добавления еще одного (..) можно задавать шаг выбора в промежутке:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> lst = [1 .. 2 .. 10] <font color="#A31515">// [1, 3, 5, 7, 9]</font><br/>
</font></code></blockquote><br/>
Кроме того, при создании списков можно использовать циклы (циклы могут быть как одинарными, так и вложенными в любой степени)<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> lst = [for i <font color="#0000ff">in</font> 1..10 <font color="#0000ff">-></font> i*i] <font color="#A31515">// [1, 4, 9,..]</font><br/>
</font></code></blockquote><br/>
Однако и это еще не все. При инициализации списков можно явно указывать, какие элементы заносить, с помощью операторов <font color="#0000ff">yield</font> (добавляет в последовательность один элемент) и <font color="#0000ff">yield!</font> (добавляет множество элементов), а также можно использовать любые логические конструкции, циклы, сравнения с шаблоном. Например, вот так выглядит создание последовательности имен всех файлов содержащихся в данной папке и во всех ее подпапках:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> <font color="#0000ff">rec</font> xamlFiles dir filter = <br/>
        seq { <font color="#0000ff">yield!</font> Directory.GetFiles(dir, filter)<br/>
            <font color="#0000ff">for</font> subdir <font color="#0000ff">in</font> Directory.GetDirectories(dir) <font color="#0000ff">do</font> <font color="#0000ff">yield!</font> xamlFiles subdir filter}<br/>
</font></code></blockquote><br/>
<br/>
<h4>Сравнение с шаблоном</h4><br/>
Сравнение с шаблоном немного похоже на обычный условный оператор или switch, однако обладает намного большей функциональностью. В общем виде синтаксис операции выглядит так:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">match</font> идент <font color="#0000ff">with</font><br/>
    [|]шаблон1|шаблон2|..|шаблон10 <font color="#0000ff">-></font> вычисление1<br/>
    |шаблон11 <font color="#0000ff">when</font> условие1 <font color="#0000ff">-></font> вычисление2<br/>
    ...<br/>
</font></code></blockquote><br/>
Сравнение с шаблонами идет сверху вниз, так что не следует забывать о том, что более узкие шаблоны должны располагаться выше. Самый общий шаблон выглядит так: _ (нижнее подчеркивание), и означает, что нас не интересует значение идентификатора. Кроме того, сравнение с шаблоном должно быть полным (отсутствуют нерассмотренные возможности) и все вычисления должны выдавать результат одного и того же типа. <br/>
Простейший вид операции с шаблоном сравнивает идентификатор с некоторым значением (числовым, строковым) С помощью ключевого слова <font color="#0000ff">when</font> к шаблону можно добавлять условие, так что вычисления будут выполняться <br/>
Если вместо значения подставляется другой идентификатор, то ему присваивается значение проверяемого идентификатора. <br/>
Наиболее часто используемые варианты сравнения с шаблоном — над кортежами и списками. Пусть x — кортеж вида (string*int), тогда возможно написать любой подобный шаблон:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">match</font> x <font color="#0000ff">with</font><br/>
    | <font color="#A31515">"Пупкин"</font>, _ <font color="#0000ff">-></font> <font color="#A31515">"Здравствуй, Вася!"</font><br/>
    | _, i <font color="#0000ff">when</font> i > 200 <font color="#0000ff">-></font> <font color="#A31515">"Здравствуй, Дункан!"</font><br/>
    | name, age <font color="#0000ff">-></font> sprintf <font color="#A31515">"Здравствуйте %s, %d"</font> name age<br/>
    | _ <font color="#0000ff">-></font> <font color="#A31515">"И вам тоже здрасте"</font> <br/>
</font></code></blockquote><br/>
Заметьте, что если в шаблоне имеются идентификаторы, то они автоматически определятся соответствующими значениями, и в обработке можно использовать отдельно поля name и age. <br/>
Точно таким же образом обрабатывается список (который на самом деле и не список даже, а размеченное объединение (discriminated union), о которых речь ниже). Обычно шаблоны для списка ('a list) выглядят либо как [], если он пустой, либо head::tail где head имеет тип 'a, а tail — 'a list, однако возможны и другие варианты, например:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">match</font> lst <font color="#0000ff">with</font><br/>
    |[x;y;z] <font color="#0000ff">-></font> <font color="#A31515">//lst содержит три элемента, причем они присвоятся идентификаторам x y z.</font><br/>
    |1::2::3::tail <font color="#0000ff">-></font> <font color="#A31515">// lst начинается с [1,2,3] tail присвоится хвост списка</font> <br/>
</font></code></blockquote><br/>
Способность при сравнении с шаблоном передавать в идентификаторы значения так полезна, что в F# существует возможность такого присвоения напрямую, без использования шаблонного синтаксиса, вот так:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> (name, age) = x <br/>
</font></code></blockquote><br/>
или даже так:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> (name, _) = x <br/>
</font></code></blockquote><br/>
если нас интересует только первый элемент кортежа.<br/>
<br/>
<h4>Записи</h4><br/>
Записи (record) в F# аналогичны кортежам, с той разницей, что в них каждое поле имеет название. Определение записи заключается в фигурные скобки и разделяется точкой с запятой.<br/>
<blockquote><code><font color="black">    <font color="#0000ff">type</font> org = { boss : string; tops :string list }<br/>
    <font color="#0000ff">let</font> Microsoft = { boss = <font color="#A31515">"Bill Gates"</font>; tops = [<font color="#A31515">"Steve Balmer"</font>, <font color="#A31515">"Paul Allen"</font>]}<br/>
</font></code></blockquote><br/>
Доступ к полям записи осуществляется, как обычно, через точку. Записи могут имитировать классы, что будет показано ниже. <br/>
<br/>
<h4>Размеченное объединение</h4><br/>
Этот тип в F# позволяет хранить данные, имеющие разную структуру и смысл. Например, вот такой тип:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">type</font> Distance =<br/>
    |Meter <font color="#0000ff">of</font> float<br/>
    |Feet <font color="#0000ff">of</font> float<br/>
    |Mile <font color="#0000ff">of</font> float<br/>
    <br/>
    <font color="#0000ff">let</font> d1 = Meter 10<br/>
    <font color="#0000ff">let</font> d2 = Feet 65.5<br/>
</font></code></blockquote><br/>
Хотя все три вида данных имеют один и тот же тип (что необязательно), они очевидно отличны по смыслу. Обработка размеченных объединений всегда осуществляется через сравнение с шаблоном.<br/>
<blockquote><code><font color="black">        <font color="#0000ff">match</font> x <font color="#0000ff">with</font><br/>
        |Meter x <font color="#0000ff">-></font> x<br/>
        |Feet x <font color="#0000ff">-></font> x*3.28<br/>
        |Mile x <font color="#0000ff">-></font> x*0.00062<br/>
</font></code></blockquote><br/>
Как уже говорилось, такой распространенный тип данных как список, является размеченным объединением. Неформальное его определение выглядит так:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">type</font> a' list =<br/>
    |[]<br/>
    |:: <font color="#0000ff">of</font> a' * List<br/>
</font></code></blockquote><br/>
Кстати, как заметно из вышеприведенного примера, размеченные множества в F# можно параметризовать, на манер generic'ов.<br/>
<br/>
<h2>F# императивный</h2><br/>
<br/>
<h4>Тип unit</h4><br/>
Тип unit родственен типу void из C#. Если функция не принимает аргументов, то ее тип входа — unit, если она не возвращает никакого значения — ее тип выхода unit. Для функционального программирования функция, которая не принимает или не возвращает значение не представляет никакой ценности, однако в императивной парадигме она ценность имеет за счет побочных эффектов (например ввода-вывода) Единственное значение типа unit имеет вид (). Вот такая функция ничего не принимает и ничего не делает (unit -> unit).<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> doNothingWithNothing () = ()<br/>
</font></code></blockquote><br/>
Скобки после названия означают, что это именно функция с пустым входом, а не значение. Как мы уже говорили функции являются значениями, но между функциональным и нефункциональным значением есть большая разница — второе вычисляется только однажды, а первое — при каждом вызове. <br/>
Любую функцию, возвращающую значение можно конвертировать в функцию, возвращающую тип unit с помощью функции ignore. Применяя ее, мы как бы сообщаем компилятору, что в данной функции нас интересует только побочный эффект, а не возвращаемое значение.<br/>
<br/>
<h4>Ключевое слово mutable</h4><br/>
Как мы знаем, в общем случае, идентификаторы в F# можно определить каким-то значением, однако это значение нельзя изменить. Однако все-таки старые добрые императивные переменные бывают полезны, так что в F# предусмотрен механизм для создания и использования переменных. Для этого перед именем переменной надо написать ключевое слово <font color="#0000ff">mutable</font>, а изменять значение можно с помощью оператора <font color="#0000ff">&lt;-</font>.<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> <font color="#0000ff">mutable</font> i = 0<br/>
    i <font color="#0000ff">&lt;-</font> i + 1<br/>
</font></code></blockquote><br/>
Однако применение таких переменных ограничено, например их нельзя использовать во внутренних функциях, а также для замыкания в лямбдах. Такой код выдаст ошибку:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> mainFunc () = <br/>
        <font color="#0000ff">let</font> <font color="#0000ff">mutable</font> i = 0<br/>
        <font color="#0000ff">let</font> subFunc () =<br/>
            i <font color="#0000ff">&lt;-</font> 1<br/>
</font></code></blockquote><br/>
<br/>
<h4>Тип ref</h4><br/>
В F# существует и другой способ определения переменных, с помощью типа <font color="#0000ff">ref</font>. Для этого всего лишь надо поставить ключевое слово <font color="#0000ff">ref</font> перед вычислениями, которые представляют значение идентификатора. <br/>
Для того, чтобы присвоить переменной другое значение используется до боли ностальгичный оператор :=, обращение же ко значению переменной осуществляется добавлением! перед именем переменной. <br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> i = <font color="#0000ff">ref</font> 0<br/>
    i := !i + 1<br/>
</font></code></blockquote><br/>
Пожалуй данная нотация далеко не столь опрятна, как предыдущая, чего стоит только использование восклицательного знака для получения значения (для отрицания в F# существует ключевое слово not)<br/>
Однако в отличие от <font color="#0000ff">mutable</font>, у <font color="#0000ff">ref</font> типа нет ограничений на область действия, так что его можно использовать и во вложенных функциях, и в замыканиях. Такой код будет работать:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> i = <font color="#0000ff">ref</font> 2<br/>
    <font color="#0000ff">let</font> lst = [1..10]<br/>
    List.map (fun x <font color="#0000ff">-></font> x * !i) lst<br/>
</font></code></blockquote><br/>
<br/>
<h4>Массивы</h4><br/>
В F# существуют массивы, которые являются изменяемым типом. Значения внутри массива можно переприсвоить, в отличие от значений в списках. Массивы задаются в таких скобках [| |], элементы в нем перечисляются через точку с запятой. Доступ к элементу массива осуществляется через .[ind], а присваивание — знакомым по работе с mutables оператором <font color="#0000ff">&lt;-</font>. Все функции для обработки массивов (практически аналогичные методам для обработки списков), находятся в классе Array.<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> arr = [|1; 2; 3|]<br/>
    arr.[0] <font color="#0000ff">&lt;-</font> 10 // [|10,2,3|]<br/>
</font></code></blockquote><br/>
Массивы можно инициализировать точно таким же способом, как и списки, используя .., yield и.т.п.<br/>
<blockquote><code><font color="black">        <font color="#0000ff">let</font> squares = [| <font color="#0000ff">for</font> x <font color="#0000ff">in</font> 1..9 <font color="#0000ff">-></font> x,x*x |] // [| (1,1);(2,4);...;(9,81) |]<br/>
</font></code></blockquote><br/>
Также F# позволяет создавать многомерные массивы, как «ступенчатые» (с подмассивами разной длины), так и «монолитные».<br/>
<br/>
<h4>Управляющая логика</h4><br/>
В F# можно использовать привычную императивную управляющую логику — условный оператор <font color="#0000ff">if</font>… <font color="#0000ff">then</font>… <font color="#0000ff">else</font>, а также циклы <font color="#0000ff">for</font> и <font color="#0000ff">while</font>. <br/>
Следует помнить о том, что оператор <font color="#0000ff">if</font> тоже можно рассматривать как функцию, а значит она должна при любом условии выдавать значение одного и того же типа. Это к тому же предполагает, что использование <font color="#0000ff">else</font> обязательно. На самом деле, есть одно исключение — когда вычисления при выполненном условии возвращают тип unit:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">if</font> System.DateTime.Now.DayOfWeek = System.DayOfWeek.Sunday <font color="#0000ff">then</font><br/>
        printfn <font color="#A31515">"Хороших выходных!"</font><br/>
    printfn <font color="#A31515">"Каждый день замечателен!"</font> <br/>
</font></code></blockquote><br/>
Для определения, какие функции относятся к циклу, какие нет, также используются сдвиги. Например, в верхнем примере второе предложение будет выведено независимо от дня недели.<br/>
Цикл <font color="#0000ff">for</font> в F# имеет тип unit, так что вычисления в теле цикла должны выдавать этот тип, иначе компилятор выдаст предупреждение.<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> arr = [|1..10|]<br/>
    <font color="#0000ff">for</font> i = 0 <font color="#0000ff">to</font> Array.length arr - 1 <font color="#0000ff">do</font><br/>
        printfn arr.[i]<br/>
</font></code></blockquote><br/>
Если хочется пройтись в обратную сторону, то <font color="#0000ff">to</font> заменяется на <font color="#0000ff">downto</font>, как в старые добрые времена.<br/>
Также можно использовать другую форму цикла <font color="#0000ff">for</font>, аналогичную всем знакомому foreach:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">for</font> item <font color="#0000ff">in</font> arr<br/>
        print_any item<br/>
</font></code></blockquote><br/>
Цикл <font color="#0000ff">while</font> также вполне обычен и знаком для императивного программиста, тело его располагается между ключевыми словам <font color="#0000ff">do</font> и <font color="#0000ff">done</font>, но второе можно опционально опускать, используя систему сдвигов.<br/>
<br/>
<h4>Вызов статических методов и объектов из библиотек .NET</h4><br/>
В F# можно использовать весь набор инструментов .NET, однако очевидно, что все методы, написанные не под F# не обладают свойством каррируемости, так что аргументы им надо задавать в виде кортежа, соответствующего по типу набору входных элементов. При этом запись вызова не будет ни на йоту отличаться от сишарпной:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">#light</font><br/>
    <font color="#0000ff">open</font> System.IO<br/>
    <font color="#0000ff">if</font> File.Exists(<font color="#A31515">"file.txt"</font>) <font color="#0000ff">then</font><br/>
        printf <font color="#A31515">"Есть такой файл!"</font><br/>
</font></code></blockquote><br/>
Однако, если вам так уж хочется, чтобы .NET метод обладал бы каррируемостью, его надо импортировать, примерно следующим образом:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> exists file = File.Exists(file)<br/>
</font></code></blockquote><br/>
Использовать объекты так же просто — они создаются с помощью ключевого слова <font color="#0000ff">new</font> (кто бы мог подумать?), и применением соответствующего кортежа параметров конструктора. Объект можно присвоить идентификатору с помощью <font color="#0000ff">let</font>. вызов методов аналогичен статическим, поля изменяются с помощью <font color="#0000ff">&lt;-</font>.<br/>
<blockquote><code><font color="black">    <font color="#0000ff">#light</font><br/>
    <font color="#0000ff">let</font> file = <font color="#0000ff">new</font> FileInfo(<font color="#A31515">"file.txt"</font>)<br/>
    <font color="#0000ff">if</font> not file.Exists <font color="#0000ff">then</font><br/>
        using (file.CreateText()) (fun stream <font color="#0000ff">-></font><br/>
            stream.WriteLine(<font color="#A31515">"Hello world"</font>))<br/>
    file.Attributes <font color="#0000ff">&lt;-</font> FileAttributes.ReadOnly<br/>
    </font></code></blockquote><br/>
F# позволяет инициализировать поля сразу при создании объекта, вот таким образом:<br/>
<blockquote><code><font color="black">        <font color="#0000ff">let</font> file = <font color="#0000ff">new</font> FileInfo(<font color="#A31515">"file.txt"</font>, Attributes = FileAttributes.ReadOnly)<br/>
</font></code></blockquote><br/>
<br/>
<h4>Использование событий в F#</h4><br/>
У каждого события в F# существует метод Add, который добавляет функцию обработчика к событию. Функция обработчика должна иметь тип 'a <font color="#0000ff">-></font> unit. Вот как можно подписаться на событие таймера:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">#light</font><br/>
    <font color="#0000ff">open</font> System.Timers<br/>
    <font color="#0000ff">let</font> timer = <font color="#0000ff">new</font> Timer(Interval=1000, Enabled=true)<br/>
    timer.Elapsed.Add(fun _ <font color="#0000ff">-></font> printfn <font color="#A31515">"Timer tick!"</font>)<br/>
</font></code></blockquote><br/>
Отписка от события производится с помощью метода Remove.<br/>
<br/>
<h4>Оператор |></h4><br/>
Пересылающий оператор |> определяется следующим образом:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> (|>) f g = g f<br/>
</font></code></blockquote><br/>
Он передает первый аргумент в качестве параметра второму аргументу. Второй аргумент, разумеется должен быть функцией, которая в качестве единственного параметра принимает значение типа f. Кстати, именно из-за возможности использования с пересылающим оператором все функции над списками (iter, map, fold) принимают сам список последним. Тогда в качестве g можно использовать недоопределенную функцию:<br/>
<blockquote><code><font color="black">    [1..10] |> List.iter (fun i <font color="#0000ff">-></font> print_int i)<br/>
</font></code></blockquote><br/>
Например, функция iter имеет вид ('a list <font color="#0000ff">-></font> unit) <font color="#0000ff">-></font> 'a list <font color="#0000ff">-></font> unit, задав лямбдой первый параметр мы получаем функцию типа 'a list <font color="#0000ff">-></font> unit, которая как раз принимает в качестве аргумента определенный до оператора список. <br/>
В программах зачастую применяются длинные цепи пересылающих операторов, каждый из которых обрабатывает значение, полученное предыдущим, этакий конвеер.<br/>
<br/>
<h2>F# объектно-ориентированный</h2><br/>
Думаю, мало кто готов поспорить с тем, что именно объектно-ориентированная парадигма на сегодняшний день является флагманом программирования, и конечно же, F# не мог проигнорировать заложенные в нем концепции. Посмотрим, что же он нам предлагает.<br/>
<br/>
<h4>Типизация.</h4><br/>
В F# имеется возможность явно изменять статический типа значения. У F# для приведения вверх и вниз используются два разных оператора. Приведение вверх, то есть присвоение статическому типу значения типа одного из его предков, осуществляется оператором :>. Значение strObj в нижнем примере будет иметь тип object.<br/>
<blockquote><code><font color="black"> <br/>
    <font color="#0000ff">let</font> strObj = (<font color="#A31515">"Тили-тили, трали-вали"</font> :> obj)<br/>
</font></code></blockquote><br/>
Присвоение вниз, то есть уточнение типа значения типом одного из его потомков, осуществляется оператором :?>.<br/>
Для проверки типа значения (аналог is из C#) служит оператор :?, который можно использовать не только в логических конструкциях, но и при сравнении с шаблоном.<br/>
<blockquote><code><font color="black">    <font color="#0000ff">match</font> x <font color="#0000ff">with</font><br/>
    |:? string <font color="#0000ff">-></font> printf <font color="#A31515">"Это строка!"</font><br/>
    |:? int <font color="#0000ff">-></font> printf <font color="#A31515">"Это целое!"</font><br/>
    |:? obj <font color="#0000ff">-></font> printf <font color="#A31515">"Неизвестно что!"</font><br/>
    </font></code></blockquote><br/>
Обычно F# не берет при вычислении функций в расчет иерархию наследования типов, то есть не позволяет применять в качестве аргумента тип-наследник. Например такая программа не скомпилируется:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> showForm (form:Form) =<br/>
        form.Show()<br/>
    <font color="#0000ff">let</font> ofd = <font color="#0000ff">new</font> OpenFileDialog();<br/>
    showForm ofd <br/>
</font></code></blockquote><br/>
В принципе, можно явно привести тип: showForm (ofd :> Form), однако F# предоставляет и другой способ — добавить перед типом в сигнатуре функции знак решетки #.<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> showForm (form: #Form) = <br/>
        form.Show()<br/>
</font></code></blockquote><br/>
Таким образом определенная функция примет аргументом объект любого наследуемого от Form класса.<br/>
<br/>
<h4>Записи и обединения как объекты</h4><br/>
В записи и объединения можно добавить методы. Для этого после определения записи необходимо добавить ключевое слово <font color="#0000ff">with</font>, после определения всех методов написать <font color="#0000ff">end</font>, а перед идентификатором каждого метода использовать ключевое слово <font color="#0000ff">member</font>:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">type</font> Point ={<br/>
        <font color="#0000ff">mutable</font> x: int;<br/>
        <font color="#0000ff">mutable</font> y: int; }<br/>
    <font color="#0000ff">with</font><br/>
        <font color="#0000ff">member</font> p.Swap() =<br/>
            <font color="#0000ff">let</font> temp = p.x<br/>
            p.x <font color="#0000ff">&lt;-</font> p.y<br/>
            p.y <font color="#0000ff">&lt;-</font> temp<br/>
    <font color="#0000ff">end</font><br/>
</font></code></blockquote><br/>
Заметьте, что параметр p, заданный перед именем метода используется внутри него для получения доступа к полям. <br/>
<br/>
<h4>Классы и интерфейсы</h4><br/>
Классы в F# определяются с помощью ключевого слова <font color="#0000ff">type</font>, за которым следует имя класса, знак равенства и ключевое слово <font color="#0000ff">class</font>. Завершается определение класса ключевым словом <font color="#0000ff">end</font>. Для того, чтобы задать конструктор, необходимо в определение класса включить член с именем <font color="#0000ff">new</font>.<br/>
<blockquote><code><font color="black">    <font color="#0000ff">type</font> construct = <font color="#0000ff">class</font><br/>
        <font color="#0000ff">new</font> () = {}<br/>
    <font color="#0000ff">end</font><br/>
    <font color="#0000ff">let</font> inst = <font color="#0000ff">new</font> construct()<br/>
</font></code></blockquote><br/>
Обратите внимание, что определение класса должно содержать в себе хотя бы один конструктор, иначе код не скомпилируется! F# не предоставляет конструктора по умолчанию, как C#.<br/>
Чтобы определить поле, необходимо добавить перед его именем ключевое слово <font color="#0000ff">val</font>.<br/>
<blockquote><code><font color="black">    <font color="#0000ff">type</font> File = <font color="#0000ff">class</font><br/>
        <font color="#0000ff">val</font> path: string<br/>
        <font color="#0000ff">val</font> info : FileInfo<br/>
        <font color="#0000ff">new</font> () = <font color="#0000ff">new</font> File(<font color="#A31515">"default.txt"</font>)<br/>
        <font color="#0000ff">new</font> (path) = <br/>
            { path = path;<br/>
             info = <font color="#0000ff">new</font> FileInfo(path) }<br/>
    <font color="#0000ff">end</font><br/>
    <font color="#0000ff">let</font> file1 = <font color="#0000ff">new</font> File(<font color="#A31515">"sample.txt"</font>)<br/>
</font></code></blockquote><br/>
Как видите, конструкторы можно совершенно привычным образом перегружать. Конструктор не может оставить некоторое поле неинициализированным, иначе код не будет скомпилирован. Заметьте, что в конструкторах можно только инициализировать поля или вызывать другие конструкторы. Чтобы задать в конструкторе дополнительные операции, необходимо дописать после него <font color="#0000ff">then</font>, после которого записать все дополнительные вычисления:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">new</font> (path) <font color="#0000ff">as</font> x =<br/>
        { path = path;<br/>
         info = <font color="#0000ff">new</font> FileInfo(path) }<br/>
        <font color="#0000ff">then</font><br/>
        <font color="#0000ff">if</font> not x.info.Exists <font color="#0000ff">then</font> printf <font color="#A31515">"Нет файла!"</font><br/>
</font></code></blockquote><br/>
По умолчанию поля класса неизменяемы, чтобы сделать некоторое поле изменяемым, необходимо добавить перед его именем <font color="#0000ff">mutable</font>.<br/>
Интерфейс в F# задается и имплементируется следуюшим образом:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">let</font> ISampleInterface = interface<br/>
        abstract Change : newVal : int <font color="#0000ff">-></font> unit<br/>
    <font color="#0000ff">end</font><br/>
    <br/>
    <font color="#0000ff">type</font> SampleClass = <font color="#0000ff">class</font><br/>
        <font color="#0000ff">val</font> <font color="#0000ff">mutable</font> i : int<br/>
        <font color="#0000ff">new</font> () = { i = 0}<br/>
        interface ISampleInterface <font color="#0000ff">with</font><br/>
            <font color="#0000ff">member</font> x.Change y = x.i <font color="#0000ff">&lt;-</font> y<br/>
        <font color="#0000ff">end</font><br/>
    <font color="#0000ff">end</font><br/>
</font></code></blockquote><br/>
F# предлагает еще один элегантный способ определения класса — неявное задание. Сразу после названия класса перечисляются входные параметры, которые в ином случае входили бы в аргументы конструктора. Конструирование класса происходит прямо в его теле, с помощью последовательности let, предшествующих определению методов. Все таким образом определенные идентификаторы будут приватны для класса. Поля и методы класса задаются с помощью ключевого слова <font color="#0000ff">member</font>. Лучше сразу посмотреть пример:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">type</font> Counter (start, inc, length) = <font color="#0000ff">class</font><br/>
        <font color="#0000ff">let</font> finish = start + length<br/>
        <font color="#0000ff">let</font> <font color="#0000ff">mutable</font> current = start<br/>
        <font color="#0000ff">member</font> c.Current = current<br/>
        <font color="#0000ff">member</font> c.Inc () =<br/>
            <font color="#0000ff">if</font> current > finish <font color="#0000ff">then</font> failwith <font color="#A31515">"Динь-дилинь!"</font><br/>
            current <font color="#0000ff">&lt;-</font> current + inc<br/>
    <font color="#0000ff">end</font><br/>
<br/>
    <font color="#0000ff">let</font> count = <font color="#0000ff">new</font> Counter(0, 5, 100)<br/>
        count.Inc()<br/>
</font></code></blockquote><br/>
F# как и C# поддерживает только одиночное наследование, и имплементацию нескольких интерфейсов. Наследование задается с помощью ключевого слова <font color="#0000ff">inherit</font> которое идет сразу после <font color="#0000ff">class</font>:<br/>
<blockquote><code><font color="black"> <br/>
    <font color="#0000ff">type</font> Base = <font color="#0000ff">class</font><br/>
        <font color="#0000ff">val</font> state : int<br/>
        <font color="#0000ff">new</font> () = {state = 0}<br/>
    <font color="#0000ff">end</font><br/>
    <br/>
    <font color="#0000ff">type</font> Sub = <font color="#0000ff">class</font><br/>
        <font color="#0000ff">inherit</font> Base<br/>
        <font color="#0000ff">val</font> otherState : int<br/>
        <font color="#0000ff">new</font> () = {otherState = 0}<br/>
    <font color="#0000ff">end</font><br/>
</font></code></blockquote><br/>
Нет необходимости вызывать явно базовый пустой конструктор. При вызове любого конструктора потомка автоматически вызовется пустой конструктор предка. Если такого конструктора в предке нет, необходимо явно вызвать в теле конструктора потомка базовый конструктор с помощью ключевого слова <font color="#0000ff">inherit</font>.<br/>
Свойства в F# определяются следующим образом:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">type</font> PropertySample = <font color="#0000ff">class</font><br/>
        <font color="#0000ff">let</font> <font color="#0000ff">mutable</font> field = 0<br/>
    <font color="#0000ff">member</font> x.Property <br/>
        <font color="#0000ff">with</font> get () = field<br/>
        and set v = field <font color="#0000ff">&lt;-</font> rand<br/>
    <font color="#0000ff">end</font><br/>
</font></code></blockquote><br/>
Для определения статических полей перед <font color="#0000ff">member</font> добавляется ключевое слово <font color="#0000ff">static</font> и убирается параметр, обзначающий экземпляр класса:<br/>
<blockquote><code><font color="black">    <font color="#0000ff">type</font> StaticSample = <font color="#0000ff">class</font><br/>
        <font color="#0000ff">static</font> <font color="#0000ff">member</font> TrimString (st:string) = st.Trim()<br/>
    <font color="#0000ff">end</font><br/>
</font></code></blockquote><br/>
<br/>
<h2>Заключение</h2><br/>
<br/>
Сегодня мы кратко рассмотрели большинство базовых возможностей языка, и можно на основании увиденного сделать какие-то выводы. <br/>
Что ж, по сути, любая операция с классами и переменными, доступная в C#, может быть выполнена и в F#, так что этот язык ничуть не менее объектно-ориентирован, чем его старший брат. Синтаксис в нем возможно и сложнее, но не критически, и как кажется, всего лишь вопрос привычки. С другой стороны, в функциональном плане F#, как и следовало ожидать (на самом деле следует ожидать еще больше, поскольку здесь была описана</div></div> <!----> <!----></div> <div class="tm-article-body__tags"><div class="tm-article-body__tags-links"><span class="tm-article-body__tags-title">Теги:</span> <span class="tm-article-body__tags-item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bfsharp%5D" class="tm-article-body__tags-item-link">fsharp</a></span></div> <div class="tm-article-body__tags-links"><span class="tm-article-body__tags-title">Хабы:</span> <span class="tm-article-body__tags-item"><a href="/ru/hub/programming/" class="tm-article-body__tags-item-link">
                  Программирование
                </a></span><span class="tm-article-body__tags-item"><a href="/ru/hub/fsharp/" class="tm-article-body__tags-item-link">
                  F#
                </a></span></div></div></article> <div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 43: ↑40 и ↓3</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg> <span title="Всего голосов 43: ↑40 и ↓3" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+37</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <!----> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    85
  </span></button> <div title="Читать комментарии" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/ru/post/55272/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value">
      68
    </span></a> <!----></div> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div></div> <!----></div> <!----> <div class="tm-page-article__additional-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body"><div class="tm-article-author tm-page-article__author"><!----> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-two-column"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/Meroving/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/fec/c12/fb5/fecc12fb5c667b1fa4aac44040d7f2c9.jpg" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 124 голоса " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    64
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">0</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info"><div class="tm-user-card__title"><span class="tm-user-card__name">Дмитрий Ейбоженко</span> <a href="/ru/users/Meroving/" class="tm-user-card__nickname">
          @Meroving
        </a> <!----></div> <p class="tm-user-card__short-info">Пользователь</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-two-column"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div></div> <!----></section> <div class="tm-page-article__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/55272/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 68 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <section class="tm-block tm-block_spacing-around"><header class="tm-block__header"><h2 class="tm-block__title">Похожие публикации</h2> <!----></header> <div class="tm-block__body"><ul class="tm-article-list-block__list"><li class="tm-article-list-block__item"><article class="tm-article-snippet-block-block tm-article-snippet-block-block_preview"><div class="tm-article-snippet-block__user-meta"><div class="tm-article-snippet-block__date"><time datetime="2018-09-26T09:33:54.000Z" title="2018-09-26, 12:33">26  сентября  2018 в 12:33</time></div></div> <h2 class="tm-article-title tm-article-title_block"><a href="/ru/post/424461/" class="tm-article-title__link"><span>Зачем изучать непопулярные языки. Пример сообщества F#</span></a></h2> <div class="tm-data-icons"><!----> <div class="tm-votes-meter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_small"><title>Всего голосов 40: ↑37 и ↓3</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg> <span title="Всего голосов 40: ↑37 и ↓3" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_small">+34</span></div> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">27K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    126
  </span></button> <div title="Читать комментарии" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/ru/post/424461/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value">
      164
    </span></a> <!----></div> <!----> <DIV class="v-portal" style="display:none;"></DIV></div></article></li><li class="tm-article-list-block__item"><article class="tm-article-snippet-block-block tm-article-snippet-block-block_preview"><div class="tm-article-snippet-block__user-meta"><div class="tm-article-snippet-block__date"><time datetime="2017-08-14T07:54:32.000Z" title="2017-08-14, 10:54">14  августа  2017 в 10:54</time></div></div> <h2 class="tm-article-title tm-article-title_block"><a href="/ru/company/microsoft/blog/335560/" class="tm-article-title__link"><span>Погружение в F#. Пособие для C#-разработчиков</span></a></h2> <div class="tm-data-icons"><!----> <div class="tm-votes-meter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_small"><title>Всего голосов 48: ↑47 и ↓1</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg> <span title="Всего голосов 48: ↑47 и ↓1" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_small">+46</span></div> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">68K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    251
  </span></button> <div title="Читать комментарии" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/ru/company/microsoft/blog/335560/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value">
      74
    </span></a> <!----></div> <!----> <DIV class="v-portal" style="display:none;"></DIV></div></article></li><li class="tm-article-list-block__item"><article class="tm-article-snippet-block-block tm-article-snippet-block-block_preview"><div class="tm-article-snippet-block__user-meta"><div class="tm-article-snippet-block__date"><time datetime="2012-09-06T21:29:12.000Z" title="2012-09-07, 01:29">7  сентября  2012 в 01:29</time></div></div> <h2 class="tm-article-title tm-article-title_block"><a href="/ru/post/151009/" class="tm-article-title__link"><span>Как я подружил Unity3D и F#</span></a></h2> <div class="tm-data-icons"><!----> <div class="tm-votes-meter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_small"><title>Всего голосов 55: ↑45 и ↓10</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg> <span title="Всего голосов 55: ↑45 и ↓10" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_small">+35</span></div> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">19K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    77
  </span></button> <div title="Читать комментарии" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/ru/post/151009/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value">
      6
    </span></a> <!----></div> <!----> <DIV class="v-portal" style="display:none;"></DIV></div></article></li> <!----></ul></div> <!----></section> <!----> <!----> <section class="tm-block tm-block_spacing-around"><header class="tm-block__header"><h2 class="tm-block__title">Лучшие публикации за сутки</h2> <!----></header> <div class="tm-block__body"><ul class="tm-article-list-block__list"><li class="tm-article-list-block__item"><article class="tm-article-snippet-block-block tm-article-snippet-block-block_preview"><div class="tm-article-snippet-block__user-meta"><div class="tm-article-snippet-block__date"><time datetime="2021-09-27T09:00:04.000Z" title="2021-09-27, 12:00">сегодня в 12:00</time></div></div> <h2 class="tm-article-title tm-article-title_block"><a href="/ru/company/ruvds/blog/580060/" class="tm-article-title__link"><span>Арракис, который мы заслужили</span></a></h2> <div class="tm-data-icons"><!----> <div class="tm-votes-meter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_small"><title>Всего голосов 96: ↑93 и ↓3</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg> <span title="Всего голосов 96: ↑93 и ↓3" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_small">+90</span></div> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">11K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    27
  </span></button> <div title="Читать комментарии" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/ru/company/ruvds/blog/580060/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value">
      34
    </span></a> <!----></div> <!----> <DIV class="v-portal" style="display:none;"></DIV></div></article></li><li class="tm-article-list-block__item"><article class="tm-article-snippet-block-block tm-article-snippet-block-block_preview"><div class="tm-article-snippet-block__user-meta"><div class="tm-article-snippet-block__date"><time datetime="2021-09-26T19:37:10.000Z" title="2021-09-26, 22:37">вчера в 22:37</time></div></div> <h2 class="tm-article-title tm-article-title_block"><a href="/ru/post/580086/" class="tm-article-title__link"><span>Термо принтер и JavaScript</span></a></h2> <div class="tm-data-icons"><!----> <div class="tm-votes-meter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_small"><title>Всего голосов 47: ↑46 и ↓1</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg> <span title="Всего голосов 47: ↑46 и ↓1" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_small">+45</span></div> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">8.9K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    35
  </span></button> <div title="Читать комментарии" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/ru/post/580086/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value">
      47
    </span></a> <!----></div> <!----> <DIV class="v-portal" style="display:none;"></DIV></div></article></li><li class="tm-article-list-block__item"><article class="tm-article-snippet-block-block tm-article-snippet-block-block_preview"><div class="tm-article-snippet-block__user-meta"><div class="tm-article-snippet-block__date"><time datetime="2021-09-26T21:49:14.000Z" title="2021-09-27, 00:49">сегодня в 00:49</time></div></div> <h2 class="tm-article-title tm-article-title_block"><a href="/ru/post/580092/" class="tm-article-title__link"><span>30 сентября: Let's Encrypt и конец срока действия IdenTrust DST Root CA X3</span></a></h2> <div class="tm-data-icons"><!----> <div class="tm-votes-meter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_small"><title>Всего голосов 43: ↑43 и ↓0</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg> <span title="Всего голосов 43: ↑43 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_small">+43</span></div> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">16K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    51
  </span></button> <div title="Читать комментарии" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/ru/post/580092/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value">
      89
    </span></a> <!----></div> <!----> <DIV class="v-portal" style="display:none;"></DIV></div></article></li><li class="tm-article-list-block__item"><article class="tm-article-snippet-block-block tm-article-snippet-block-block_preview"><div class="tm-article-snippet-block__user-meta"><div class="tm-article-snippet-block__date"><time datetime="2021-09-26T19:00:02.000Z" title="2021-09-26, 22:00">вчера в 22:00</time></div></div> <h2 class="tm-article-title tm-article-title_block"><a href="/ru/company/funcorp/blog/579542/" class="tm-article-title__link"><span>Jetpack Compose — как легко построить UI на Android</span></a></h2> <div class="tm-data-icons"><!----> <div class="tm-votes-meter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_small"><title>Всего голосов 39: ↑35 и ↓4</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg> <span title="Всего голосов 39: ↑35 и ↓4" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_small">+31</span></div> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">3.7K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    54
  </span></button> <div title="Читать комментарии" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/ru/company/funcorp/blog/579542/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value">
      8
    </span></a> <!----></div> <!----> <DIV class="v-portal" style="display:none;"></DIV></div></article></li><li class="tm-article-list-block__item"><article class="tm-article-snippet-block-block tm-article-snippet-block-block_preview"><div class="tm-article-snippet-block__user-meta"><div class="tm-article-snippet-block__date"><time datetime="2021-09-26T22:35:26.000Z" title="2021-09-27, 01:35">сегодня в 01:35</time></div></div> <h2 class="tm-article-title tm-article-title_block"><a href="/ru/post/580094/" class="tm-article-title__link"><span>Блокчейн нас подвёл? Почему ДЭГ — это плохо и можем ли мы адекватно контролировать процесс подсчёта голосов?</span></a></h2> <div class="tm-data-icons"><!----> <div class="tm-votes-meter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_small"><title>Всего голосов 50: ↑39 и ↓11</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg> <span title="Всего голосов 50: ↑39 и ↓11" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_small">+28</span></div> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">13K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    23
  </span></button> <div title="Читать комментарии" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/ru/post/580094/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value">
      82
    </span></a> <!----></div> <!----> <DIV class="v-portal" style="display:none;"></DIV></div></article></li> <!----></ul></div> <!----></section> <!----> <!----></div></div></div> <div class="tm-page__sidebar"><div hl="ru" id="55272" class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/55272/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/55272/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"55272":{"id":"55272","timePublished":"2009-03-23T15:00:50+00:00","isCorporative":false,"lang":"ru","titleHtml":"Три парадигмы F#","leadData":{"textHtml":"\u003Ch2\u003EВведение\u003C\u002Fh2\u003E\u003Cbr\u003E\r\nВсе, кто так или иначе связан с .NET программированием знает, что уже в следующую версию Visual Studio будет встроен новый язык программирования — F#, который позиционируется как функциональный, чем сразу, так уж повелось, вызывает подозрения в бесполезности. Для того, чтобы показать, что F# — куда больше, чем просто ФЯП (хотя и просто ФЯП — это очень немало), я и написал все нижеследующее.\u003Cbr\u003E\r\nЭта статья, несмотря на изрядную длину, не претендует на то, чтобы полностью описать всю функциональность языка. Это всего лишь краткий обзор, призванный продемонстрировать широкий спектр возможностей, каждая из которых заслуживает отдельной статьи, и даже не одной. \u003Cbr\u003E\r\nКроме того, написав такой пространный пост, я хотел сделать задел на будущее, чтобы в дальнейшем мне не отвлекаться на незначительные вещи базового уровня. Конечно, сразу головой в пруд — это действенно, но и какой-никакой фундамент не помешает. \u003Cbr\u003E\r\nА уже в следующий раз я приведу пример на волнующую тему пригодности F# для обычной профессиональной программистской деятельности.\u003Cbr\u003E\r\nИ еще раз, под катом действительно МНОГО текста. И не говорите потом, что я вас не предупреждал. =)\u003Cbr\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше →","image":null},"editorVersion":"1.0","postType":"article","postLabels":[],"author":{"scoreStats":{"score":64,"votesCount":124},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"36425","alias":"Meroving","fullname":"Дмитрий Ейбоженко","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Ffec\u002Fc12\u002Ffb5\u002Ffecc12fb5c667b1fa4aac44040d7f2c9.jpg","speciality":null},"statistics":{"commentsCount":68,"favoritesCount":85,"readingCount":18742,"score":37,"votesCount":43},"hubs":[{"relatedData":null,"id":"359","alias":"programming","type":"collective","title":"Программирование","titleHtml":"Программирование","isProfiled":true},{"relatedData":null,"id":"21364","alias":"fsharp","type":"collective","title":"F#","titleHtml":"F#","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Ch2\u003EВведение\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nВсе, кто так или иначе связан с .NET программированием знает, что уже в следующую версию Visual Studio будет встроен новый язык программирования — F#, который позиционируется как функциональный, чем сразу, так уж повелось, вызывает подозрения в бесполезности. Для того, чтобы показать, что F# — куда больше, чем просто ФЯП (хотя и просто ФЯП — это очень немало), я и написал все нижеследующее.\u003Cbr\u002F\u003E\r\nЭта статья, несмотря на изрядную длину, не претендует на то, чтобы полностью описать всю функциональность языка. Это всего лишь краткий обзор, призванный продемонстрировать широкий спектр возможностей, каждая из которых заслуживает отдельной статьи, и даже не одной. \u003Cbr\u002F\u003E\r\nКроме того, написав такой пространный пост, я хотел сделать задел на будущее, чтобы в дальнейшем мне не отвлекаться на незначительные вещи базового уровня. Конечно, сразу головой в пруд — это действенно, но и какой-никакой фундамент не помешает. \u003Cbr\u002F\u003E\r\nА уже в следующий раз я приведу пример на волнующую тему пригодности F# для обычной профессиональной программистской деятельности.\u003Cbr\u002F\u003E\r\nИ еще раз, под катом действительно МНОГО текста. И не говорите потом, что я вас не предупреждал. =)\u003Cbr\u002F\u003E\r\n\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EF# функциональный\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nКонечно, в первую очередь F# — функциональный язык, а значит именно поддержка функциональной парадигмы в нем реализована наиболее полно. Как известно, много ключевых слов и литералов в нем заимствовано из OCaml, что неудивительно, так как Дон Сайм (Don Syme), главный создатель F# когда-то приложил руку и к OCaml. \u003Cbr\u002F\u003E\r\nМного знаний о F#, как о чистом функциональном языке программирования читатель мог почерпнуть уже из прошлых моих постов, однако исключительно ради того, чтобы создать полное впечатление о языке, я кратко повторю все их еще раз.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EИдентификаторы, ключевые слова, функции.\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nИтак, F#, как ни странно, позволяет программисту определять идентификаторы, с помощью которых можно будет в последствии обращаться к функциям. Делается это с помощью ключевого слова \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E, за которым следует имя идентификатора, список параметров, а после знака равенства — выражения, определяющего функцию. Примерно так:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E k = 3.14\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E square x = x**2.0\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nВ отличие от императивного программирования, первое выражение определяет не переменную, а скорее константу, так как значение ее нельзя изменять во время выполнения программы. Вообще говоря, F# не делает различия между функциями и значениями — любая функция является значением, которое так же свободно можно передавать в качестве параметра.\u003Cbr\u002F\u003E\r\nСписок всех ключевых слов F# можно увидеть \u003Ca href=\"http:\u002F\u002Fstuff.mit.edu\u002Fafs\u002Fathena\u002Fsoftware\u002Ffsharp_v1.1.12\u002FFSharp-1.1.12.3\u002Fmanual\u002Flexyacc.html#Keywords\"\u003Eздесь\u003C\u002Fa\u003E. Слова из второго приведенного по ссылке списка не используются в данный момент, но зарезервированы на будущее. Их можно использовать, но компилятор при этом выдаст предупреждение.\u003Cbr\u002F\u003E\r\nF# поддерживает \u003Ca href=\"http:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%9A%D0%B0%D1%80%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5\"\u003Eкаррированные\u003C\u002Fa\u003E функции, в которые можно передавать не все параметры сразу:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E add a b = a + b \u003Cfont color=\"#A31515\"\u003E\u002F\u002F'a -\u003E 'a -\u003E 'a\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E addFour = add 4 \u003Cfont color=\"#A31515\"\u003E\u002F\u002F'a -\u003E 'a\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nВторой идентификатор задает функцию уже от одного свободного параметра, другой определен как 4. Это еще раз демонстрирует тезис, что функция есть значение. Поскольку функция — значение, то не получив полного набора параметров, она попросту возвращает другую функцию, которая тоже является значением.\u003Cbr\u002F\u003E\r\nОднако все функции из .NET не обладают свойством каррируемости, и для их применения в F# используются кортежи — наборы нескольких разнотипных значений. Кортеж может содержать множество различных параметров внутри себя, однако рассматривается F# как один параметр, и как следствие применяется только целиком. Записываются кортежи в круглых скобках, через запятую.\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E \u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E add (a,b) = a + b\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E addFour = add 4\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nТакой код не будет скомпилирован, так как по мнению F# мы пытаемся применить функцию к параметру несоответствующего типа, а именно int вместо 'a * 'b.\u003Cbr\u002F\u003E\r\nОднако следует помнить, что при разработке собственных функций, особенно тех, которые будут использоваться другими программистами, следует по возможности делать их каррируемыми, так как они очевидно обладают большей гибкостью в использовании.\u003Cbr\u002F\u003E\r\nКак я полагаю, читатель уже заметил, в F# в функциях не нужно явно определять возвращаемое значение. Однако при этом непонятно, как вычислять промежуточные значения внутри функции? Здесь F# использует способ, о существовании которого многие, думаю, успели подзабыть — с помощью пробелов. Внутренние вычисления в функции обычно отделяются четырьмя пробелами:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E midValue a b =\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E dif = b - a\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E mid = dif \u002F 2\u003Cbr\u002F\u003E\r\n        mid + a\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nКстати, если кого-то из видевших программы на F# удивляло постоянное присутствие в коде команды \u003Cfont color=\"#0000ff\"\u003E#light\u003C\u002Ffont\u003E, то один из ее эффектов как раз и заключается в том, что пробелы становятся важны. Это позволяет избежать использования множества ключевых слов и знаков, пришедших из OCaml, таких как \u003Cfont color=\"#0000ff\"\u003Ein\u003C\u002Ffont\u003E, ;;, \u003Cfont color=\"#0000ff\"\u003Ebegin\u003C\u002Ffont\u003E, \u003Cfont color=\"#0000ff\"\u003Eend\u003C\u002Ffont\u003E. \u003Cbr\u002F\u003E\r\nКаждый из идентфикаторов имеет свою область применения, которая начинается от места его определения (то есть применять его выше по коду, чем место его определения, нельзя), а заканчивается в конце секции, где он был определен. Например, промежуточные идентификаторы dif и mid из предыдущего примера не будут действовать за пределами функции midValue.\u003Cbr\u002F\u003E\r\nИдентификаторы, определенные внутри функций имеют некоторую особенность в сравнении с теми, что определены на внешнем уровне — они могут быть переопределены с помощью слова \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E. Это полезно, так как позволяет не изобретать все новые, и чаще всего мало что значащие имена для держания промежуточных значений. Например, в предыдущем примере мы могли бы написать так:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E midValue a b = \u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E k = b - a\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E k = k \u002F 2\u003Cbr\u002F\u003E\r\n        k + a\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nБолее того, поскольку это переопределение в полном смысле, а не изменение значения переменной, то мы вполне можем поменять не только значение идентификатора, но и его тип.\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E changingType () = \u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E k = 1\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E k = \u003Cfont color=\"#A31515\"\u003E\"string\"\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nF# позволяет в большинстве случаев обходиться вовсе без циклов за счет пакетных функций обработки последовательностей map, list, fold и.т.д., однако в тех случаях, где это необходимо, можно использовать рекурсию. Что легче для понимания, цикл или рекурсия — вопрос в целом открытый, на мой взгляд и то и другое вполне посильно. Для того, чтобы функция в F# могла обратиться к себе внутри своего определения, необходимо добавить после \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E ключевое слово \u003Cfont color=\"#0000ff\"\u003Erec\u003C\u002Ffont\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nF# является сильно типизированным языком, то есть нельзя использовать функции с значениями неподходящего типа. Функции, как и любые значения, имеют свой тип. F# во многих случаях сам выводит тип функции, при этом он может быть определен неоднозначно, например:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E square x = x*x\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E \u003Cbr\u002F\u003E\r\nимеет тип 'a \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E 'a, где 'a может быть int, float, и вообще говоря любым, для которого перегружен оператор *.\u003Cbr\u002F\u003E\r\nПри необходимости тип параметра функции можно задать самому (например, когда надо использовать методы класса):\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E parent (x:XmlNode) = x.ParentNode\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EЛямбды и операторы\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nF# поддерживает анонимные функции или лямбды, которые используются, если нет необходимости присваивать функции имя, когда она передается в качестве параметра для другой функции. Пример лямбды ниже:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    List.map (fun x \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E x**2) [1..10]\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nДанная функция выдаст список, состоящий из квадратов всех чисел от одного до десяти.\u003Cbr\u002F\u003E\r\nКроме того, в F# существует и еще один способ определения лямбды с помощью ключевого слова \u003Cfont color=\"#0000ff\"\u003Efunction\u003C\u002Ffont\u003E. Определенная таким образом лямбда может содержать внутри себя операцию сравнения с шаблоном (pattern matching), однако она принимает только один параметр. Но даже и в этом случае можно сохранить каррируемость функции:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Efunction\u003C\u002Ffont\u003E x \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E \u003Cfont color=\"#0000ff\"\u003Efunction\u003C\u002Ffont\u003E y \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E x + y\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nЛямбды в F# поддерживают \u003Ca href=\"http:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)\"\u003Eзамыкание\u003C\u002Fa\u003E, однако об этом будет подробнее рассказано во второй части обзора. \u003Cbr\u002F\u003E\r\nВ F# операторы (унарные и бинарные) можно рассматривать как более эстетичный способ вызова функций. Так же как и в C#, операторы перегружены, так что могут использоваться с различными типами, однако в отличие от C#, здесь нельзя применять оператор к операндам различного типа, то есть нельзя складывать строки с числами (и даже целые с вещественными), необходимо всегда делать приведение.\u003Cbr\u002F\u003E\r\nF# позволяет перегружать операторы, или определять собственные. \u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E (+) a b = a - b\u003Cbr\u002F\u003E\r\n    printfn \"%d\" (1 + 1) \u003Cfont color=\"#A31515\"\u003E\u002F\u002F \"0\"\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nОператоры могут являться любой последовательностью следующих символов !$%&amp;*+_.\u002F&lt;=\u003E?@^|~:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E (+:*) a b = (a + b) * a * b\u003Cbr\u002F\u003E\r\n    printfn \u003Cfont color=\"#A31515\"\u003E\"%d\"\u003C\u002Ffont\u003E (1 +:* 2) \u003Cfont color=\"#A31515\"\u003E\u002F\u002F \"6\"\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EИнициализация списков\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nЕще одной мощной техникой F# является инициализация списков, которая позволяет создавать достаточно сложные списки, массивы и последовательности (эквивалент IEnumerable) напрямую, с помощью использования специального синтаксиса. Списки задаются в прямоугольных скобках [ ], последовательности — в {}, массивы — в [| |].\u003Cbr\u002F\u003E\r\nПростейший способ — определение промежутка, который задается с использованием (..), например:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E lst = [1 .. 10]\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E seq = {\u003Cfont color=\"#A31515\"\u003E'a'\u003C\u002Ffont\u003E..\u003Cfont color=\"#A31515\"\u003E'z'\u003C\u002Ffont\u003E}\u003Cbr\u002F\u003E\r\n    \u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nТакже с помощью добавления еще одного (..) можно задавать шаг выбора в промежутке:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E lst = [1 .. 2 .. 10] \u003Cfont color=\"#A31515\"\u003E\u002F\u002F [1, 3, 5, 7, 9]\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nКроме того, при создании списков можно использовать циклы (циклы могут быть как одинарными, так и вложенными в любой степени)\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E lst = [for i \u003Cfont color=\"#0000ff\"\u003Ein\u003C\u002Ffont\u003E 1..10 \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E i*i] \u003Cfont color=\"#A31515\"\u003E\u002F\u002F [1, 4, 9,..]\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nОднако и это еще не все. При инициализации списков можно явно указывать, какие элементы заносить, с помощью операторов \u003Cfont color=\"#0000ff\"\u003Eyield\u003C\u002Ffont\u003E (добавляет в последовательность один элемент) и \u003Cfont color=\"#0000ff\"\u003Eyield!\u003C\u002Ffont\u003E (добавляет множество элементов), а также можно использовать любые логические конструкции, циклы, сравнения с шаблоном. Например, вот так выглядит создание последовательности имен всех файлов содержащихся в данной папке и во всех ее подпапках:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E \u003Cfont color=\"#0000ff\"\u003Erec\u003C\u002Ffont\u003E xamlFiles dir filter = \u003Cbr\u002F\u003E\r\n        seq { \u003Cfont color=\"#0000ff\"\u003Eyield!\u003C\u002Ffont\u003E Directory.GetFiles(dir, filter)\u003Cbr\u002F\u003E\r\n            \u003Cfont color=\"#0000ff\"\u003Efor\u003C\u002Ffont\u003E subdir \u003Cfont color=\"#0000ff\"\u003Ein\u003C\u002Ffont\u003E Directory.GetDirectories(dir) \u003Cfont color=\"#0000ff\"\u003Edo\u003C\u002Ffont\u003E \u003Cfont color=\"#0000ff\"\u003Eyield!\u003C\u002Ffont\u003E xamlFiles subdir filter}\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EСравнение с шаблоном\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nСравнение с шаблоном немного похоже на обычный условный оператор или switch, однако обладает намного большей функциональностью. В общем виде синтаксис операции выглядит так:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Ematch\u003C\u002Ffont\u003E идент \u003Cfont color=\"#0000ff\"\u003Ewith\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    [|]шаблон1|шаблон2|..|шаблон10 \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E вычисление1\u003Cbr\u002F\u003E\r\n    |шаблон11 \u003Cfont color=\"#0000ff\"\u003Ewhen\u003C\u002Ffont\u003E условие1 \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E вычисление2\u003Cbr\u002F\u003E\r\n    ...\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nСравнение с шаблонами идет сверху вниз, так что не следует забывать о том, что более узкие шаблоны должны располагаться выше. Самый общий шаблон выглядит так: _ (нижнее подчеркивание), и означает, что нас не интересует значение идентификатора. Кроме того, сравнение с шаблоном должно быть полным (отсутствуют нерассмотренные возможности) и все вычисления должны выдавать результат одного и того же типа. \u003Cbr\u002F\u003E\r\nПростейший вид операции с шаблоном сравнивает идентификатор с некоторым значением (числовым, строковым) С помощью ключевого слова \u003Cfont color=\"#0000ff\"\u003Ewhen\u003C\u002Ffont\u003E к шаблону можно добавлять условие, так что вычисления будут выполняться \u003Cbr\u002F\u003E\r\nЕсли вместо значения подставляется другой идентификатор, то ему присваивается значение проверяемого идентификатора. \u003Cbr\u002F\u003E\r\nНаиболее часто используемые варианты сравнения с шаблоном — над кортежами и списками. Пусть x — кортеж вида (string*int), тогда возможно написать любой подобный шаблон:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Ematch\u003C\u002Ffont\u003E x \u003Cfont color=\"#0000ff\"\u003Ewith\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    | \u003Cfont color=\"#A31515\"\u003E\"Пупкин\"\u003C\u002Ffont\u003E, _ \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E \u003Cfont color=\"#A31515\"\u003E\"Здравствуй, Вася!\"\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    | _, i \u003Cfont color=\"#0000ff\"\u003Ewhen\u003C\u002Ffont\u003E i \u003E 200 \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E \u003Cfont color=\"#A31515\"\u003E\"Здравствуй, Дункан!\"\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    | name, age \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E sprintf \u003Cfont color=\"#A31515\"\u003E\"Здравствуйте %s, %d\"\u003C\u002Ffont\u003E name age\u003Cbr\u002F\u003E\r\n    | _ \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E \u003Cfont color=\"#A31515\"\u003E\"И вам тоже здрасте\"\u003C\u002Ffont\u003E \u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nЗаметьте, что если в шаблоне имеются идентификаторы, то они автоматически определятся соответствующими значениями, и в обработке можно использовать отдельно поля name и age. \u003Cbr\u002F\u003E\r\nТочно таким же образом обрабатывается список (который на самом деле и не список даже, а размеченное объединение (discriminated union), о которых речь ниже). Обычно шаблоны для списка ('a list) выглядят либо как [], если он пустой, либо head::tail где head имеет тип 'a, а tail — 'a list, однако возможны и другие варианты, например:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Ematch\u003C\u002Ffont\u003E lst \u003Cfont color=\"#0000ff\"\u003Ewith\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    |[x;y;z] \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E \u003Cfont color=\"#A31515\"\u003E\u002F\u002Flst содержит три элемента, причем они присвоятся идентификаторам x y z.\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    |1::2::3::tail \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E \u003Cfont color=\"#A31515\"\u003E\u002F\u002F lst начинается с [1,2,3] tail присвоится хвост списка\u003C\u002Ffont\u003E \u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nСпособность при сравнении с шаблоном передавать в идентификаторы значения так полезна, что в F# существует возможность такого присвоения напрямую, без использования шаблонного синтаксиса, вот так:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E (name, age) = x \u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nили даже так:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E (name, _) = x \u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nесли нас интересует только первый элемент кортежа.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EЗаписи\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nЗаписи (record) в F# аналогичны кортежам, с той разницей, что в них каждое поле имеет название. Определение записи заключается в фигурные скобки и разделяется точкой с запятой.\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Etype\u003C\u002Ffont\u003E org = { boss : string; tops :string list }\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E Microsoft = { boss = \u003Cfont color=\"#A31515\"\u003E\"Bill Gates\"\u003C\u002Ffont\u003E; tops = [\u003Cfont color=\"#A31515\"\u003E\"Steve Balmer\"\u003C\u002Ffont\u003E, \u003Cfont color=\"#A31515\"\u003E\"Paul Allen\"\u003C\u002Ffont\u003E]}\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nДоступ к полям записи осуществляется, как обычно, через точку. Записи могут имитировать классы, что будет показано ниже. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EРазмеченное объединение\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nЭтот тип в F# позволяет хранить данные, имеющие разную структуру и смысл. Например, вот такой тип:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Etype\u003C\u002Ffont\u003E Distance =\u003Cbr\u002F\u003E\r\n    |Meter \u003Cfont color=\"#0000ff\"\u003Eof\u003C\u002Ffont\u003E float\u003Cbr\u002F\u003E\r\n    |Feet \u003Cfont color=\"#0000ff\"\u003Eof\u003C\u002Ffont\u003E float\u003Cbr\u002F\u003E\r\n    |Mile \u003Cfont color=\"#0000ff\"\u003Eof\u003C\u002Ffont\u003E float\u003Cbr\u002F\u003E\r\n    \u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E d1 = Meter 10\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E d2 = Feet 65.5\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nХотя все три вида данных имеют один и тот же тип (что необязательно), они очевидно отличны по смыслу. Обработка размеченных объединений всегда осуществляется через сравнение с шаблоном.\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E        \u003Cfont color=\"#0000ff\"\u003Ematch\u003C\u002Ffont\u003E x \u003Cfont color=\"#0000ff\"\u003Ewith\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n        |Meter x \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E x\u003Cbr\u002F\u003E\r\n        |Feet x \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E x*3.28\u003Cbr\u002F\u003E\r\n        |Mile x \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E x*0.00062\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nКак уже говорилось, такой распространенный тип данных как список, является размеченным объединением. Неформальное его определение выглядит так:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Etype\u003C\u002Ffont\u003E a' list =\u003Cbr\u002F\u003E\r\n    |[]\u003Cbr\u002F\u003E\r\n    |:: \u003Cfont color=\"#0000ff\"\u003Eof\u003C\u002Ffont\u003E a' * List\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nКстати, как заметно из вышеприведенного примера, размеченные множества в F# можно параметризовать, на манер generic'ов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EF# императивный\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EТип unit\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nТип unit родственен типу void из C#. Если функция не принимает аргументов, то ее тип входа — unit, если она не возвращает никакого значения — ее тип выхода unit. Для функционального программирования функция, которая не принимает или не возвращает значение не представляет никакой ценности, однако в императивной парадигме она ценность имеет за счет побочных эффектов (например ввода-вывода) Единственное значение типа unit имеет вид (). Вот такая функция ничего не принимает и ничего не делает (unit -\u003E unit).\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E doNothingWithNothing () = ()\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nСкобки после названия означают, что это именно функция с пустым входом, а не значение. Как мы уже говорили функции являются значениями, но между функциональным и нефункциональным значением есть большая разница — второе вычисляется только однажды, а первое — при каждом вызове. \u003Cbr\u002F\u003E\r\nЛюбую функцию, возвращающую значение можно конвертировать в функцию, возвращающую тип unit с помощью функции ignore. Применяя ее, мы как бы сообщаем компилятору, что в данной функции нас интересует только побочный эффект, а не возвращаемое значение.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EКлючевое слово mutable\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nКак мы знаем, в общем случае, идентификаторы в F# можно определить каким-то значением, однако это значение нельзя изменить. Однако все-таки старые добрые императивные переменные бывают полезны, так что в F# предусмотрен механизм для создания и использования переменных. Для этого перед именем переменной надо написать ключевое слово \u003Cfont color=\"#0000ff\"\u003Emutable\u003C\u002Ffont\u003E, а изменять значение можно с помощью оператора \u003Cfont color=\"#0000ff\"\u003E&lt;-\u003C\u002Ffont\u003E.\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E \u003Cfont color=\"#0000ff\"\u003Emutable\u003C\u002Ffont\u003E i = 0\u003Cbr\u002F\u003E\r\n    i \u003Cfont color=\"#0000ff\"\u003E&lt;-\u003C\u002Ffont\u003E i + 1\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nОднако применение таких переменных ограничено, например их нельзя использовать во внутренних функциях, а также для замыкания в лямбдах. Такой код выдаст ошибку:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E mainFunc () = \u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E \u003Cfont color=\"#0000ff\"\u003Emutable\u003C\u002Ffont\u003E i = 0\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E subFunc () =\u003Cbr\u002F\u003E\r\n            i \u003Cfont color=\"#0000ff\"\u003E&lt;-\u003C\u002Ffont\u003E 1\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EТип ref\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nВ F# существует и другой способ определения переменных, с помощью типа \u003Cfont color=\"#0000ff\"\u003Eref\u003C\u002Ffont\u003E. Для этого всего лишь надо поставить ключевое слово \u003Cfont color=\"#0000ff\"\u003Eref\u003C\u002Ffont\u003E перед вычислениями, которые представляют значение идентификатора. \u003Cbr\u002F\u003E\r\nДля того, чтобы присвоить переменной другое значение используется до боли ностальгичный оператор :=, обращение же ко значению переменной осуществляется добавлением! перед именем переменной. \u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E i = \u003Cfont color=\"#0000ff\"\u003Eref\u003C\u002Ffont\u003E 0\u003Cbr\u002F\u003E\r\n    i := !i + 1\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nПожалуй данная нотация далеко не столь опрятна, как предыдущая, чего стоит только использование восклицательного знака для получения значения (для отрицания в F# существует ключевое слово not)\u003Cbr\u002F\u003E\r\nОднако в отличие от \u003Cfont color=\"#0000ff\"\u003Emutable\u003C\u002Ffont\u003E, у \u003Cfont color=\"#0000ff\"\u003Eref\u003C\u002Ffont\u003E типа нет ограничений на область действия, так что его можно использовать и во вложенных функциях, и в замыканиях. Такой код будет работать:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E i = \u003Cfont color=\"#0000ff\"\u003Eref\u003C\u002Ffont\u003E 2\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E lst = [1..10]\u003Cbr\u002F\u003E\r\n    List.map (fun x \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E x * !i) lst\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EМассивы\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nВ F# существуют массивы, которые являются изменяемым типом. Значения внутри массива можно переприсвоить, в отличие от значений в списках. Массивы задаются в таких скобках [| |], элементы в нем перечисляются через точку с запятой. Доступ к элементу массива осуществляется через .[ind], а присваивание — знакомым по работе с mutables оператором \u003Cfont color=\"#0000ff\"\u003E&lt;-\u003C\u002Ffont\u003E. Все функции для обработки массивов (практически аналогичные методам для обработки списков), находятся в классе Array.\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E arr = [|1; 2; 3|]\u003Cbr\u002F\u003E\r\n    arr.[0] \u003Cfont color=\"#0000ff\"\u003E&lt;-\u003C\u002Ffont\u003E 10 \u002F\u002F [|10,2,3|]\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nМассивы можно инициализировать точно таким же способом, как и списки, используя .., yield и.т.п.\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E        \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E squares = [| \u003Cfont color=\"#0000ff\"\u003Efor\u003C\u002Ffont\u003E x \u003Cfont color=\"#0000ff\"\u003Ein\u003C\u002Ffont\u003E 1..9 \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E x,x*x |] \u002F\u002F [| (1,1);(2,4);...;(9,81) |]\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nТакже F# позволяет создавать многомерные массивы, как «ступенчатые» (с подмассивами разной длины), так и «монолитные».\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EУправляющая логика\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nВ F# можно использовать привычную императивную управляющую логику — условный оператор \u003Cfont color=\"#0000ff\"\u003Eif\u003C\u002Ffont\u003E… \u003Cfont color=\"#0000ff\"\u003Ethen\u003C\u002Ffont\u003E… \u003Cfont color=\"#0000ff\"\u003Eelse\u003C\u002Ffont\u003E, а также циклы \u003Cfont color=\"#0000ff\"\u003Efor\u003C\u002Ffont\u003E и \u003Cfont color=\"#0000ff\"\u003Ewhile\u003C\u002Ffont\u003E. \u003Cbr\u002F\u003E\r\nСледует помнить о том, что оператор \u003Cfont color=\"#0000ff\"\u003Eif\u003C\u002Ffont\u003E тоже можно рассматривать как функцию, а значит она должна при любом условии выдавать значение одного и того же типа. Это к тому же предполагает, что использование \u003Cfont color=\"#0000ff\"\u003Eelse\u003C\u002Ffont\u003E обязательно. На самом деле, есть одно исключение — когда вычисления при выполненном условии возвращают тип unit:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Eif\u003C\u002Ffont\u003E System.DateTime.Now.DayOfWeek = System.DayOfWeek.Sunday \u003Cfont color=\"#0000ff\"\u003Ethen\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n        printfn \u003Cfont color=\"#A31515\"\u003E\"Хороших выходных!\"\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    printfn \u003Cfont color=\"#A31515\"\u003E\"Каждый день замечателен!\"\u003C\u002Ffont\u003E \u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nДля определения, какие функции относятся к циклу, какие нет, также используются сдвиги. Например, в верхнем примере второе предложение будет выведено независимо от дня недели.\u003Cbr\u002F\u003E\r\nЦикл \u003Cfont color=\"#0000ff\"\u003Efor\u003C\u002Ffont\u003E в F# имеет тип unit, так что вычисления в теле цикла должны выдавать этот тип, иначе компилятор выдаст предупреждение.\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E arr = [|1..10|]\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Efor\u003C\u002Ffont\u003E i = 0 \u003Cfont color=\"#0000ff\"\u003Eto\u003C\u002Ffont\u003E Array.length arr - 1 \u003Cfont color=\"#0000ff\"\u003Edo\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n        printfn arr.[i]\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nЕсли хочется пройтись в обратную сторону, то \u003Cfont color=\"#0000ff\"\u003Eto\u003C\u002Ffont\u003E заменяется на \u003Cfont color=\"#0000ff\"\u003Edownto\u003C\u002Ffont\u003E, как в старые добрые времена.\u003Cbr\u002F\u003E\r\nТакже можно использовать другую форму цикла \u003Cfont color=\"#0000ff\"\u003Efor\u003C\u002Ffont\u003E, аналогичную всем знакомому foreach:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Efor\u003C\u002Ffont\u003E item \u003Cfont color=\"#0000ff\"\u003Ein\u003C\u002Ffont\u003E arr\u003Cbr\u002F\u003E\r\n        print_any item\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nЦикл \u003Cfont color=\"#0000ff\"\u003Ewhile\u003C\u002Ffont\u003E также вполне обычен и знаком для императивного программиста, тело его располагается между ключевыми словам \u003Cfont color=\"#0000ff\"\u003Edo\u003C\u002Ffont\u003E и \u003Cfont color=\"#0000ff\"\u003Edone\u003C\u002Ffont\u003E, но второе можно опционально опускать, используя систему сдвигов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EВызов статических методов и объектов из библиотек .NET\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nВ F# можно использовать весь набор инструментов .NET, однако очевидно, что все методы, написанные не под F# не обладают свойством каррируемости, так что аргументы им надо задавать в виде кортежа, соответствующего по типу набору входных элементов. При этом запись вызова не будет ни на йоту отличаться от сишарпной:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003E#light\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Eopen\u003C\u002Ffont\u003E System.IO\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Eif\u003C\u002Ffont\u003E File.Exists(\u003Cfont color=\"#A31515\"\u003E\"file.txt\"\u003C\u002Ffont\u003E) \u003Cfont color=\"#0000ff\"\u003Ethen\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n        printf \u003Cfont color=\"#A31515\"\u003E\"Есть такой файл!\"\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nОднако, если вам так уж хочется, чтобы .NET метод обладал бы каррируемостью, его надо импортировать, примерно следующим образом:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E exists file = File.Exists(file)\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nИспользовать объекты так же просто — они создаются с помощью ключевого слова \u003Cfont color=\"#0000ff\"\u003Enew\u003C\u002Ffont\u003E (кто бы мог подумать?), и применением соответствующего кортежа параметров конструктора. Объект можно присвоить идентификатору с помощью \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E. вызов методов аналогичен статическим, поля изменяются с помощью \u003Cfont color=\"#0000ff\"\u003E&lt;-\u003C\u002Ffont\u003E.\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003E#light\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E file = \u003Cfont color=\"#0000ff\"\u003Enew\u003C\u002Ffont\u003E FileInfo(\u003Cfont color=\"#A31515\"\u003E\"file.txt\"\u003C\u002Ffont\u003E)\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Eif\u003C\u002Ffont\u003E not file.Exists \u003Cfont color=\"#0000ff\"\u003Ethen\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n        using (file.CreateText()) (fun stream \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n            stream.WriteLine(\u003Cfont color=\"#A31515\"\u003E\"Hello world\"\u003C\u002Ffont\u003E))\u003Cbr\u002F\u003E\r\n    file.Attributes \u003Cfont color=\"#0000ff\"\u003E&lt;-\u003C\u002Ffont\u003E FileAttributes.ReadOnly\u003Cbr\u002F\u003E\r\n    \u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nF# позволяет инициализировать поля сразу при создании объекта, вот таким образом:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E        \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E file = \u003Cfont color=\"#0000ff\"\u003Enew\u003C\u002Ffont\u003E FileInfo(\u003Cfont color=\"#A31515\"\u003E\"file.txt\"\u003C\u002Ffont\u003E, Attributes = FileAttributes.ReadOnly)\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EИспользование событий в F#\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nУ каждого события в F# существует метод Add, который добавляет функцию обработчика к событию. Функция обработчика должна иметь тип 'a \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E unit. Вот как можно подписаться на событие таймера:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003E#light\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Eopen\u003C\u002Ffont\u003E System.Timers\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E timer = \u003Cfont color=\"#0000ff\"\u003Enew\u003C\u002Ffont\u003E Timer(Interval=1000, Enabled=true)\u003Cbr\u002F\u003E\r\n    timer.Elapsed.Add(fun _ \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E printfn \u003Cfont color=\"#A31515\"\u003E\"Timer tick!\"\u003C\u002Ffont\u003E)\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nОтписка от события производится с помощью метода Remove.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EОператор |\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nПересылающий оператор |\u003E определяется следующим образом:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E (|\u003E) f g = g f\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nОн передает первый аргумент в качестве параметра второму аргументу. Второй аргумент, разумеется должен быть функцией, которая в качестве единственного параметра принимает значение типа f. Кстати, именно из-за возможности использования с пересылающим оператором все функции над списками (iter, map, fold) принимают сам список последним. Тогда в качестве g можно использовать недоопределенную функцию:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    [1..10] |\u003E List.iter (fun i \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E print_int i)\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nНапример, функция iter имеет вид ('a list \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E unit) \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E 'a list \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E unit, задав лямбдой первый параметр мы получаем функцию типа 'a list \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E unit, которая как раз принимает в качестве аргумента определенный до оператора список. \u003Cbr\u002F\u003E\r\nВ программах зачастую применяются длинные цепи пересылающих операторов, каждый из которых обрабатывает значение, полученное предыдущим, этакий конвеер.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EF# объектно-ориентированный\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nДумаю, мало кто готов поспорить с тем, что именно объектно-ориентированная парадигма на сегодняшний день является флагманом программирования, и конечно же, F# не мог проигнорировать заложенные в нем концепции. Посмотрим, что же он нам предлагает.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EТипизация.\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nВ F# имеется возможность явно изменять статический типа значения. У F# для приведения вверх и вниз используются два разных оператора. Приведение вверх, то есть присвоение статическому типу значения типа одного из его предков, осуществляется оператором :\u003E. Значение strObj в нижнем примере будет иметь тип object.\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E \u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E strObj = (\u003Cfont color=\"#A31515\"\u003E\"Тили-тили, трали-вали\"\u003C\u002Ffont\u003E :\u003E obj)\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nПрисвоение вниз, то есть уточнение типа значения типом одного из его потомков, осуществляется оператором :?\u003E.\u003Cbr\u002F\u003E\r\nДля проверки типа значения (аналог is из C#) служит оператор :?, который можно использовать не только в логических конструкциях, но и при сравнении с шаблоном.\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Ematch\u003C\u002Ffont\u003E x \u003Cfont color=\"#0000ff\"\u003Ewith\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    |:? string \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E printf \u003Cfont color=\"#A31515\"\u003E\"Это строка!\"\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    |:? int \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E printf \u003Cfont color=\"#A31515\"\u003E\"Это целое!\"\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    |:? obj \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E printf \u003Cfont color=\"#A31515\"\u003E\"Неизвестно что!\"\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    \u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nОбычно F# не берет при вычислении функций в расчет иерархию наследования типов, то есть не позволяет применять в качестве аргумента тип-наследник. Например такая программа не скомпилируется:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E showForm (form:Form) =\u003Cbr\u002F\u003E\r\n        form.Show()\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E ofd = \u003Cfont color=\"#0000ff\"\u003Enew\u003C\u002Ffont\u003E OpenFileDialog();\u003Cbr\u002F\u003E\r\n    showForm ofd \u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nВ принципе, можно явно привести тип: showForm (ofd :\u003E Form), однако F# предоставляет и другой способ — добавить перед типом в сигнатуре функции знак решетки #.\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E showForm (form: #Form) = \u003Cbr\u002F\u003E\r\n        form.Show()\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nТаким образом определенная функция примет аргументом объект любого наследуемого от Form класса.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EЗаписи и обединения как объекты\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nВ записи и объединения можно добавить методы. Для этого после определения записи необходимо добавить ключевое слово \u003Cfont color=\"#0000ff\"\u003Ewith\u003C\u002Ffont\u003E, после определения всех методов написать \u003Cfont color=\"#0000ff\"\u003Eend\u003C\u002Ffont\u003E, а перед идентификатором каждого метода использовать ключевое слово \u003Cfont color=\"#0000ff\"\u003Emember\u003C\u002Ffont\u003E:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Etype\u003C\u002Ffont\u003E Point ={\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Emutable\u003C\u002Ffont\u003E x: int;\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Emutable\u003C\u002Ffont\u003E y: int; }\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Ewith\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Emember\u003C\u002Ffont\u003E p.Swap() =\u003Cbr\u002F\u003E\r\n            \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E temp = p.x\u003Cbr\u002F\u003E\r\n            p.x \u003Cfont color=\"#0000ff\"\u003E&lt;-\u003C\u002Ffont\u003E p.y\u003Cbr\u002F\u003E\r\n            p.y \u003Cfont color=\"#0000ff\"\u003E&lt;-\u003C\u002Ffont\u003E temp\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Eend\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nЗаметьте, что параметр p, заданный перед именем метода используется внутри него для получения доступа к полям. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EКлассы и интерфейсы\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nКлассы в F# определяются с помощью ключевого слова \u003Cfont color=\"#0000ff\"\u003Etype\u003C\u002Ffont\u003E, за которым следует имя класса, знак равенства и ключевое слово \u003Cfont color=\"#0000ff\"\u003Eclass\u003C\u002Ffont\u003E. Завершается определение класса ключевым словом \u003Cfont color=\"#0000ff\"\u003Eend\u003C\u002Ffont\u003E. Для того, чтобы задать конструктор, необходимо в определение класса включить член с именем \u003Cfont color=\"#0000ff\"\u003Enew\u003C\u002Ffont\u003E.\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Etype\u003C\u002Ffont\u003E construct = \u003Cfont color=\"#0000ff\"\u003Eclass\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Enew\u003C\u002Ffont\u003E () = {}\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Eend\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E inst = \u003Cfont color=\"#0000ff\"\u003Enew\u003C\u002Ffont\u003E construct()\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nОбратите внимание, что определение класса должно содержать в себе хотя бы один конструктор, иначе код не скомпилируется! F# не предоставляет конструктора по умолчанию, как C#.\u003Cbr\u002F\u003E\r\nЧтобы определить поле, необходимо добавить перед его именем ключевое слово \u003Cfont color=\"#0000ff\"\u003Eval\u003C\u002Ffont\u003E.\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Etype\u003C\u002Ffont\u003E File = \u003Cfont color=\"#0000ff\"\u003Eclass\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Eval\u003C\u002Ffont\u003E path: string\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Eval\u003C\u002Ffont\u003E info : FileInfo\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Enew\u003C\u002Ffont\u003E () = \u003Cfont color=\"#0000ff\"\u003Enew\u003C\u002Ffont\u003E File(\u003Cfont color=\"#A31515\"\u003E\"default.txt\"\u003C\u002Ffont\u003E)\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Enew\u003C\u002Ffont\u003E (path) = \u003Cbr\u002F\u003E\r\n            { path = path;\u003Cbr\u002F\u003E\r\n             info = \u003Cfont color=\"#0000ff\"\u003Enew\u003C\u002Ffont\u003E FileInfo(path) }\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Eend\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E file1 = \u003Cfont color=\"#0000ff\"\u003Enew\u003C\u002Ffont\u003E File(\u003Cfont color=\"#A31515\"\u003E\"sample.txt\"\u003C\u002Ffont\u003E)\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nКак видите, конструкторы можно совершенно привычным образом перегружать. Конструктор не может оставить некоторое поле неинициализированным, иначе код не будет скомпилирован. Заметьте, что в конструкторах можно только инициализировать поля или вызывать другие конструкторы. Чтобы задать в конструкторе дополнительные операции, необходимо дописать после него \u003Cfont color=\"#0000ff\"\u003Ethen\u003C\u002Ffont\u003E, после которого записать все дополнительные вычисления:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Enew\u003C\u002Ffont\u003E (path) \u003Cfont color=\"#0000ff\"\u003Eas\u003C\u002Ffont\u003E x =\u003Cbr\u002F\u003E\r\n        { path = path;\u003Cbr\u002F\u003E\r\n         info = \u003Cfont color=\"#0000ff\"\u003Enew\u003C\u002Ffont\u003E FileInfo(path) }\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Ethen\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Eif\u003C\u002Ffont\u003E not x.info.Exists \u003Cfont color=\"#0000ff\"\u003Ethen\u003C\u002Ffont\u003E printf \u003Cfont color=\"#A31515\"\u003E\"Нет файла!\"\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nПо умолчанию поля класса неизменяемы, чтобы сделать некоторое поле изменяемым, необходимо добавить перед его именем \u003Cfont color=\"#0000ff\"\u003Emutable\u003C\u002Ffont\u003E.\u003Cbr\u002F\u003E\r\nИнтерфейс в F# задается и имплементируется следуюшим образом:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E ISampleInterface = interface\u003Cbr\u002F\u003E\r\n        abstract Change : newVal : int \u003Cfont color=\"#0000ff\"\u003E-\u003E\u003C\u002Ffont\u003E unit\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Eend\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    \u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Etype\u003C\u002Ffont\u003E SampleClass = \u003Cfont color=\"#0000ff\"\u003Eclass\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Eval\u003C\u002Ffont\u003E \u003Cfont color=\"#0000ff\"\u003Emutable\u003C\u002Ffont\u003E i : int\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Enew\u003C\u002Ffont\u003E () = { i = 0}\u003Cbr\u002F\u003E\r\n        interface ISampleInterface \u003Cfont color=\"#0000ff\"\u003Ewith\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n            \u003Cfont color=\"#0000ff\"\u003Emember\u003C\u002Ffont\u003E x.Change y = x.i \u003Cfont color=\"#0000ff\"\u003E&lt;-\u003C\u002Ffont\u003E y\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Eend\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Eend\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nF# предлагает еще один элегантный способ определения класса — неявное задание. Сразу после названия класса перечисляются входные параметры, которые в ином случае входили бы в аргументы конструктора. Конструирование класса происходит прямо в его теле, с помощью последовательности let, предшествующих определению методов. Все таким образом определенные идентификаторы будут приватны для класса. Поля и методы класса задаются с помощью ключевого слова \u003Cfont color=\"#0000ff\"\u003Emember\u003C\u002Ffont\u003E. Лучше сразу посмотреть пример:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Etype\u003C\u002Ffont\u003E Counter (start, inc, length) = \u003Cfont color=\"#0000ff\"\u003Eclass\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E finish = start + length\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E \u003Cfont color=\"#0000ff\"\u003Emutable\u003C\u002Ffont\u003E current = start\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Emember\u003C\u002Ffont\u003E c.Current = current\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Emember\u003C\u002Ffont\u003E c.Inc () =\u003Cbr\u002F\u003E\r\n            \u003Cfont color=\"#0000ff\"\u003Eif\u003C\u002Ffont\u003E current \u003E finish \u003Cfont color=\"#0000ff\"\u003Ethen\u003C\u002Ffont\u003E failwith \u003Cfont color=\"#A31515\"\u003E\"Динь-дилинь!\"\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n            current \u003Cfont color=\"#0000ff\"\u003E&lt;-\u003C\u002Ffont\u003E current + inc\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Eend\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E count = \u003Cfont color=\"#0000ff\"\u003Enew\u003C\u002Ffont\u003E Counter(0, 5, 100)\u003Cbr\u002F\u003E\r\n        count.Inc()\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nF# как и C# поддерживает только одиночное наследование, и имплементацию нескольких интерфейсов. Наследование задается с помощью ключевого слова \u003Cfont color=\"#0000ff\"\u003Einherit\u003C\u002Ffont\u003E которое идет сразу после \u003Cfont color=\"#0000ff\"\u003Eclass\u003C\u002Ffont\u003E:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E \u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Etype\u003C\u002Ffont\u003E Base = \u003Cfont color=\"#0000ff\"\u003Eclass\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Eval\u003C\u002Ffont\u003E state : int\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Enew\u003C\u002Ffont\u003E () = {state = 0}\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Eend\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n    \u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Etype\u003C\u002Ffont\u003E Sub = \u003Cfont color=\"#0000ff\"\u003Eclass\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Einherit\u003C\u002Ffont\u003E Base\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Eval\u003C\u002Ffont\u003E otherState : int\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Enew\u003C\u002Ffont\u003E () = {otherState = 0}\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Eend\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nНет необходимости вызывать явно базовый пустой конструктор. При вызове любого конструктора потомка автоматически вызовется пустой конструктор предка. Если такого конструктора в предке нет, необходимо явно вызвать в теле конструктора потомка базовый конструктор с помощью ключевого слова \u003Cfont color=\"#0000ff\"\u003Einherit\u003C\u002Ffont\u003E.\u003Cbr\u002F\u003E\r\nСвойства в F# определяются следующим образом:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Etype\u003C\u002Ffont\u003E PropertySample = \u003Cfont color=\"#0000ff\"\u003Eclass\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Elet\u003C\u002Ffont\u003E \u003Cfont color=\"#0000ff\"\u003Emutable\u003C\u002Ffont\u003E field = 0\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Emember\u003C\u002Ffont\u003E x.Property \u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Ewith\u003C\u002Ffont\u003E get () = field\u003Cbr\u002F\u003E\r\n        and set v = field \u003Cfont color=\"#0000ff\"\u003E&lt;-\u003C\u002Ffont\u003E rand\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Eend\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nДля определения статических полей перед \u003Cfont color=\"#0000ff\"\u003Emember\u003C\u002Ffont\u003E добавляется ключевое слово \u003Cfont color=\"#0000ff\"\u003Estatic\u003C\u002Ffont\u003E и убирается параметр, обзначающий экземпляр класса:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ccode\u003E\u003Cfont color=\"black\"\u003E    \u003Cfont color=\"#0000ff\"\u003Etype\u003C\u002Ffont\u003E StaticSample = \u003Cfont color=\"#0000ff\"\u003Eclass\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n        \u003Cfont color=\"#0000ff\"\u003Estatic\u003C\u002Ffont\u003E \u003Cfont color=\"#0000ff\"\u003Emember\u003C\u002Ffont\u003E TrimString (st:string) = st.Trim()\u003Cbr\u002F\u003E\r\n    \u003Cfont color=\"#0000ff\"\u003Eend\u003C\u002Ffont\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Ffont\u003E\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EЗаключение\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСегодня мы кратко рассмотрели большинство базовых возможностей языка, и можно на основании увиденного сделать какие-то выводы. \u003Cbr\u002F\u003E\r\nЧто ж, по сути, любая операция с классами и переменными, доступная в C#, может быть выполнена и в F#, так что этот язык ничуть не менее объектно-ориентирован, чем его старший брат. Синтаксис в нем возможно и сложнее, но не критически, и как кажется, всего лишь вопрос привычки. С другой стороны, в функциональном плане F#, как и следовало ожидать (на самом деле следует ожидать еще больше, поскольку здесь была описана\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"fsharp"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F55272\u002F22d5b53406eed729bca715f8054ef09c\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F55272\u002F22d5b53406eed729bca715f8054ef09c\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F55272\\\u002F\"},\"headline\":\"Три парадигмы F#\",\"datePublished\":\"2009-03-23T18:00:50+03:00\",\"dateModified\":\"2018-02-12T15:34:58+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Дмитрий Ейбоженко\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Введение Все, кто так или иначе связан с .NET программированием знает, что уже в следующую версию Visual Studio будет встроен новый язык программирования &mdash; F#, к...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F55272\\\u002F#post-content-body\",\"about\":[\"h_programming\",\"h_fsharp\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F55272\\\u002F22d5b53406eed729bca715f8054ef09c\\\u002F\"]}","metaDescription":"Введение\r\nВсе, кто так или иначе связан с .NET программированием знает, что уже в следующую версию Visual Studio будет встроен новый язык программирования — F#, который позиционируется как...","mainImageUrl":null,"amp":false},"polls":[],"commentsEnabled":true,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false},"578296":{"id":"578296","timePublished":"2021-09-26T14:00:02+00:00","isCorporative":true,"lang":"ru","titleHtml":"Вектор? Растр? А может — и то, и другое?","editorVersion":"1.0","postType":"article","postLabels":[{"type":"translation","data":{"originalAuthorName":"Zach Leatherman","originalUrl":"https:\u002F\u002Fwww.zachleat.com\u002Fweb\u002Fvector-raster-split\u002F"}}],"author":{"id":"1220775","alias":"ru_vds","fullname":null,"avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fe36\u002F812\u002Fd3d\u002Fe36812d3de38eb3d479d7a13228717ef.png","speciality":"Пользователь"},"statistics":{"commentsCount":8,"favoritesCount":32,"readingCount":2775,"score":25,"votesCount":27},"hubs":[{"relatedData":null,"id":"19791","alias":"ruvds","type":"corporative","title":"Блог компании RUVDS.com","titleHtml":"Блог компании RUVDS.com","isProfiled":false},{"relatedData":null,"id":"449","alias":"vector_graphics","type":"collective","title":"Работа с векторной графикой","titleHtml":"Работа с векторной графикой","isProfiled":true},{"relatedData":null,"id":"8880","alias":"server_side_optimization","type":"collective","title":"Серверная оптимизация","titleHtml":"Серверная оптимизация","isProfiled":true},{"relatedData":null,"id":"17175","alias":"image_processing","type":"collective","title":"Обработка изображений","titleHtml":"Обработка изображений","isProfiled":true},{"relatedData":null,"id":"19802","alias":"graph_design","type":"collective","title":"Графический дизайн","titleHtml":"Графический дизайн","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"2","alias":"design","title":"Дизайн"},{"id":"6","alias":"admin","title":"Администрирование"}],"relatedData":null,"leadData":{"textHtml":"На этой неделе я столкнулся с интересным классом задач, для решения которых, как я теперь понимаю, можно было использовать гораздо более удачный подход и раньше. Но существует ли такой подход?\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fruvds\u002Fblog\u002F578296\u002F\"\u003E\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fge\u002Fkf\u002F1n\u002Fgekf1nauxn50imhrqyil4rlzj5m.jpeg\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fa\u003E\u003Cbr\u003E\r\n\u003Ci\u003E\u003Cfont color=\"#999999\"\u003EИзображение для верхней части сайта\u003C\u002Ffont\u003E\u003C\u002Fi\u003E\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nРечь идёт о подготовке изображения, рассчитанного на использовании в верхней правой части сайта \u003Ca href=\"https:\u002F\u002Fjamstackconf.com\" rel=\"nofollow noopener noreferrer\"\u003Ejamstackconf.com\u003C\u002Fa\u003E. Мы, в маркетинговой команде Netlify, используем Figma. Первая моя попытка экспорта этого изображения для использования его на сайте оказалась далеко не самой удачной.\u003Cbr\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"графика"},{"titleHtml":"веб-разработка"},{"titleHtml":"ruvds_перевод"}]},"579542":{"id":"579542","timePublished":"2021-09-26T19:00:02+00:00","isCorporative":true,"lang":"ru","titleHtml":"Jetpack Compose — как легко построить UI на Android","editorVersion":"2.0","postType":"article","postLabels":[],"author":{"id":"2713395","alias":"i15in","fullname":"Иван","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F25f\u002Fe4b\u002Ff94\u002F25fe4bf94867d9647a0ae809abf2e429.jpg","speciality":"Android developer"},"statistics":{"commentsCount":8,"favoritesCount":54,"readingCount":3710,"score":31,"votesCount":39},"hubs":[{"relatedData":null,"id":"18232","alias":"funcorp","type":"corporative","title":"Блог компании FUNCORP","titleHtml":"Блог компании FUNCORP","isProfiled":false},{"relatedData":null,"id":"6345","alias":"mobile_dev","type":"collective","title":"Разработка мобильных приложений","titleHtml":"Разработка мобильных приложений","isProfiled":true},{"relatedData":null,"id":"9188","alias":"ui","type":"collective","title":"Интерфейсы","titleHtml":"Интерфейсы","isProfiled":true},{"relatedData":null,"id":"17107","alias":"android_dev","type":"collective","title":"Разработка под Android","titleHtml":"Разработка под Android","isProfiled":true},{"relatedData":null,"id":"19441","alias":"kotlin","type":"collective","title":"Kotlin","titleHtml":"Kotlin","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"2","alias":"design","title":"Дизайн"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EВ июле этого года вместе с Android Studio Arctic Fox вышла одна из долгожданных библиотек — Jetpack Compose. Она позволяет создавать пользовательский интерфейс в декларативном стиле и обещает быть революцией в построении UI.\u003C\u002Fp\u003E\u003Cp\u003EРазбираемся, так ли это на самом деле, какие у библиотеки преимущества и недостатки. Подробности — в статье.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F5da\u002F63d\u002F3cb\u002F5da63d3cbeb8e38de3dde2792d851722.jpg","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F5da\u002F63d\u002F3cb\u002F5da63d3cbeb8e38de3dde2792d851722.jpg","fit":"cover","positionY":0,"positionX":0}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"разработка мобильных приложений"},{"titleHtml":"jetpack compose"},{"titleHtml":"ui"},{"titleHtml":"интерфейсы"},{"titleHtml":"android"},{"titleHtml":"kotlin"},{"titleHtml":"android studio"},{"titleHtml":"arctic fox"},{"titleHtml":"пользовательские интерфейсы"}]},"579772":{"id":"579772","timePublished":"2021-09-27T05:32:01+00:00","isCorporative":true,"lang":"ru","titleHtml":"Сливы процветают. Эксперт-«параноик» Майкл Баззель о защите личных данных","editorVersion":"2.0","postType":"article","postLabels":[{"type":"translation","data":{"originalAuthorName":"Michael Bazzell","originalUrl":"https:\u002F\u002Finteltechniques.com\u002Fblog\u002F2021\u002F07\u002F23\u002Fpersonal-ransomware-exposure\u002F"}}],"author":{"id":"2297567","alias":"SearchInform_team","fullname":null,"avatarUrl":"","speciality":"Пользователь"},"statistics":{"commentsCount":0,"favoritesCount":6,"readingCount":2036,"score":9,"votesCount":9},"hubs":[{"relatedData":null,"id":"22418","alias":"searchinform","type":"corporative","title":"Блог компании SearchInform","titleHtml":"Блог компании SearchInform","isProfiled":false},{"relatedData":null,"id":"50","alias":"infosecurity","type":"collective","title":"Информационная безопасность","titleHtml":"Информационная безопасность","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EНаш очередной пост из серии «интересное на иностранном языке» – рассказ Майкла Баззеля о том, как сберечь свои персональные данные от утечек. Майкл – знаковая фигура в сфере OSINT, работал в правительстве США и ФБР, его приглашали в качестве технического эксперта в сериал «Мистер Робот», который считают достойным с точки зрения достоверности. В личной жизни эксперт придерживается настолько жестких правил в отношении информационной гигиены, что некоторые считают его «неадекватом». Так ли это – может быть несколько мнений. \u003C\u002Fp\u003E\u003Cp\u003EОдин из факторов, который убеждает в правильном подходе Майкла, – что риски обнаружить свои данные в интернете стали существенно выше, потому что шифровальщики без разбору сливают в сеть все, до чего дотягиваются при атаках на бизнес. Приводим перевод \u003Ca href=\"https:\u002F\u002Finteltechniques.com\u002Fblog\u002F2021\u002F07\u002F23\u002Fpersonal-ransomware-exposure\u002F\"\u003Eпоста Майкла Баззеля\u003C\u002Fa\u003E. \u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EАтакуют корпорации, а страдают люди\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cp\u003EБольшинство людей не задумываются о том, как их касается проблема распространения вирусов-шифровальщиков. Логика такова: речь идет о проблемах компаний, это они вынуждены платить выкуп. При чем тут, казалось бы, обычные люди?! \u003C\u002Fp\u003E\u003Cp\u003EА при том, что преступники сменили тактику: сейчас они не просто шифруют данные, но и скачивают их, выкладывают в открытый доступ, если компании не платят им выкуп. Теперь давайте подумаем, что в этих слитых базах? Множество данных о сотрудниках, клиентах, контрагентах, с которыми компания-жертва работает.\u003C\u002Fp\u003E\u003Cp\u003EХочу сразу уточнить: я это пишу не потому что выступаю за уплату выкупа. Я за то, чтобы сопротивляться избыточному сбору данных там, где это не обязательно. Мы халатно относимся к своим ПДн, раздавая их по первому требованию.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fe3b\u002F3e1\u002F2c2\u002Fe3b3e12c2036d90018b804276e31ebea.png","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fe3b\u002F3e1\u002F2c2\u002Fe3b3e12c2036d90018b804276e31ebea.png","fit":"cover","positionY":0,"positionX":0}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"персональные данные"},{"titleHtml":"пдн"},{"titleHtml":"сёрчинформ"},{"titleHtml":"Майкл Баззел"},{"titleHtml":"утечки информации"}]},"579854":{"id":"579854","timePublished":"2021-09-27T06:03:01+00:00","isCorporative":true,"lang":"ru","titleHtml":"Видишь уязвимости? А они есть! Наше исследование популярных CMS-систем","editorVersion":"2.0","postType":"article","postLabels":[],"author":{"id":"2684283","alias":"Solar_Pentest","fullname":null,"avatarUrl":"","speciality":""},"statistics":{"commentsCount":8,"favoritesCount":16,"readingCount":2712,"score":25,"votesCount":27},"hubs":[{"relatedData":null,"id":"20826","alias":"solarsecurity","type":"corporative","title":"Блог компании Ростелеком-Солар","titleHtml":"Блог компании Ростелеком-Солар","isProfiled":false},{"relatedData":null,"id":"50","alias":"infosecurity","type":"collective","title":"Информационная безопасность","titleHtml":"Информационная безопасность","isProfiled":true},{"relatedData":null,"id":"260","alias":"php","type":"collective","title":"PHP","titleHtml":"PHP","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EЛьвиная доля всех работ по анализу защищенности внешнего периметра – это тестирование веб-приложений. Здесь могут быть как корпоративные решения, так и «домашние» разработки на базе различных публичных систем управления контентом (CMS). Мы всегда проводим глубокий анализ подобных решений на тестовых стендах и зачастую находим уязвимости нулевого дня. Собственно, из опыта таких проектов и родилась идея собрать исследовательскую команду и провести глубокий анализ популярных CMS-систем и различных плагинов для них. В этом посте мы поделимся результатами нашего исследования, а также продемонстрируем примеры уязвимого кода наиболее интересных, на наш взгляд, уязвимостей и примеры их эксплуатации. Конечно все эти уязвимости уже исправлены и описываются здесь с разрешения владельцев систем.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F6df\u002F317\u002F4e6\u002F6df3174e60bbe263a70bcafdf9e51e6b.jpg","buttonTextHtml":"Не всё то в безопасности, что с Bug Bounty","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F6df\u002F317\u002F4e6\u002F6df3174e60bbe263a70bcafdf9e51e6b.jpg","fit":"cover","positionY":0,"positionX":0}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"cms"},{"titleHtml":"уязвимости"},{"titleHtml":"уязвимости и их эксплуатация"},{"titleHtml":"уязвимость нулевого дня"}]},"580008":{"id":"580008","timePublished":"2021-09-27T06:30:02+00:00","isCorporative":false,"lang":"ru","titleHtml":"Летний Магнитогорск","editorVersion":"2.0","postType":"article","postLabels":[],"author":{"id":"2614609","alias":"city_scraper","fullname":null,"avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F8f8\u002Fd6c\u002F328\u002F8f8d6c328ec3a513103b6757c2c21610.png","speciality":"Пользователь"},"statistics":{"commentsCount":6,"favoritesCount":3,"readingCount":2954,"score":9,"votesCount":15},"hubs":[{"relatedData":null,"id":"22012","alias":"Ecology","type":"collective","title":"Экология","titleHtml":"Экология","isProfiled":false},{"relatedData":null,"id":"22024","alias":"urban","type":"collective","title":"Урбанизм","titleHtml":"Урбанизм","isProfiled":false}],"flows":[{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EМагнитогорск Челябинской области – один из крупнейших мировых центров чёрной металлургии. В России это шестой из крупнейших городов, которые не являются центрами субъектов страны. \u003C\u002Fp\u003E\u003Cp\u003EСовсем недавно город был одним из наиболее неблагополучных с точки зрения загрязнения атмосферного воздуха, но в 2021 году был зафиксирован «повышенный» уровень – то есть не «высокий» или «очень высокий», как раньше. \u003C\u002Fp\u003E\u003Cp\u003EКак этот город выглядит летом? Где и как его жители могут проводить время?\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F030\u002F0d1\u002Fcff\u002F0300d1cff2029948d33d803000331724.jpg","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F030\u002F0d1\u002Fcff\u002F0300d1cff2029948d33d803000331724.jpg","fit":"cover","positionY":0,"positionX":0}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"Магнитогорск"},{"titleHtml":"промышленность"},{"titleHtml":"промышленные города"},{"titleHtml":"урбанизм\u002Fурбания"},{"titleHtml":"урбанистика"},{"titleHtml":"города России"},{"titleHtml":"города"}]},"580048":{"id":"580048","timePublished":"2021-09-26T14:22:36+00:00","isCorporative":false,"lang":"ru","titleHtml":"Будь строже к себе: как ограничения помогают сделать код лучше","editorVersion":"2.0","postType":"article","postLabels":[{"type":"sandbox","data":null}],"author":{"id":"2787821","alias":"ZeBrains_team","fullname":"Станислав Маслов","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fae3\u002F3ee\u002F4f1\u002Fae33ee4f1a117aeeab42ec5a9e2eba25.jpg","speciality":"директор продакшена в IT-компании"},"statistics":{"commentsCount":10,"favoritesCount":51,"readingCount":4738,"score":8,"votesCount":16},"hubs":[{"relatedData":null,"id":"19583","alias":"dev_management","type":"collective","title":"Управление разработкой","titleHtml":"Управление разработкой","isProfiled":true},{"relatedData":null,"id":"20682","alias":"pm","type":"collective","title":"Управление проектами","titleHtml":"Управление проектами","isProfiled":true},{"relatedData":null,"id":"20726","alias":"productpm","type":"collective","title":"Управление продуктом","titleHtml":"Управление продуктом","isProfiled":true}],"flows":[{"id":"3","alias":"management","title":"Менеджмент"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003E\u003Cstrong\u003E\u003Cem\u003EЕсли вам приходилось задумываться о построении эффективной экосистемы проекта и определении ролей тимлида и разработчика — статья Артема Прозорова из ZeBrains для вас. \u003C\u002Fem\u003E\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cp\u003EПредлагаю вам задуматься над одним вопросом. Но не спешите с ответом, потому что он не так очевиден, как может показаться:\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EКакая из команд может реализовать более технически стабильный продукт?&nbsp;\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EКоманда №1:\u003C\u002Fstrong\u003E Проектный менеджер, аналитик, тестировщик и несколько разработчиков, у каждого из которых за плечами минимум три года опыта. Все работают в одном офисе, посвящая свое время одному проекту в режиме fulltime.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EКоманда №2:\u003C\u002Fstrong\u003E Один сильный разработчик. Ему помогают множество не знакомых между собой людей из разных часовых поясов. У каждого — свой набор компетенций и уровень опыта. Работой над проектом участники занимаются в свободном режиме, по несколько часов в неделю.\u003C\u002Fp\u003E\u003Cp\u003E* * *\u003C\u002Fp\u003E\u003Cp\u003EОтвет на этот вопрос получим к концу статьи.\u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fefe\u002F413\u002Feb2\u002Fefe413eb27c391cfcfef0484e6997aab.png","fit":"cover","positionY":0,"positionX":0}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"управление проектами"},{"titleHtml":"управление продуктом"},{"titleHtml":"управление командой разработки"},{"titleHtml":"управление командами разработчиков"},{"titleHtml":"тимлид"},{"titleHtml":"тимлиды и разработчики"}]},"580052":{"id":"580052","timePublished":"2021-09-26T15:29:26+00:00","isCorporative":false,"lang":"ru","titleHtml":"Почему экология не может быть плохой?","editorVersion":"2.0","postType":"article","postLabels":[],"author":{"id":"2568695","alias":"phanerozoi_evidence","fullname":"Фанерозой","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fdcc\u002F862\u002F561\u002Fdcc862561429f2ed85090ac53e39cf7d.jpg","speciality":"Биологи, врач, научный популяризатор, палеонтолог"},"statistics":{"commentsCount":47,"favoritesCount":28,"readingCount":5094,"score":8,"votesCount":28},"hubs":[{"relatedData":null,"id":"20742","alias":"read","type":"collective","title":"Читальный зал","titleHtml":"Читальный зал","isProfiled":false},{"relatedData":null,"id":"21910","alias":"popular_science","type":"collective","title":"Научно-популярное","titleHtml":"Научно-популярное","isProfiled":false},{"relatedData":null,"id":"22012","alias":"Ecology","type":"collective","title":"Экология","titleHtml":"Экология","isProfiled":false},{"relatedData":null,"id":"22750","alias":"biology","type":"collective","title":"Биология","titleHtml":"Биология","isProfiled":false}],"flows":[{"id":"3","alias":"management","title":"Менеджмент"},{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003E\u003Cem\u003EСо второй половины ХХ в мы всё чаще слышим из средств массовой информации выражения «плохая экология», «сохранить экологию», «экология строительных материалов». Но, к сожалению, не многие знают, что такое «экология» на самом деле. Для разгадки тайн экологии нам предстоит окунуться в удивительный мир науки...\u003C\u002Fem\u003E\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F9a4\u002Fecf\u002Fd11\u002F9a4ecfd1144e299873622d45d23d2ce0.png","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F9a4\u002Fecf\u002Fd11\u002F9a4ecfd1144e299873622d45d23d2ce0.png","fit":"cover","positionY":29.545454545455,"positionX":1.4102564102564}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"виды"},{"titleHtml":"охрана окружающей среды"},{"titleHtml":"мифы"},{"titleHtml":"экосистема"},{"titleHtml":"биогеоценоз"},{"titleHtml":"экология"},{"titleHtml":"экосистемы"},{"titleHtml":"биоценозы"},{"titleHtml":"биология"},{"titleHtml":"вирусы"}]},"580060":{"id":"580060","timePublished":"2021-09-27T09:00:04+00:00","isCorporative":true,"lang":"ru","titleHtml":"Арракис, который мы заслужили","editorVersion":"1.0","postType":"article","postLabels":[],"author":{"id":"238277","alias":"Zelenyikot","fullname":"Виталий Егоров","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F22b\u002F2d7\u002F7a5\u002F22b2d77a57b687aae24784a3e53089c9.jpg","speciality":"Популяризатор космонавтики"},"statistics":{"commentsCount":34,"favoritesCount":27,"readingCount":10851,"score":90,"votesCount":96},"hubs":[{"relatedData":null,"id":"19791","alias":"ruvds","type":"corporative","title":"Блог компании RUVDS.com","titleHtml":"Блог компании RUVDS.com","isProfiled":false},{"relatedData":null,"id":"21910","alias":"popular_science","type":"collective","title":"Научно-популярное","titleHtml":"Научно-популярное","isProfiled":false},{"relatedData":null,"id":"21962","alias":"space","type":"collective","title":"Космонавтика","titleHtml":"Космонавтика","isProfiled":false},{"relatedData":null,"id":"21984","alias":"sci-fi","type":"collective","title":"Научная фантастика","titleHtml":"Научная фантастика","isProfiled":false},{"relatedData":null,"id":"22014","alias":"futurenow","type":"collective","title":"Будущее здесь","titleHtml":"Будущее здесь","isProfiled":false}],"flows":[{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"leadData":{"textHtml":"\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fruvds\u002Fblog\u002F580060\u002F\"\u003E\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fk0\u002Fds\u002Fy5\u002Fk0dsy5npxclyjdytiroqga7-leu.jpeg\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fa\u003E\u003Cbr\u003E\r\nВо вселенной писателя-фантаста Фрэнка Герберта, Дюна, она же Арракис &mdash; это пустынная и маловодная планета с двумя лунами. По сюжету, она находится за пределами Солнечной системы, но если мы захотим поискать ближайшую схожую параллель,&nbsp;то больше всего подходит планета Марс. Предлагаю воспользоваться возможностями, которые даёт современная космонавтика, и совершить воображаемую прогулку на нашу Дюну.\u003Cbr\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"Марс"},{"titleHtml":"Дюна"},{"titleHtml":"MRO"},{"titleHtml":"Curiosity"},{"titleHtml":"марсоход"},{"titleHtml":"ruvds_статьи"}]},"580080":{"id":"580080","timePublished":"2021-09-26T19:12:55+00:00","isCorporative":false,"lang":"ru","titleHtml":"Дайджест свежих материалов из мира фронтенда за последнюю неделю №486 (20 — 26 сентября 2021)","editorVersion":"1.0","postType":"article","postLabels":[],"author":{"id":"59347","alias":"alexzfort","fullname":null,"avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fd2a\u002Fe8a\u002F5ac\u002Fd2ae8a5ac9876f838ebdd45f3ea3bc3b.png","speciality":""},"statistics":{"commentsCount":2,"favoritesCount":21,"readingCount":3416,"score":17,"votesCount":17},"hubs":[{"relatedData":null,"id":"91","alias":"webdev","type":"collective","title":"Разработка веб-сайтов","titleHtml":"Разработка веб-сайтов","isProfiled":true},{"relatedData":null,"id":"307","alias":"css","type":"collective","title":"CSS","titleHtml":"CSS","isProfiled":true},{"relatedData":null,"id":"357","alias":"javascript","type":"collective","title":"JavaScript","titleHtml":"JavaScript","isProfiled":true},{"relatedData":null,"id":"17103","alias":"html5","type":"collective","title":"HTML","titleHtml":"HTML","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"leadData":{"textHtml":"Предлагаем вашему вниманию подборку с ссылками на новые материалы из области фронтенда и около него.\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fec\u002F0x\u002Fkx\u002Fec0xkxfr5jd-rci1wjo9bmr4cns.jpeg\"\u003E\u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"дайджест"},{"titleHtml":"фронтенд"},{"titleHtml":"css"},{"titleHtml":"js"},{"titleHtml":"es6"},{"titleHtml":"vue"},{"titleHtml":"react"},{"titleHtml":"angular"},{"titleHtml":"ember"},{"titleHtml":"html5"},{"titleHtml":"браузеры"},{"titleHtml":"ссылки"}]},"580084":{"id":"580084","timePublished":"2021-09-26T19:30:13+00:00","isCorporative":false,"lang":"ru","titleHtml":"Telegram Bots vs Google Forms","editorVersion":"2.0","postType":"article","postLabels":[],"author":{"id":"2705023","alias":"dm_aq","fullname":null,"avatarUrl":"","speciality":""},"statistics":{"commentsCount":4,"favoritesCount":21,"readingCount":4056,"score":7,"votesCount":7},"hubs":[{"relatedData":null,"id":"144","alias":"open_source","type":"collective","title":"Open source","titleHtml":"Open source","isProfiled":true},{"relatedData":null,"id":"19441","alias":"kotlin","type":"collective","title":"Kotlin","titleHtml":"Kotlin","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EGoogle forms отличный инструмент для решения простых организационных задач, например, сбор информации для регистрации людей на небольшое мероприятие. Но что если мы попытаемся решить эту задачу по другому? Например через telegram.&nbsp;\u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать далее","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"telegrambot"},{"titleHtml":"telegram"},{"titleHtml":"kotlin"},{"titleHtml":"spring"}]},"580086":{"id":"580086","timePublished":"2021-09-26T19:37:10+00:00","isCorporative":false,"lang":"ru","titleHtml":"Термо принтер и JavaScript","editorVersion":"2.0","postType":"article","postLabels":[{"type":"recovery","data":null}],"author":{"id":"1709955","alias":"IIIarp","fullname":"Сергей Шарпов","avatarUrl":"","speciality":"Веб разработчик"},"statistics":{"commentsCount":47,"favoritesCount":35,"readingCount":8887,"score":45,"votesCount":47},"hubs":[{"relatedData":null,"id":"84","alias":"crazydev","type":"collective","title":"Ненормальное программирование","titleHtml":"Ненормальное программирование","isProfiled":true},{"relatedData":null,"id":"357","alias":"javascript","type":"collective","title":"JavaScript","titleHtml":"JavaScript","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EПриобрел я на днях термопринтер (кассовый аппарат, если изволите) жене для магазина и решил что смогу его обуздать как истинный программист и сделать свою веб кассу, вместо того, что-бы использовать платные решения, ведь задача простая, печатать чеки, но это оказалось не так то и просто...\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F4f3\u002F259\u002Fe4e\u002F4f3259e4e73b5bfae82890fd3db512a0.jpg","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F4f3\u002F259\u002Fe4e\u002F4f3259e4e73b5bfae82890fd3db512a0.jpg","fit":"cover","positionY":0,"positionX":0}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"термопринтер"},{"titleHtml":"javascript"},{"titleHtml":"webusb"}]},"580088":{"id":"580088","timePublished":"2021-09-26T21:17:27+00:00","isCorporative":false,"lang":"ru","titleHtml":"Запуск X-приложения в chroot на примере POSE (или «QEMU не нужен»)","editorVersion":"2.0","postType":"article","postLabels":[],"author":{"id":"1481597","alias":"edo1h","fullname":null,"avatarUrl":"","speciality":"немного программист, немного админ"},"statistics":{"commentsCount":5,"favoritesCount":9,"readingCount":1043,"score":11,"votesCount":11},"hubs":[{"relatedData":null,"id":"221","alias":"sys_admin","type":"collective","title":"Системное администрирование","titleHtml":"Системное администрирование","isProfiled":true},{"relatedData":null,"id":"7289","alias":"nix","type":"collective","title":"*nix","titleHtml":"*nix","isProfiled":true}],"flows":[{"id":"6","alias":"admin","title":"Администрирование"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EЭта мини-статья родилась как ответ на статью \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fruvds\u002Fblog\u002F579296\" rel=\"noopener noreferrer nofollow\"\u003EУпрощаем эмуляцию X86 с помощью Live CD\u003C\u002Fa\u003E, в которой для запуска старых 32-битных приложений на 64-битных дистрибутивах Linux предлагалось использовать QEMU + Live CD — по моему мнению «из пушки по воробьям». Опишу своё решение на \u003Ccode\u003Echroot\u003C\u002Fcode\u003E + \u003Ccode\u003Edebootstrap\u003C\u002Fcode\u003E. \u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать далее","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"chroot"},{"titleHtml":"debootstrap"},{"titleHtml":"xwindow"}]},"580090":{"id":"580090","timePublished":"2021-09-26T21:19:11+00:00","isCorporative":false,"lang":"ru","titleHtml":"Сравнение подходов к реализации распределенных транзакций для микросервисов","editorVersion":"2.0","postType":"article","postLabels":[{"type":"sandbox","data":null},{"type":"translation","data":{"originalAuthorName":"Bilgin Ibryam","originalUrl":"https:\u002F\u002Fdevelopers.redhat.com\u002Farticles\u002F2021\u002F09\u002F21\u002Fdistributed-transaction-patterns-microservices-compared"}}],"author":{"id":"194270","alias":"sprosin","fullname":"Sergey Prosin","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fd67\u002F5d8\u002F1d6\u002Fd675d81d6fe5bf69493735cef4910eb5.jpg","speciality":"Веду команды к релизам, пишу статьи, выступаю."},"statistics":{"commentsCount":6,"favoritesCount":83,"readingCount":4162,"score":14,"votesCount":14},"hubs":[{"relatedData":null,"id":"7504","alias":"refactoring","type":"collective","title":"Проектирование и рефакторинг","titleHtml":"Проектирование и рефакторинг","isProfiled":true},{"relatedData":null,"id":"21482","alias":"distributed_systems","type":"collective","title":"Распределённые системы","titleHtml":"Распределённые системы","isProfiled":true},{"relatedData":null,"id":"22115","alias":"microservices","type":"collective","title":"Микросервисы","titleHtml":"Микросервисы","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"6","alias":"admin","title":"Администрирование"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EКак архитектор-консультант в Red Hat, я имел возможность поработать над множеством проектов для наших клиентов. У каждого из них есть свои особенности, которые, однако, имеют некоторые общие черты. Большинство клиентов хотят знать, как скоординировать запись в несколько систем одновременно. Ответ на этот вопрос обычно включает подробное объяснение двойной записи, распределенных транзакций, современных альтернатив, а также возможных сценариев сбоев и недостатков каждого подхода. Как правило, именно в этот момент заказчик понимает, что разделение монолитного приложения на микросервисы - долгий и сложный путь, обычно требующий компромиссов.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fbc4\u002F35d\u002Fff3\u002Fbc435dff35d09143dacf29bbc1e470a7.png","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fbc4\u002F35d\u002Fff3\u002Fbc435dff35d09143dacf29bbc1e470a7.png","fit":"cover","positionY":0,"positionX":0}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"распределенные системы"},{"titleHtml":"микросервисы"},{"titleHtml":"транзакции"},{"titleHtml":"распределенные транзакции"},{"titleHtml":"оркестрация"},{"titleHtml":"оркестрация микросервисов"},{"titleHtml":"хореография"},{"titleHtml":"конвейеры"}]},"580092":{"id":"580092","timePublished":"2021-09-26T21:49:14+00:00","isCorporative":false,"lang":"ru","titleHtml":"30 сентября: Let's Encrypt и конец срока действия IdenTrust DST Root CA X3","editorVersion":"2.0","postType":"article","postLabels":[],"author":{"id":"805873","alias":"rantal","fullname":null,"avatarUrl":"","speciality":""},"statistics":{"commentsCount":89,"favoritesCount":51,"readingCount":15888,"score":43,"votesCount":43},"hubs":[{"relatedData":null,"id":"50","alias":"infosecurity","type":"collective","title":"Информационная безопасность","titleHtml":"Информационная безопасность","isProfiled":true},{"relatedData":null,"id":"17350","alias":"s_admin","type":"collective","title":"Серверное администрирование","titleHtml":"Серверное администрирование","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"6","alias":"admin","title":"Администрирование"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003E30 сентября 2021 14:01:15  GMT оканчивается срок действия корневого сертификата IdenTrust DST Root CA X3.\u003C\u002Fp\u003E\u003Cp\u003EЭто событие достойно вашего внимания по той причине, что после наступления этого момента ряд устаревших систем перестанут доверять сертификатам,&nbsp;выпущенным центром сертификации Let’s Encrypt. С учётом того, что на текущий момент Let's Encrypt предоставляет бесплатные криптографические сертификаты примерно для \u003Ca href=\"https:\u002F\u002Fletsencrypt.org\u002Fstats\u002F\" rel=\"noopener noreferrer nofollow\"\u003E250 миллионов доменных имен\u003C\u002Fa\u003E, а \"устаревшие системы\" - это порой системы возрастом всего 5-6 лет, вряд ли окончание срока действия сертификата&nbsp;DST Root CA X3 пройдёт для всех гладко и незаметно. В чём причина, кого конкретно это затронет, и что можно сделать?\u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать далее","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"let's encrypt"},{"titleHtml":"DST Root CA X3"},{"titleHtml":"корневой сертификат"},{"titleHtml":"https"},{"titleHtml":"tls"},{"titleHtml":"openssl"}]},"580094":{"id":"580094","timePublished":"2021-09-26T22:35:26+00:00","isCorporative":false,"lang":"ru","titleHtml":"Блокчейн нас подвёл? Почему ДЭГ — это плохо и можем ли мы адекватно контролировать процесс подсчёта голосов?","editorVersion":"2.0","postType":"article","postLabels":[],"author":{"id":"206414","alias":"PoltoS","fullname":"Сергей Полторак","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F5cf\u002F03a\u002Fc7f\u002F5cf03ac7fe60ea8a6686bd4c57627ddc.png","speciality":""},"statistics":{"commentsCount":82,"favoritesCount":23,"readingCount":12563,"score":28,"votesCount":50},"hubs":[{"relatedData":null,"id":"118","alias":"crypto","type":"collective","title":"Криптография","titleHtml":"Криптография","isProfiled":true},{"relatedData":null,"id":"210","alias":"it_testing","type":"collective","title":"Тестирование IT-систем","titleHtml":"Тестирование IT-систем","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EИнтересно наблюдать, как дискредитируется термин блокчейна на выборах в госдуму. Вроде голосование было на блокчейне, но его якобы подделали. Т.е. блокчейн можно подделать или ЦИК и ДИТ нам подсунули какой-то лохчейн вместо блокчейна?!? И мало кто обсуждает происходящее по существу без эмоций, связанных с результатами партий и кандидатов.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F6e5\u002F82b\u002F9d0\u002F6e582b9d062dd29fa41c7842a8b76495.jpg","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F6e5\u002F82b\u002F9d0\u002F6e582b9d062dd29fa41c7842a8b76495.jpg","fit":"cover","positionY":0,"positionX":0}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"Криптография"},{"titleHtml":"блокчейн"},{"titleHtml":"открытые данные"},{"titleHtml":"электронное голосование"},{"titleHtml":"выборы"},{"titleHtml":"выборы в госдуму"},{"titleHtml":"дэг"},{"titleHtml":"дэг 2021"}]},"580124":{"id":"580124","timePublished":"2021-09-27T13:03:14+00:00","isCorporative":true,"lang":"ru","titleHtml":"Электролюминесцентные индикаторы из прошлого","editorVersion":"1.0","postType":"article","postLabels":[],"author":{"id":"146371","alias":"radiolok","fullname":"Артем Кашканов","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fa46\u002Fc6a\u002F151\u002Fa46c6a15193f7c0cac79d2736b107358.jpg","speciality":"Релейно-декатронный маньяк"},"statistics":{"commentsCount":4,"favoritesCount":10,"readingCount":1142,"score":19,"votesCount":19},"hubs":[{"relatedData":null,"id":"19791","alias":"ruvds","type":"corporative","title":"Блог компании RUVDS.com","titleHtml":"Блог компании RUVDS.com","isProfiled":false},{"relatedData":null,"id":"21484","alias":"electronics","type":"collective","title":"Производство и разработка электроники","titleHtml":"Производство и разработка электроники","isProfiled":true},{"relatedData":null,"id":"21906","alias":"history","type":"collective","title":"История IT","titleHtml":"История IT","isProfiled":false},{"relatedData":null,"id":"21930","alias":"antikvariat","type":"collective","title":"Старое железо","titleHtml":"Старое железо","isProfiled":false}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"leadData":{"textHtml":"Сегодня речь пойдёт об электролюминесцентных индикаторах. Но, не о тех, которые окружают вас повсюду и к которым вы привыкли, а о других — получивших огромную популярность в 60-е годы прошлого века, и так же стремительно канувших в небытие. Заодно запущу свою коллекцию индикаторов, как серийно выпускавшихся, так и уникальных опытных и даже — лабораторных образцов.\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fruvds\u002Fblog\u002F523004\u002F\"\u003E\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F94e\u002F51f\u002F459\u002F94e51f459ae59c9d2fe6c448cb07bcca.gif\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fa\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"Индикатор"},{"titleHtml":"электролюминесцентность"},{"titleHtml":"ruvds_статьи"}]},"580150":{"id":"580150","timePublished":"2021-09-27T10:50:03+00:00","isCorporative":true,"lang":"ru","titleHtml":"Топ-5 когнитивных искажений при планировании в IT","editorVersion":"2.0","postType":"article","postLabels":[],"author":{"id":"2794469","alias":"KM_QA","fullname":null,"avatarUrl":"","speciality":""},"statistics":{"commentsCount":1,"favoritesCount":22,"readingCount":2349,"score":15,"votesCount":15},"hubs":[{"relatedData":null,"id":"14332","alias":"oleg-bunin","type":"corporative","title":"Блог компании Конференции Олега Бунина (Онтико)","titleHtml":"Блог компании Конференции Олега Бунина (Онтико)","isProfiled":false},{"relatedData":null,"id":"19583","alias":"dev_management","type":"collective","title":"Управление разработкой","titleHtml":"Управление разработкой","isProfiled":true},{"relatedData":null,"id":"20736","alias":"hr_management","type":"collective","title":"Управление персоналом","titleHtml":"Управление персоналом","isProfiled":true},{"relatedData":null,"id":"20754","alias":"tech_events","type":"collective","title":"Конференции","titleHtml":"Конференции","isProfiled":false},{"relatedData":null,"id":"21990","alias":"brain","type":"collective","title":"Мозг","titleHtml":"Мозг","isProfiled":false}],"flows":[{"id":"3","alias":"management","title":"Менеджмент"},{"id":"4","alias":"marketing","title":"Маркетинг"},{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EЭта статья подходит для тимлидов и их подопечных, а также для всех, кто оценивает проекты и задачи. Я расскажу, как и почему мы делаем ошибки из-за когнитивных искажений. Попадаем в них мы почти все, просто потому что мы живые люди. И на примере одного дня из жизни тимлида я хочу показать, в какие искажения чаще всего влетают в IT, и&nbsp; — самое полезное&nbsp; —&nbsp; как из них можно выходить.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EЗамечу, что искать когнитивные искажения стоит, в первую очередь, у себя, а не у коллег. \u003C\u002Fstrong\u003EИ что рассказывать про искажения намного проще, чем не влетать в их на практике, однако, если этому научиться, то в перспективе это изрядно окупается, потому что экономит и время, и деньги, помогая и нам, и команде.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb78\u002F76f\u002F001\u002Fb7876f0010e85c328462a735df0b76e8.jpg","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb78\u002F76f\u002F001\u002Fb7876f0010e85c328462a735df0b76e8.jpg","fit":"cover","positionY":0,"positionX":0}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"когнитивные искажения"},{"titleHtml":"нейрофизиология"},{"titleHtml":"мозг"},{"titleHtml":"психология"},{"titleHtml":"тимлидство"},{"titleHtml":"тимлид"},{"titleHtml":"управление людьми"},{"titleHtml":"управление проектами и командой"},{"titleHtml":"управление командой"},{"titleHtml":"управление персоналом"}]},"580172":{"id":"580172","timePublished":"2021-09-27T11:45:49+00:00","isCorporative":true,"lang":"ru","titleHtml":"Небинарный ngIf*","editorVersion":"2.0","postType":"article","postLabels":[],"author":{"id":"1050218","alias":"Waterplea","fullname":"Александр Инкин","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fa70\u002F569\u002Ff31\u002Fa70569f31346559ce2b8b875e7f97480.jpg","speciality":"Google Developer Expert | Angular"},"statistics":{"commentsCount":0,"favoritesCount":6,"readingCount":456,"score":8,"votesCount":8},"hubs":[{"relatedData":null,"id":"17420","alias":"tinkoff","type":"corporative","title":"Блог компании TINKOFF","titleHtml":"Блог компании TINKOFF","isProfiled":false},{"relatedData":null,"id":"91","alias":"webdev","type":"collective","title":"Разработка веб-сайтов","titleHtml":"Разработка веб-сайтов","isProfiled":true},{"relatedData":null,"id":"18109","alias":"angular","type":"collective","title":"Angular","titleHtml":"Angular","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EВам когда-нибудь хотелось отобразить состояние загрузки, пока \u003Ccode\u003EngIf\u003C\u002Fcode\u003E ждет ответа от \u003Ccode\u003Easync\u003C\u002Fcode\u003E-пайпа? Или, может, вы мечтали передать в \u003Ccode\u003EngFor\u003C\u002Fcode\u003E шаблон для пустого массива? Возможно, вы бросили это, потому что вам не хотелось реализовывать базовую логику этих директив самому. На самом деле в этом нет нужды! Один и тот же селектор может подцепить несколько директив, что позволяет расширить функциональность встроенных директив дополнительной логикой.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F846\u002F786\u002F3e2\u002F8467863e2df65db32cb31f4b16c822ef.png","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F846\u002F786\u002F3e2\u002F8467863e2df65db32cb31f4b16c822ef.png","fit":"cover","positionY":0,"positionX":0}},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"template"},{"titleHtml":"directive"},{"titleHtml":"angular"},{"titleHtml":"structural"}]},"580196":{"id":"580196","timePublished":"2021-09-27T12:28:15+00:00","isCorporative":true,"lang":"ru","titleHtml":"Зачем нужен динамический анализ кода, на примере проекта PVS-Studio","editorVersion":"1.0","postType":"article","postLabels":[],"author":{"id":"2302295","alias":"MrROBUST","fullname":"Алексей Говоров","avatarUrl":"","speciality":"Пользователь"},"statistics":{"commentsCount":0,"favoritesCount":2,"readingCount":228,"score":8,"votesCount":8},"hubs":[{"relatedData":null,"id":"18095","alias":"pvs-studio","type":"corporative","title":"Блог компании PVS-Studio","titleHtml":"Блог компании PVS-Studio","isProfiled":false},{"relatedData":null,"id":"559","alias":"cpp","type":"collective","title":"C++","titleHtml":"C++","isProfiled":true},{"relatedData":null,"id":"11606","alias":"vs","type":"collective","title":"Visual Studio","titleHtml":"Visual Studio","isProfiled":true},{"relatedData":null,"id":"21456","alias":"win_dev","type":"collective","title":"Разработка под Windows","titleHtml":"Разработка под Windows","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EВ разговоре с Маршаллом Клоу на подкасте CppCast #300 ABI Stability была затронута достаточно давняя новость о поддержке компиляторами Visual Studio инструмента AddressSanitizer (ASan). Мы уже достаточно давно внедрили ASan в свою систему тестирования и хотим рассказать о паре интересных ошибок, которые он помог найти.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F7ef\u002F2db\u002F210\u002F7ef2db210d677f9a8c07026d4361d3ba.png\" alt=\"0868_PVS-Studio_ASan_ru\u002Fimage2.png\"\u003E\u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"pvs-studio"},{"titleHtml":"clang"},{"titleHtml":"asan"},{"titleHtml":"sanitizer"},{"titleHtml":"динамический анализ кода"}]},"580210":{"id":"580210","timePublished":"2021-09-27T12:53:02+00:00","isCorporative":false,"lang":"ru","titleHtml":"PHP Дайджест № 212 (13 – 27 сентября 2021)","editorVersion":"1.0","postType":"article","postLabels":[],"author":{"id":"100489","alias":"pronskiy","fullname":"Роман Пронский","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F27f\u002Fb99\u002Feb3\u002F27fb99eb3e30e3221c5839e88be02395.jpg","speciality":"PHP"},"statistics":{"commentsCount":0,"favoritesCount":4,"readingCount":1583,"score":18,"votesCount":18},"hubs":[{"relatedData":null,"id":"91","alias":"webdev","type":"collective","title":"Разработка веб-сайтов","titleHtml":"Разработка веб-сайтов","isProfiled":true},{"relatedData":null,"id":"260","alias":"php","type":"collective","title":"PHP","titleHtml":"PHP","isProfiled":true},{"relatedData":null,"id":"477","alias":"symfony","type":"collective","title":"Symfony","titleHtml":"Symfony","isProfiled":true},{"relatedData":null,"id":"9554","alias":"yii","type":"collective","title":"Yii","titleHtml":"Yii","isProfiled":true},{"relatedData":null,"id":"18812","alias":"laravel","type":"collective","title":"Laravel","titleHtml":"Laravel","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"leadData":{"textHtml":"\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fek\u002F6r\u002Fr1\u002Fek6rr1odvyzb89tfv0lq4cmfxi4.jpeg\"\u003E\u003C\u002Fdiv\u003E\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nПодборка свежих новостей и материалов из мира PHP.\u003Cbr\u003E\r\nВышел PHP 8.1 RC2 и уже доступен первый пакет с использованием перечислений, будет сделан форк Magento, новый тип стандартов PER в дополнение к PSR, стартовала PhpStorm 2021.3 EAP, Symfony 6 будет полностью типизирован — как обновляться?\u003Cbr\u003E\r\nДля PHP 8.2 предложены новые оптимизированные структуры данных.\u003Cbr\u003E\r\nТакже в выпуске порция инструментов, полезные статьи, видео и анонсы двух митапов.\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nПриятного чтения!\u003Cbr\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"status":"published","plannedPublishTime":null,"checked":null,"tags":[{"titleHtml":"дайджест"},{"titleHtml":"php-дайджест"},{"titleHtml":"PHP"},{"titleHtml":"Symfony"},{"titleHtml":"Laravel"},{"titleHtml":"Magento"},{"titleHtml":"PHPUnit"},{"titleHtml":"PHP 8.1"},{"titleHtml":"PHP 8.2"}]}},"articlesIds":{"ARTICLES_LIST_TOP_PERIOD_DAILY":["580060","580086","580092","579542","580094","579854","578296","580124","580210","580080","580150","580090","580088","580008","579772","580196","580172","580052","580048","580084"]},"isLoading":false,"pagesCount":{"ARTICLES_LIST_TOP_PERIOD_DAILY":3},"route":{"name":"ARTICLES_LIST_TOP_PERIOD","params":{"period":"daily"},"query":{}},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":["424461","335560","151009"],"similarListRefs":{"151009":{"id":"151009","timePublished":"2012-09-06T21:29:12+00:00","isCorporative":false,"lang":"ru","titleHtml":"Как я подружил Unity3D и F#","editorVersion":"1.0","postType":"article","postLabels":[{"type":"sandbox","data":null}],"author":{"id":"198485","alias":"6opoDuJIo","fullname":"Рыгор Бородулин","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fd1b\u002F2b0\u002F64f\u002Fd1b2b064f96bc24b67e0afad12840945.jpg","speciality":"Любитель ракет и сладких конфет"},"statistics":{"commentsCount":6,"favoritesCount":77,"readingCount":19432,"score":35,"votesCount":55},"hubs":[{"id":"546","alias":"net","type":"collective","title":".NET","titleHtml":".NET","isProfiled":true},{"id":"17188","alias":"compilers","type":"collective","title":"Компиляторы","titleHtml":"Компиляторы","isProfiled":true},{"id":"17831","alias":"unity","type":"collective","title":"Unity","titleHtml":"Unity","isProfiled":true},{"id":"21364","alias":"fsharp","type":"collective","title":"F#","titleHtml":"F#","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка","titleHtml":"Разработка"}],"relatedData":null,"leadData":{"textHtml":"\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage2\u002Fc5b\u002F015\u002Fa2f\u002Fc5b015a2ff38be3eb814821840f5e76d.jpg\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ последнее время я стал все больше и больше интересоваться функциональным программированием, и при выборе языка предо мною пал выбор среди двух очень понравившихся мне языков — \u003Ca href=\"http:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FHaskell\"\u003EHaskell\u003C\u002Fa\u003E и \u003Ca href=\"http:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FFSharp\"\u003EF#\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\nВ F# меня соблазнило то, что его можно компилировать в MSIL сборки, что обеспечивает возможность использования библиотек классов F# в других языках Microsoft .Net, а также то, что он и сам может их использовать. Ко всему прочему, я ещё и начинающий разработчик Unity3D, и мне в голову пришла мысль: если компилируется в MSIL, то может можно использовать F# скрипты в Unity? Гугление дало ответ: по-человечески нельзя. Можно создать библиотеку классов, поставить в проекте ссылки на библиотеку UnityEngine.dll, компилировать и импортировать как \u003Ca href=\"http:\u002F\u002Fdocs.unity3d.com\u002FDocumentation\u002FManual\u002FAssetImportandCreation.html\"\u003Eассет\u003C\u002Fa\u003E, после чего добавлять компоненты Mono-behaviour напрямую из библиотеки, но это не слишком удобно, согласитесь. Однако, пройдя гугл, Reflection и \u003Ca href=\"http:\u002F\u002Fdocs.unity3d.com\u002FDocumentation\u002FScriptReference\u002F\"\u003Eсправку по Unity\u003C\u002Fa\u003E, мне все таки удалось приблизить(но не повторить в точности) работу с F# скриптами внутри редактора к тому виду, в котором производится работа со скриптами на встроенных языках. Подробности — под хабракатом.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n","imageUrl":null,"buttonTextHtml":"Показать подробно","image":null},"status":"published","plannedPublishTime":null,"checked":null},"335560":{"id":"335560","timePublished":"2017-08-14T07:54:32+00:00","isCorporative":true,"lang":"ru","titleHtml":"Погружение в F#. Пособие для C#-разработчиков","editorVersion":"1.0","postType":"article","postLabels":[{"type":"translation","data":{"originalAuthorName":"cartermp","originalUrl":"https:\u002F\u002Fblogs.msdn.microsoft.com\u002Fdotnet\u002F2017\u002F07\u002F24\u002Fget-started-with-f-as-a-c-developer\u002F"}}],"author":{"id":"399812","alias":"Schvepsss","fullname":null,"avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F83b\u002Fba1\u002F675\u002F83bba1675ff4cc70994099e6246adda9.png","speciality":null},"statistics":{"commentsCount":74,"favoritesCount":251,"readingCount":68373,"score":46,"votesCount":48},"hubs":[{"id":"5058","alias":"microsoft","type":"corporative","title":"Блог компании Microsoft","titleHtml":"Блог компании Microsoft","isProfiled":false},{"id":"546","alias":"net","type":"collective","title":".NET","titleHtml":".NET","isProfiled":true},{"id":"11272","alias":"mono","type":"collective","title":"Mono и Moonlight","titleHtml":"Mono и Moonlight","isProfiled":true},{"id":"17718","alias":"csharp","type":"collective","title":"C#","titleHtml":"C#","isProfiled":true},{"id":"21364","alias":"fsharp","type":"collective","title":"F#","titleHtml":"F#","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка","titleHtml":"Разработка"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003EЭтот пост будет не о том, как «перевести» код с C# на F#: различные парадигмы делают каждый из этих языков лучшим для своего круга задач. Однако вы сможете оценить все достоинства функционального программирования быстрее, если не будете думать о переводе кода из одной парадигмы в другую. Настало время любопытных, пытливых и готовых изучать совершенно новые вещи. Давайте начнем!\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fweb\u002F794\u002F67d\u002F0df\u002F79467d0dfc8142de801ed176c404dffe.jpg\"\u003E\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cblockquote\u003EВсе материалы из серии переводов \u003Ca href=\"http:\u002F\u002Ffsharplang.ru\"\u003Eрусскоязычного сообщества F#-разработчиков\u003C\u002Fa\u003E вы сможете найти по тегу \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fsearch\u002F?q=%23fsharplangru#h\"\u003E#fsharplangru\u003C\u002Fa\u003E.\u003C\u002Fblockquote\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше →","image":null},"status":"published","plannedPublishTime":null,"checked":null},"424461":{"id":"424461","timePublished":"2018-09-26T09:33:54+00:00","isCorporative":false,"lang":"ru","titleHtml":"Зачем изучать непопулярные языки. Пример сообщества F#","editorVersion":"1.0","postType":"article","postLabels":[],"author":{"id":"1756299","alias":"arttom","fullname":"Артем Малышев","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F990\u002F394\u002F3e0\u002F9903943e0a8be51830493cb5fe92a921.jpg","speciality":"Редактор, сценарист, альпинист, книжный червь"},"statistics":{"commentsCount":164,"favoritesCount":126,"readingCount":27426,"score":34,"votesCount":40},"hubs":[{"id":"546","alias":"net","type":"collective","title":".NET","titleHtml":".NET","isProfiled":true},{"id":"17718","alias":"csharp","type":"collective","title":"C#","titleHtml":"C#","isProfiled":true},{"id":"21364","alias":"fsharp","type":"collective","title":"F#","titleHtml":"F#","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка","titleHtml":"Разработка"}],"relatedData":null,"leadData":{"textHtml":"\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fza\u002Ffc\u002F5b\u002Fzafc5b7humaid3herpmsg3xpw5q.jpeg\"\u003E\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nБывают культовые фильмы, игры, книги или музыка — их страшно любит сплоченное сообщество, профессионалы и критики. Но коммерческого успеха и широкой популярности нет. Мне в таких ситуациях обычно до боли обидно.\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nВ разработке хорошие технологии тоже не всегда становятся массовыми. Например, F#. Все что я о нем знаю — это дико крутой, но совершенно непопулярный язык, после которого разработчики уже не могут просто так возвращаться к своим привычным языкам. \u003Cbr\u003E\r\n\u003Cbr\u003E\r\nЯ попытался узнать, в чем причина. И вообще — кто те люди, которые на нем пишут, и зачем они это делают, если язык не нужен бизнесу? Для этого я постучался поговорить в русскоязычное сообщество F# в «Телеграме». Здесь — наш круглый стол.\u003Cbr\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше →","image":null},"status":"published","plannedPublishTime":null,"checked":null}}},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{"meroving":{"scoreStats":{"score":64,"votesCount":124},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"36425","alias":"Meroving","fullname":"Дмитрий Ейбоженко","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Ffec\u002Fc12\u002Ffb5\u002Ffecc12fb5c667b1fa4aac44040d7f2c9.jpg","speciality":null}},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.670ab961.js" defer></script><script src="https://assets.habr.com/habr-web/js/chunk-f458c7c4.6e221df6.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.76acc47b.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
